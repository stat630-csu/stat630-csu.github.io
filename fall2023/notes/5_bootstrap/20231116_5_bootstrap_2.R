## ----echo = FALSE, message=FALSE, warning=FALSE-------------------------------------------------------------------------------------------------------------------------------------
library(knitr)
library(ggplot2)
library(dplyr)
library(tidyr)
library(boot)
library(simpleboot)
set.seed(333)

theme_set(theme_bw())
knitr::opts_chunk$set(fig.height = 3)

## ----fig.height = 2.5, fig.width=3, fig.show='hold'---------------------------------------------------------------------------------------------------------------------------------
head(Puromycin)
dim(Puromycin)

ggplot(Puromycin) +
  geom_point(aes(conc, rate))

ggplot(Puromycin) +
  geom_point(aes(log(conc), (rate)))


## ----fig.height = 2.5, fig.width = 3.25, fig.show="hold"----------------------------------------------------------------------------------------------------------------------------
m0 <- lm(rate ~ conc, data = Puromycin)
plot(m0)
summary(m0)
confint(m0)

m1 <- lm(rate ~ log(conc), data = Puromycin)
plot(m1)
summary(m1)
confint(m1)


## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Your turn
reg_func <- function(dat, idx) {
  # write a regression function that returns fitted beta
  reg <- lm(rate ~ log(conc), data = dat[idx,])
  coef(reg)
}

# use the boot function to get the bootstrap samples
boot.reg_paired <- boot(Puromycin, reg_func, 2000)

# examine the bootstrap sampling distribution, make histograms
plot(boot.reg_paired, index = 1)
plot(boot.reg_paired, index = 2)

data.frame(boot.reg_paired$t) |>
  pivot_longer(everything(), names_to = "variable", values_to = "value") |>
  ggplot() +
  geom_histogram(aes(value)) +
  facet_wrap(.~ variable, scales = "free")

# get confidence intervals for beta_0 and beta_1 using boot.ci
boot.ci(boot.reg_paired, type = "bca", index = 1)
boot.ci(boot.reg_paired, type = "bca", index = 2)


## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Your turn
reg_func_2 <- function(dat, idx) {
  # write a regression function that returns fitted beta
  # from fitting a y that is created from the residuals
  reg <- lm(rate ~ log(conc), data = dat)
  resids <- residuals(reg)
  fitted <- reg$fitted.values
  
  resids_star <- resids[idx]
  df_star <- data.frame(rate = fitted + resids_star, conc = dat$conc)
  reg_star <- lm(rate ~ log(conc), data = df_star)
  
  coef(reg_star)
}

# use the boot function to get the bootstrap samples
boot.reg_resid <- boot(Puromycin, reg_func_2, 2000)

# examine the bootstrap sampling distribution, make histograms
data.frame(boot.reg_resid$t) |>
  pivot_longer(everything(), names_to = "variable", values_to = "value") |>
  ggplot() +
  geom_histogram(aes(value)) +
  facet_wrap(.~ variable, scales = "free")

# get confidence intervals for beta_0 and beta_1 using boot.ci
boot.ci(boot.reg_resid, type = "bca", index = 1)
boot.ci(boot.reg_resid, type = "bca", index = 2)



## Suppose we observe a time series $\boldsymbol Y = (Y_1, \dots, Y_n)$ which we assume is generated by an AR(1) process, i.e.,

## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
data(lynx)
plot(lynx)


## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
theta_hat <- mean(lynx)
theta_hat


## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
B <- 1000
n <- length(lynx)


## Your turn: perform the independent bootstrap
## what is the bootstrap estimate se?
theta_hat_iid <- rep(NA, B)
for(i in seq_len(B)) {
  theta_hat_iid[i] <- mean(lynx[sample(seq_len(n), n, replace = TRUE)])
}

ggplot() +
  geom_histogram(aes(theta_hat_iid))

sd(theta_hat_iid)  


## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
acf(lynx)


## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# function to create non-overlapping blocks
nb <- function(x, ell) {
  n <- length(x)
  b <- n %/% ell
  
  blocks <- matrix(NA, nrow = b, ncol = ell)
  for(i in 1:b) {
    blocks[i, ] <- x[((i - 1)*ell + 1):(i*ell)]
  }
  blocks
}

# Your turn: perform the NBB with b = 10 and l = 11
ell <- 11
theta_hat_star_nbb <- rep(NA, B)
nb_blocks <- nb(lynx, ell)
for(i in 1:B) {
  # sample blocks
  # get theta_hat^*
  idx <- sample(seq_len(nrow(nb_blocks)), ell, replace = TRUE)
  theta_hat_star_nbb[i] <- mean(nb_blocks[idx,])
}

# Plot your results to inspect the distribution
data.frame(iid = theta_hat_iid,
           nbb = theta_hat_star_nbb) |>
  pivot_longer(everything(), names_to = "boot", values_to = "theta_hat") |>
  ggplot() +
  geom_histogram(aes(theta_hat)) +
  facet_wrap(. ~ boot)

# What is the estimated standard error of theta hat? The Bias?
block_stats <- function(blocks, n) {
  y_bar_i <- rowMeans(blocks)
  mu_hat <- mean(y_bar_i)
  ell <- ncol(blocks)
  b <- n %/% ell
  
  c(mu_hat, sqrt(mean((y_bar_i - mu_hat)^2) / b))
}

block_stats(nb_blocks, n)
sd(theta_hat_iid)
mean(lynx) ## not the same as the mean of block means because of length of series

## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# function to create overlapping blocks
mb <- function(x, ell) {
  n <- length(x)
  blocks <- matrix(NA, nrow = n - ell + 1, ncol = ell)
  for(i in 1:(n - ell + 1)) {
    blocks[i, ] <- x[i:(i + ell - 1)]
  }
  blocks
}

# Your turn: perform the MBB with l = 11
mb_blocks <- mb(lynx, ell)
theta_hat_star_mbb <- rep(NA, B)
for(i in 1:B) {
  # sample blocks
  # get theta_hat^*
  idx <- sample(seq_len(nrow(mb_blocks)), ell, replace = TRUE)
  theta_hat_star_mbb[i] <- mean(mb_blocks[idx,])
}

# Plot your results to inspect the distribution
data.frame(iid = theta_hat_iid,
           nbb = theta_hat_star_nbb,
           mbb = theta_hat_star_mbb) |>
  pivot_longer(everything(), names_to = "boot", values_to = "theta_hat") |>
  ggplot() +
  geom_histogram(aes(theta_hat)) +
  facet_wrap(. ~ boot)

# What is the estimated standard error of theta hat? The Bias?
block_stats(nb_blocks, n)
block_stats(mb_blocks, n)
sd(theta_hat_iid)

## -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Your turn: Perform the mbb for multiple block sizes l = 1:12
# Create a plot of the se vs the block size. What do you notice?
se_mbb <- rep(NA, 12)
se_nbb <- rep(NA, 12)
for(ell in seq_len(12)) {
  mb_blocks <- mb(lynx, ell)
  nb_blocks <- nb(lynx, ell)
  se_mbb[ell] <- block_stats(mb_blocks, n)[2]
  se_nbb[ell] <- block_stats(nb_blocks, n)[2]
}

## plot
data.frame(ell = 0:12,
           mbb = c(sd(theta_hat_iid), se_mbb),
           nbb = c(sd(theta_hat_iid), se_nbb)) |>
  pivot_longer(-ell, names_to = "boot", values_to = "se") |>
  ggplot() +
  geom_point(aes(ell, se, colour = boot)) +
  geom_line(aes(ell, se, colour = boot))
