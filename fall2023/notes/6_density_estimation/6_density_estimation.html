<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Density Estimation" />






<meta name="description" content="Density Estimation">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"css":["../style/my-style-page.css","default-fonts","default-page","default"],"number_sections":true,"self_contained":true}},"title":"Density Estimation"}
</script>

<title>Density Estimation</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  let beforePaged = PagedConfig.before;
  window.PagedConfig.before = async () => {
    if (beforePaged) await beforePaged();
    return new Promise((resolve, reject) => {
      var script = document.createElement("script");
      script.type = "text/javascript";
      var src = `https://mathjax.rstudio.com/latest/MathJax.js` + "?config=TeX-MML-AM_CHTML";
      if (location.protocol !== "file:" && /^https?:/.test(src))
        src = src.replace(/^https?:/, '');
      script.src = src;
      window.MathJax = {
        AuthorInit: () => {
          MathJax.Hub.Register.StartupHook("Begin", () => {
            MathJax.Hub.Queue(resolve);
          });
        }
      };
      document.getElementsByTagName("head")[0].appendChild(script);
    });
  };
})();
</script>

<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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AAIAFAAsAAEAAAAJAAEAAQD9AAMAAAABABwAAQASAAEAAAAJAAIAAQD3APwAAAABAAIAUwBZAAAB9ABdAAAAAAEYAAABGAAAAvwALgL8AC4C/AAuAvwALgL8AC4C/AAuAvwALgPsABoCsgA+Ap4ARgKeAEYDDAA+AwAAPgKyAD4CsgA+ArIAPgKyAD4CsgA+AqQAPgLQAEYDFAA+AYoAPgGKAD4BigAyAYoANgGKAD4CHAAsAvQAPgKeAD4CngA+A0YAPgMCAD4DAgA+ArwARgK8AEYCvABGArwARgK8AEYCvABGArwARgQYAEYCqAA+AqgAPgK8AEYCzAA+AmwAWALKAEgDDAA0AwwANAMMADQDDAA0AwwANAMEACwELAAmAu4ALgLYACoC2AAqAowARAHuAC4B7gAuAe4ALgHuAC4B7gAuAe4ALgHuAC4CvAAuAgAAFgG0ADABtAAwAgoAMAH0ADABzAAwAcwAMAHMADABzAAwAcwAMAFKABwCHAA0AiAAHAEOACYBDgAmAQ4AJgEaAAcBGgALAQ7/9AFA/9oBQP/aAggAHAEOABwBdAAcAxoAJgIcACYCHAAmAfAAMAHwADAB8AAwAfAAMAHwADAB8AAwAfAAMAL+ADACBgAcAfQAGgH2ADABmgAmAbIANAIOABwBXgAcAhYAIAIWACACFgAgAhYAIAIWACACEgASAwgAEgIIACICEgASAhIAEgISABIBuAAoAhIAHAISABwBfAA+AXwARgJEADACRAB4AkQASgJEAEgCRAA4AkQAVgJEAFACRABaAkQAPAJEAE4BfAAeAXwAVAF8ADQBfABEAXwALAF8ADYBfAA2AXwAPAF8ACgBfAAyAXwAHgF8AFQBfAA0AXwARAF8ACwBfAA2AXwANgF8ADwBfAAoAXwAMgF8AB4BfABUAXwANAF8AEQBfAAsAXwANgF8ADYBfAA8AXwAKAF8ADIAUv+AAzQAVAM0AFQDNABEAfYASAHCADgBGABOAfQAiAEYAE4BGABIA0gATgEYAE4BGABOAqwAUQEYAE4B1gBAAdYAIgGKAFYA8ABWARgASAHCADgCCAAAAaQAaAGkAFQBfAB4AXwARgFyAGIBcgAwA+gAPAJsADwBcgA8AXIAPAHgAGwB4AByAUoAbAFKAFsB0gBIAdIARgHSAEgBGABGARgASAEYAEgBGAAAAKQAAAAAAAACRABwAkQANAJEAD4CRAAiAtAAQAJEAA4CMAAwA6wAMAOsADADrACcA6wAMAOsADADrABQA6wAVAOsADAClAAwAkQAMAJeAD4DXABgAXgAMAF4ADADNAAwAxIANgIcAEACgABkAzQAMAM0ADAD1AAeAkQAmgEcAHgBHAB4AkQAPgEEACwBrAAsAAD+gAAA/vMAAP7zAAD+gAAA/pgAAP69AAD/NAAA/mgAAP7zAAD+8wAA/mQAAP6MAMgAKADIACgBcQBkAYIAZAHOAGQB5ABkAXEAZAHMAGQBjABkAeQAZAACAAAAAAAA/7UAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAQ0AAAECAAIAAwAkAMkAxwBiAK0AYwCuAJAAJQAmAGQAJwDpACgAZQDIAMoAywApACoAKwAsAMwAzQDOAM8ALQAuAC8BAwAwADEAZgAyANAA0QBnANMAkQCvALAAMwDtADQANQA2ADcAOADUANUAaADWADkAOgA7ADwA6wA9AEQAaQBrAGwAagBuAG0AoABFAEYAbwBHAOoASABwAHIAcwBxAEkASgBLAEwA1wB0AHYAdwB1AE0BBABOAE8BBQBQAFEAeABSAHkAewB8AHoAoQB9ALEAUwDuAFQAVQBWAIkAVwBYAH4AgACBAH8AWQBaAFsAXADsALoAXQDAAMEAnQCeABMAFAAVABYAFwAYABkAGgAbABwBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMAvAD0APUA9gANAD8AwwCHAB0ADwCrAAQAowAGABEAIgCiAAUACgAeABIAQgBeAGAAPgBAAAsADACzALIAEAEkAKkAqgC+AL8AxQC0ALUAtgC3AMQBJQEmAScAhAC9AAcBKACFAJYBKQAOAO8A8AC4ACAAIQAfAJMAYQCkASoACAErASwAIwAJAIgAhgCLAIoAjACDAF8A6ABBAS0BLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwAjQDeANgAjgBDANoA3QDZBE5VTEwETGRvdAd1bmkwMjM3BGxkb3QJemVyby5kbm9tCG9uZS5kbm9tCHR3by5kbm9tCnRocmVlLmRub20JZm91ci5kbm9tCWZpdmUuZG5vbQhzaXguZG5vbQpzZXZlbi5kbm9tCmVpZ2h0LmRub20JbmluZS5kbm9tCXplcm8ubnVtcghvbmUubnVtcgh0d28ubnVtcgp0aHJlZS5udW1yCWZvdXIubnVtcglmaXZlLm51bXIIc2l4Lm51bXIKc2V2ZW4ubnVtcgplaWdodC5udW1yCW5pbmUubnVtcgd1bmkyMDcwB3VuaTAwQjkHdW5pMDBCMgd1bmkwMEIzB3VuaTIwNzQHdW5pMjA3NQd1bmkyMDc2B3VuaTIwNzcHdW5pMjA3OAd1bmkyMDc5B3VuaTAwQUQHdW5pMDBBMAd1bmkyMDA5B3VuaTIwMEIERXVybwd1bmkyMjE1B3VuaTAwQjUHYXJyb3d1cAlhcnJvd2Rvd24GbWludXRlBnNlY29uZAd1bmkwMzA4CWdyYXZlY29tYglhY3V0ZWNvbWIJdGlsZGVjb21iB3VuaTAzMDQNaG9va2Fib3ZlY29tYgxkb3RiZWxvd2NvbWIMdW5pMDMwOC5jYXNlDmdyYXZlY29tYi5jYXNlDmFjdXRlY29tYi5jYXNlDnRpbGRlY29tYi5jYXNlDHVuaTAzMDQuY2FzZQd1bmkwMkJDB3VuaTAyQkIAAQAAAAoATgCaAANERkxUADRjeXJsACRsYXRuABQABAAAAAD//wADAAIABQAIAAQAAAAA//8AAwABAAQABwAEAAAAAP//AAMAAAADAAYACWtlcm4ARmtlcm4ARmtlcm4ARm1hcmsAQG1hcmsAQG1hcmsAQG1rbWsAOG1rbWsAOG1rbWsAOAAAAAIAAgADAAAAAQABAAAAAQAAAAQCPgDUAKoACgAGAgAAAQAIAAEAiACIAAEAWgAMAAsASABCAEIAPAA2ADAAKgAkACQAHgAYAAH/FANeAAH/AAOKAAH/SAOqAAH/AgOGAAH/EgKOAAH/GgJkAAH/DgKMAAH/SAKsAAH/DgKEAAsAAAHCAAABvAAAAbwAAAHCAAABtgAAAbAAAAGkAAABngAAAZgAAAGYAAABkgACAAIA9wD8AAAA/gECAAYABgEAAAEACAABABwAHAABABYADAABAAQAAf9o/z4AAQAAAU4AAQABAP0ABAAAAAEACAABAVgA0gACAPAADAANAMAAugC0AK4AqACiAJwAlgCQAIoAhAB+AHgAcgBsAGYAYABaAGAAVABOAEgAQgA8AIQANgABAQkByAAB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) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page 1;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:nth-last-of-type(1) {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page 1;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            
	//             head 
	//                            tail
	//                                         
	//                                                 
	//            item        item        item        item
	//                      
	//  null prev prev prev prev 
	//           next next next next null
	//                      
	//           data      data      data      data 
	//                      
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	//  4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	//  4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	//  4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	//  4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	//  4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// 4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// 4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	//  4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-' : node.min) +
	                ',' +
	                (node.max === null ? '' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    //  4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    //  4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If strings value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    //  4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>s value.
	            }
	        }
	    }

	    //  4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that its being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldnt be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    //  4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that propertys value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if anyfor example by saying that any pre-defined keywords
	    // in that propertys value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: its defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesnt matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// 5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	//  5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// 5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integers sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // 
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation[min,max]within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [,] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null  stashing allowed, nothing stashed
	    // false  stashing disabled, nothing stashed
	    // anithing else  fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   sources entry.  This value is prepended to the individual
	    //   entries in the source field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   sourceRoot, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,]>"
		},
		"positive-integer": {
			syntax: "<integer [0,]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // 2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the boxs intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>


<style type="text/css">@page {
size: 8.5in 11in; 
}
@page :blank {
}
.pagedjs_page {
--pagedjs-pagebox-width: 8.5in;
--pagedjs-pagebox-height: 11in;
}
.level1 {
break-before: avoid;
}
.red {
color: red;
}
.yourturn {
color: blue;
font-size: 2em;
}
.pagebreak {
break-after: always;
}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Density Estimation</h1>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><strong>Goal:</strong> We are interested in estimation of a density function <span class="math inline">\(f\)</span> using observations of random variables <span class="math inline">\(Y_1, \dots, Y_n\)</span> sampled independently from <span class="math inline">\(f\)</span>.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>Parametric Solution:</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>We will focus on <strong>nonparametric</strong> approaches to density estimation.</p>
<div id="histograms" class="section level1 page-break-before" number="1">
<h1><span class="header-section-number">1</span> Histograms</h1>
<p>One familiar density estimator is a histogram. Histograms are produced automatically by most software packages and are used so routinely to visualize densities that we rarely talk about their underlying complexity.</p>
<div id="motivation" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Motivation</h2>
<p>Recall the definition of a density function
<span class="math display">\[
f(y) \equiv \frac{d}{dy} F(y) \equiv \lim\limits_{h \rightarrow 0} \frac{F(y + h) - F(y - h)}{2h} = \lim\limits_{h \rightarrow 0} \frac{F(y + h) - F(y)}{h},
\]</span>
where <span class="math inline">\(F(x)\)</span> is the cdf of the random variable <span class="math inline">\(Y\)</span>.</p>
<p>Now, let <span class="math inline">\(Y_1, \dots, Y_n\)</span> be a random sample of size <span class="math inline">\(n\)</span> from the density <span class="math inline">\(f\)</span>.</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>A natural finite-sample analog of <span class="math inline">\(f(y)\)</span> is to divide the support of <span class="math inline">\(Y\)</span> into a set of <span class="math inline">\(K\)</span> equi-sized bins with small width <span class="math inline">\(h\)</span> and replace <span class="math inline">\(F(x)\)</span> with the empirical cdf.</p>
<p><br /><br /><br /><br /><br /><br /></p>
</div>
<div id="bin-width" class="section level2 page-break-before" number="1.2">
<h2><span class="header-section-number">1.2</span> Bin Width</h2>
<p><img src="data:image/png;base64,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8GBxHCfpjD755BOugZJWYwMEEEAAAU9A42gEQD2NgD1eddVV0r9//4CVmuIigAACCORT4IYbbkh799p69LLLLks7HzJAAAEEECgcgbFjx8rTTz+ddoWfeuopadiwYdr5kAECCCCAQGEIrF+/Xs4777y0KksL0LT40t+4pKREGjRokH5G5IAAAgggUDACqbS6qY5TVFTE+ac6Cq8RQAABBGoVKC4urnV5fReWlpZyDqovFushgAACCGREgEmQMsJIJggggAACCCCAAAIIIIAAAggggAACCCDgRwECoH48KpQJAQQQQAABBBBAAAEEEEAAAQQQQAABBDIiQAA0I4xkggACCCCAAAIIIIAAAggggAACCCCAAAJ+FCAA6sejQpkQQAABBBBAAAEEEEAAAQQQQAABBBBAICMCBEAzwkgmCCCAAAIIIIAAAggggAACCCCAAAIIIOBHAQKgfjwqlAkBBBBAAAEEEEAAAQQQQAABBBBAAAEEMiJAADQjjGSCAAIIIIAAAggggAACCCCAAAIIIIAAAn4UIADqx6NCmRBAAAEEEEAAAQQQQAABBBBAAAEEEEAgIwIEQDPCSCYIIIAAAggggAACCCCAAAIIIIAAAggg4EcBAqB+PCqUCQEEEEAAAQQQQAABBBBAAAEEEEAAAQQyIkAANCOMZIJAcATKy8uDU1hKigACCCAQGoFIJCLr168PTX2oCAIIIIBAMAQ4/wTjOFFKBLItUJLtHZA/AgjkV8B1XRk+fLh8/vnnMm3aNFm4cKG0aNFCevfuLX369JGTTjpJ2rVrl99CZmjvb731lowYMUIOPvhgOfnkkzOUa93ZrFmzRq677jrp2LGjXHvttXVvwBoIIIBAgQjMmjVLXn31VZk6dapMnz5dNmzYIN27d5ctt9xS9txzTznkkENCI3HxxRfbutx7773SuHHjrNbrvffekw8//FBmz54temHfo0cP66nnPxICCCCAgEghnX9yeQ20ePFiGTp0qD2vr1u3Tvr27Ss77rijHHDAAXzsEPC9AAFQ3x8iCohA6gKrV6+Wu+66Sz766CObSVFRkbRq1Ur0/S+//NL+Gz9+vNx8882y3Xbbpb4jn2xZVlYmP/30k/Tr1y9nJdIA85133inffvutFBcX52y/7AgBBBDwu8DEiRPt96PeJNKkQcHmzZvLjBkz7D89/3z99ddy6aWXSmlpqd+rU2f59PyjadOmTXWum+oK2oJWb7R99dVXNgu9oalJ9z1u3DjRi+Dbb7896wFYu1P+QwABBHwqUGjnn1xdA02aNEluueUW0cCnJj2n//jjj7axzcCBA+Xyyy/nesinfxMUKypAAJRPAgIhFvj73/9ug589e/aUSy65RHbaaafYSWnmzJnyr3/9S95//3254oor5IknnrCtckLMkfGqrV27Vh5++GHRH1kkBBBAAIFKgZ9//lluuOEG+8bgwYPlxBNPlNatW9vXOhTLhAkT5LHHHrMBO20VetVVV1VuzLMaBR599FEb/NQWnxoI3Wqrrey6U6ZMscFmDYw+8sgj9rxeYyYsQAABBEIswPknOwd30aJFcscdd9jg5/HHHy8nnHCCdOjQwfYy1HPT6NGjpVmzZnLRRRdlpwDkikAGBBgDNAOIZIGAHwW0lYjepXMcR4YMGSK77rprLPip5dWLJ7047d+/v2zcuNEGQv1YD7+WSYcU+M1vfmNP9tqyloQAAgggUCng9TwYNGiQ/a70gp+6RsOGDeXwww+X66+/3m6gN+IYG7TSrqZnetNNh3nRc85NN90UC37q+ttss43tzaHPR40aJbouCQEEEChEAc4/2Tnq77zzjqxatUq6dOkiOuRL586d7bXlHnvsIWeeeabdqQ7PQkLAzwK0APXz0aFsCKQhoN3htHuCdo+raYxPvYjS7graBVGDpaeffvpme9SLUh1jTMfR0a7zetLT8dvatm272brarVHz1OXaNVxfa6sUbYGqrVTiu4gvWLDA7lcvhLfddlt7BzE+w+XLl8vSpUulTZs2tg561/G7776zF8k6dqmOYZps0nHStC46Fqp2UdR8tKzx5apPntrNULu9a9p9991l3333lfvvv78+m7IOAgggUBACel7RtMUWW9RY31122UU6deok8+fPt8OI6OvqScca0/PPnDlz7LmgW7du9nu7epd575yh5zttgaIXad988409Z+iNvvgArJ7XfvjhB5tn165dZYcddrDnrvh9x5/PtIWqdvH75Zdf7LlPe1OkMsanlknHQtW66IWjjoPasmXL+N3W+lyHWvHG+9TzavXUq1cve75XM20Btf3221dfhdcIIIBA6AUydf4J0zVQuucf/dDouXW33XaTgw46aLNz5j777GM/VzrXhF6/xZ9zQ/+Bo4KBEiAAGqjD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b/oboKQk+D/FwvT9luzfVBC+M7zvN/0NF4YWUt5Fp9YlTL9LmzRpYr+Xk/0M5nr9dIOW3rlL/3bSzSsXdV+1apX9u9FzUNCT/rb2blrrbwD9zAU9he37Ta9R9Vo1199v2TqXedfd+reu1wxBT3r9o9dBmsL0u1SPk/4m9XvSv3dN6fyWCf6vbr8fpRrK5x00PfkE4eSvrY30AxeEstZAHnvb+yLWN/Q4hKFOenz0AlRPLGE4uWjA3QuAan3CEtTVQEcYPm/6t+MFQMNSJw2yaQA0KMdHLyC984gej2STbqtB1CDUV2/waABUz5eNGjVKtqq+Wz/++03rE5bvt6B8njL9gQjC31D891s63xuZtks1v/gAQRD866qnHh+tk34XBKE+6X5neZ9B/f4LQn31946WOQhlreuzpr8dvABoWH6/6XWd9/vN+2zV5eDn5V4jHS1jLj9z2dqXd90dlJhHXZ8NDX56AdAw/S7V81C2PgN1mSaz3LuBls7feurNR5IpKesigAACCCCAAAIIIIAAAggggAACCCCAAAJ5ECAAmgd0dokAAggggAACCCCAAAIIIIAAAggggAACuREgAJobZ/aCAAIIIIAAAggggAACCCCAAAIIIIAAAnkQIACaB3R2iQACCCCAAAIIIIAAAggggAACCCCAAAK5ESAAmhtn9oIAAggggAACCCCAAAIIIIAAAggggAACeRAgAJoHdHaJAAIIIIAAAggggAACCCCAAAIIIIAAArkRKMnNbtgLAgggUCkwcODAyhc+ezZ69GiflYjiIIAAAggUgkAmz42cywrhE0MdEUAAAQQQQCAZAVqAJqPFuggggAACCCCAAAIIIIAAAggggAACCCAQKAECoIE6XBQWAQQQQAABBBBAAAEEEEAAAQQQQAABBJIRIACajBbrIoAAAggggAACCCCAAAIIIIAAAggggECgBAiABupwUVgEEEAAAQQQQAABBBBAAAEEEEAAAQQQSEaAAGgyWqyLAAIIIIAAAggggAACCCCAAAIIIIAAAoESIAAaqMNFYRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgGQECoMlosS4CCCCAAAIIIIAAAggggAACCCCAAAIIBEqAAGigDheFRQABBBBAAAEEEEAAAQQQQAABBBBAAIFkBAiAJqPFuggggAACCCCAAAIIIIAAAggggAACCCAQKAECoIE6XBQWAQQQQAABBBBAAAEEEEAAAQQQQAABBJIRIACajBbrIoAAAggggAACCCCAAAIIIIAAAggggECgBAiABupwUVgEEEAAAQQQQAABBBBAAAEEEEAAAQQQSEaAAGgyWqyLAAIIIIAAAggggAACCCCAAAIIIIAAAoESIAAaqMNFYRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgGQECoMlosS4CCCCAAAIIIIAAAggggAACCCCAAAIIBEqAAGigDheFRQABBBBAAAEEEEAAAQQQQAABBBBAAIFkBAiAJqPFuggggAACCCCAAAIIIIAAAggggAACCCAQKAECoIE6XBQWAQQQQAABBBBAAAEEEEAAAQQQQAABBJIRIACajBbrIoAAAggggAACCCCAAAIIIIAAAggggECgBAiABupwUVgEEEAAAQQQQAABBBBAAAEEEEAAAQQQSEaAAGgyWqyLAAIIIIAAAggggAACCCCAAAIIIIAAAoESIAAaqMNFYRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgGQECoMlosS4CCCCAAAIIIIAAAggggAACCCCAAAIIBEqAAGigDheFRQABBBBAAAEEEEAAAQQQQAABBBBAAIFkBAiAJqPFuggggAACCCCAAAIIIIAAAggggAACCCAQKAECoIE6XBQWAQQQQAABBBBAAAEEEEAAAQQQQAABBJIRIACajBbrIoAAAggggAACCCCAAAIIIIAAAggggECgBAiABupwUVgEEEAAAQQQQAABBBBAAAEEEEAAAQQQSEaAAGgyWqyLAAIIIIAAAggggAACCCCAAAIIIIAAAoESIAAaqMNFYRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgGQECoMlosS4CCCCAAAIIIIAAAggggAACCCCAAAIIBEqAAGigDheFRQABBBBAAAEEEEAAAQQQQAABBBBAAIFkBAiAJqPFuggggAACCCCAAAIIIIAAAggggAACCCAQKAECoIE6XBQWAQQQQAABBBBAAAEEEEAAAQQQQAABBJIRIACajBbrIoAAAggggAACCCCAAAIIIIAAAggggECgBAiABupwUVgEEEAAAQQQQAABBBBAAAEEEEAAAQQQSEaAAGgyWqyLAAIIIIAAAggggAACCCCAAAIIIIAAAoESIAAaqMNFYRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgGQECoMlosS4CCCCAAAIIIIAAAggggAACCCCAAAIIBEqAAGigDheFRQABBBBAAAEEEEAAAQQQQAABBBBAAIFkBAiAJqPFuggggAACCCCAAAIIIIAAAggggAACCCAQKAECoIE6XBQWAQQQQAABBBBAAAEEEEAAAQQQQAABBJIRIACajBbrIoAAAggggAACCCCAAAIIIIAAAggggECgBAiABupwUVgEEEAAAQQQQAABBBBAAAEEEEAAAQQQSEaAAGgyWqyLAAIIIIAAAggggAACCCCAAAIIIIAAAoESIAAaqMNFYRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgGQECoMlosS4CCCCAAAIIIIAAAggggAACCCCAAAIIBEqAAGigDheFRQABBBBAAAEEEEAAAQQQQAABBBBAAIFkBAiAJqPFuggggAACCCCAAAIIIIAAAggggAACCCAQKAECoIE6XBQWAQQQQAABBBBAAAEEEEAAAQQQQAABBJIRIACajBbrIoAAAggggAACCCCAAAIIIIAAAggggECgBEoCVdp6FLa8vFxeffVV+eyzz2Tp0qWy1VZbyU477SQDBw6U4uLieuRQ8yqu68qtt94qs2bNkjvuuEM6duxY88osQQABBBBAAAEEEEAAAQQQQAABBBBAAIG8C4QqALps2TK55JJLbIBSZdu0aSOjR4+2/z766CO56aabpEGDBimjv/zyyzJ27Fi7/fr161POhw0RQAABBBBAAAEEEEAAAQQQQAABBBBAIDcCoeoCf9ttt9ng55577ikjRoyQ4cOHy0svvSRbbrmlvPfee/Lggw+mrDp16lR57LHHUt6eDRFAAAEEEEAAAQQQQAABBBBAAAEEEEAg9wKhCYB+//338umnn0rjxo3l9ttvl5YtW1rNrl27yr333mu7v48aNUpWrlyZtLJ2q9eu7yUlJWm1IE16x2yAAAIIIIAAAggggAACCCCAAAIIIIAAAmkJhKYL/IQJEyzEgAEDpFGjRlVQtCv8HnvsIRMnThQNgp5yyilVltf14tFHH5VffvlFrrzySnniiSeE7u91ibEcAQQQQAABBBBAAAEEEEAAAQQ8AZ2XhIQAAvkTCE0L0O+++84qavf3REkDoJq+/vrrRItrfG/SpEl2UqW9995bjjnmmBrXYwECCCCAAAIIIIAAAggggAACCCCAAAII+E8g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HRHSL3DDDTfI+PHj3Y4t/7F8iJA5AtYy56qrrnIJuuCCC+S3v/1t5iSOlDiB/v37i9XKa9q0aexaAZr0C1S0xZHdeubn56c/wexRJk2aJJdffrmTGDZsmFx//fWoZJjAwIEDZf369a7254cffphhqSM59957r4waNcpBPProo3LUUUeBUgkC1apVq3CLFmqAVsIJC3ZZ0QuHYHv+V0zAbvqDCy/7z3momGMqt7LCmeAc2Q8c5yiV2uWP2wregvNjNzKcn/IbVvYWVnBa0cLTyk57tu+/cB5k54DvT2adUX7fMut8xEuNVSCwPIhruHg6mT/Pmvbyu1c554nft8pxL89eg982ft/Ko5a+dQs/wLHvE79l6bNP1p4YBClZksSDAAIIIIAAAggggAACCCCAAAIIIIAAAhknQAFoxp0SEoQAAggggAACCCCAAAIIIIAAAggggAACyRKgADRZksSDAAIIIIAAAggggAACCCCAAAIIIIAAAhknQAFoxp0SEoQAAggggAACCCCAAAIIIIAAAggggAACyRKgADRZksSDAAIIIIAAAggggAACCCCAAAIIIIAAAhkn4OlIVn7GpYoEIZBCARuBd8KECW4P9evXlyOPPDKFeyPqighMnz5dVq1a5Tbt37+/1K1btyLRsE2KBFavXi3Tpk1zsXfs2FE6deqUoj0RLQK5JzBjxgz57rvv3IFZ/mP5ECFzBNasWSNTp051CWrXrp106dIlcxJHSpzAu+++60aAr1mzpgwcOBAVBBAoo8APP/wgU6ZMcWu3bdtWunbtWsYtWS1dAu+//77s2rXLjS4+ePDgdO2W/ZRRYP78+bJkyRK3dp8+faRp06Zl3JLVMkWAAtBMOROkAwEEEEAAAQQQQAABBBBAAAEEEEAAAQSSLkAT+KSTEiECCCCAAAIIIIAAAggggAACCCCAAAIIZIoABaCZciZIBwIIIIAAAggggAACCCCAAAIIIIAAAggkXYAC0KSTEiECCCCAAAIIIIAAAggggAACCCCAAAIIZIoABaCZciZIBwIIIIAAAggggAACCCCAAAIIIIAAAggkXaBa0mMkQgSySGDixIny8ccfy4oVK8RGh99///3liCOOkOOPPz6LjiJ3krpz50556aWX3AiV69evd6OL9+rVS4YMGSJ5eXm5c6BZfCR8Z7L45JH0jBJYu3atjBkzRhYu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" width="672" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAVAoAMABAAAAAEAAAJAAAAAAMyroGYAAEAASURBVHgB7J0HfBzF9cffnqrl3nADG1yxwcaEYqoNphkIEHoJJZBACIEQUoAQWmihhRbyp4U0IAZjQgcDxhRjejXFNjamGGPAlrtcZOn2P7+5m9NIPulOd7un3b3f+3wk7e3Ozrz3ndXOzZuZN46rRCgkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkEEECsQjaRJNIgARIgARIgARIgARIgARIgARIgARIgARIgARIQBOgA5QPAgmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQQGQJ0AEa2aqlYSRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAnSA8hkgARIgARIgARIgARIgARIgARIgARIgARIgARKILAE6QCNbtTSMBEiABEiABEiABEiABEiABEiABEiABEiABEiADlA+AyRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAApElQAdoZKuWhpEACZAACZAACZAACZAACZAACZAACZAACZAACdABymeABEiABEiABEiABEiABEiABEiABEiABEiABEggsgToAI1s1dIwEiABEiABEiABEiABEiABEiABEiABEiABEiABOkD5DJAACZAACZAACZAACZAACZAACZAACZAACZAACUSWAB2gka1aGkYCJEACJEACJEACJEACJEACJEACJEACJEACJEAHKJ8BEiABEiABEiABEiABEiABEiABEiABEiABEiCByBKgAzSyVUvDSIAESIAESIAESIAESIAESIAESIAESIAESIAESomgbQisXr1aHn/88bYpnKWSAAmQAAmEnsDAgQNlzJgxOdkxbdo0+e6773K6lzeRAAmQAAmQwLHHHpsThC+++EJee+21nO7lTSRAAiRAAiSw0047yRZbbJETCDpAc8KW/03V1dVy6aWX5p8RcyABEiABEihKAvvvv3/ODtDbbrtNZs6cWZTcaDQJkAAJkED+BI455hhxHKfVGb3xxhvsA7WaGm8gARIgARIwBOBHowPU0AjZ33PPPVdGjRoVMq2pLgmQAAmQQFsSuOiii/IuHrNHzzrrrLzzYQYkQAIkQALFQ2Dq1Knyr3/9K2+D7777bqmoqMg7H2ZAAiRAAiRQHARqa2vllFNOyctYzgDNC1/+N5eWlkp5eXn+GTEHEiABEiCBoiGQy6ybpnBisRjbn6ZQ+JkESIAESKBFAiUlJS1ez/ZiWVkZ26BsYTEdCZAACZCAJwS4CZInGJkJCZAACZAACZAACZAACZAACZAACZAACZAACZBAEAnQARrEWqFOJEACJEACJEACJEACJEACJEACJEACJEACJEACnhCgA9QTjMyEBEiABEiABEiABEiABEiABEiABEiABEiABEggiAToAA1irVAnEiABEiABEiABEiABEiABEiABEiABEiABEiABTwjQAeoJRmZCAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiQQRAJ0gAaxVqgTCZAACZAACZAACZAACZAACZAACZAACZAACZCAJwToAPUEIzMhARIgARIgARIgARIgARIgARIgARIgARIgARIIIgE6QINYK9SJBEiABEiABEiABEiABEiABEiABEiABEiABEjAEwJ0gHqCkZmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAkEkQAdoEGsFepEAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiTgCQE6QD3ByExIIDwE1q9fHx5lqSkJkAAJkEBkCMTjcamtrY2MPTSEBEiABEggHATY/oSjnqglCfhNoNTvApg/CZBA2xJwXVceffRReeedd+Szzz6T77//Xjp16iQDBw6UwYMHyxFHHCE9evRoWyU9Kv3JJ5+UJ554QsaPHy9HHnmkR7lmzmbNmjVywQUXSK9eveQPf/hD5huYggRIgASKhMCCBQtk8uTJMm/ePPniiy9kw4YNstlmm8mgQYNkzJgxstdee0WGxC9+8Qttyw033CDt2rXz1a6XX35ZZsyYIV9//bWgY9+/f3/NE+0fhQRIgARIQKSY2p9C9oGWLFkikyZN0u36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BYMhYXAOZHpAovp+gwMUdRR2QduDOoJE7f2G73BRcBDgO5xxgOYTCiQozyo6nnjHwcGWz7K+Qtnj1cSB/v37h8JeDMDh/8YruwtVT+nKwQAPJkxAzDOXLl2Yzq1Zs0Y7daP2fsMzF6V+d1jeb5mefQwg4JmDROl7KdqhMAwomglSmeqppeuMPN0SHV4jARIgARIgARIgARIgARIgARIgARIgARIgARIINQE6QENdfVSeBEiABEiABEiABEiABEiABEiABEiABEiABEigJQJ0gLZEh9dIgARIgARIgARIgARIgARIgARIgARIgARIgARCTYAO0FBXH5UnARIgARIgARIgARIgARIgARIgARIgARIgARJoiQAdoC3R4TUSIAESIAESIAESIAESIAESIAESIAESIAESIIFQE6ADNNTVR+VJgARIgARIgARIgARIgARIgARIgARIgARIgARaIkAHaEt0eI0ESIAESIAESIAESIAESIAESIAESIAESIAESCDUBEpDrX0a5devXy+TJ0+Wt99+W5YtWyZDhgyR0aNHy4QJE6SkpCTNHdmfcl1XLrvsMlmwYIFceeWV0qtXr+xvZkoSIAESIAESIAESIAESIAESIAESIAESIAESIIGCE4iUA3T58uVyxhlnaAclSHbr1k2mTJmif1599VW55JJLpLy8PGfIDzzwgEydOlXfX1tbm3M+vJEESIAESIAESIAESIAESIAESIAESIAESIAESKAwBCK1BP7yyy/Xzs8xY8bIE088IY8++qjcf//9MmjQIHn55ZfllltuyZnqvHnz5I477sj5ft5IAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRQeAKRcYB+8skn8uabb0q7du3kiiuukM6dO2ua/fr1kxtuuEEvf3/66adl1apVraaMZfVY+l5aWprXDNJWF8wbSIAESIAESIAESIAESIAESIAESIAESIAESIAE8iIQGQfoiy++qEGMGzdOKisrG0HBUvgdd9xRsGwdTtDWyu233y6ff/65nHXWWVJVVdXa25meBEiABEiABEiABEiABEiABEiABEiABEiABEigjQhExgH68ccfa4RY/p5O4ACFzJw5M93lZs+99dZbelOlnXfeWQ4++OBm0/ECCZAACZAACZAACZAACZAACZAACZAACZAACZBA8AhEZhOkhQsXarpdunRJ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AAIQgAAEIAABCEAAAlEngAA06kjJEAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEEgWAghAk6UnqAcEIAABCEAAAhCAAAQgAAEIQAACEIAABCAQdQL1op4jGUIghQh89tln8uWXX8rSpUvFosPvs88+csghh8jxxx+fQq1In6qWlJTIm2++6SJUFhUVuejigwYNkmHDhkl2dnb6NDSFW8I9k8KdR9WTisC6detk9OjRMm/ePFm1apW0atVKunTpImeddZa0bNkyqeqaKZWx6K5vvPGGLFq0SPLz82XAgAFyzDHHSNeuXTMFQVK3k/EnqbuHyqUYAe6n5Oowxp/k6o/KteGdrTKR1P1OFPjU7TtqHgEBE7Rdd9118tNPP7lcCgoK3P9Nmza5/yZ0u/feeyUvLy+CUri0LgQ2bNggl19+uSxZssRd1qxZM1m/fr3bPvLII+X222+XnJycumTJuVEkwD0TRZhklfEEPv/8c7n77rtl+/btbnGnefPmYi/Xu3fvduPODTfcIMcee2zGc4onAFt8e+ihh1yRjRo1kh07driPvQfcc889sv/++8ezOpQVRIDxJwgGmxCIkAD3U4QAY3A5408MoEYxS97ZoggzCbLCBD4JOoEqxJ/AY4895oSfnTt3lqefflo++OAD93nqqaekY8eOMnHiRHnkkUfiX7EMLvHOO+90ws8hQ4bI+++/L++++66MGjVKunXrJuPGjZOHH344g+kkvuncM4nvA2qQHgSWLVsWEH5eeOGF8u9//1veeust9//88893QlETuHmLQenR6uRuxZQpU9wYY4ts//M//yMffvihfPTRR3LFFVe4/hg5cqSsXLkyuRuRxrVj/EnjzqVpcSfA/RR35NUWyPhTLZ6EH+SdLeFdEPUKIACNOlIyTHYC27Ztk3/961+SlZUld9xxh/Tq1StQ5d69e7vJj+0wIZydS4o9genTp8v333/vNJ/uuusuKSwsdIW2b99eHnjgAachNWbMGNm8eXPsK0MJexHgntkLCTsgEDaB9957zwnVjjvuOLnoooskNzfX5WX/L774YjnqqKOkuLhY7DxSfAi88MIL4vf75dxzzxWzOPD5fFK/fn0544wz5PTTT5edO3fKO++8E5/KUEoFAow/FXDwBQIREeB+ighfTC5m/IkJ1qhlyjtb1FAmTUYIQJOmK6hIvAjYSpuZGZqm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s7PlgAMOqFBW8JfJkydLcXGxNGnSRHr27Bl8KLDt9/tlzpw5MmnSJJk2bZq0a9dOBg0aJAMGDJC8vLzAeWxAAAIQgAAEIAABCESPAALQ6LEkJwhAAAIQgAAEIACBMAl89dVXcu6557qrX331VRk+fHiVOd16663y+OOPS05OjixfvrzCeU8++aSMHDlStmzZUmG/92XIkCHy9NNPS//+/b1dNf6/44475Pnnn5f8/Pwq87VMTjnlFDFh6YknnigffPDBXvnOnTvXtfG7777b61irVq3kmWeekV/84hd7HWMHBCAAAQhAAAIQgEBkBOq2/B1ZWVwNAQhAAAIQgAAEIACBkAROO+20gCbnyy+/HPIc27ljxw55/fXX3fGTTz5Zmjdv7rZNs9IEj7///e+dkNI0Ky3PESNGuP0tWrRw55nw8ZBDDpGioiL3PV5/3n77bafpaeX7fD456KCD5MILL5TjjjtOCgoKZPXq1WLtueGGG+JVJcqBAAQgAAEIQAACGUMAAWjGdDUNhQAEIAABCEAAAslLwMy/zz77bFfBsWPHOpPzULX98MMPZf369e6QCRC9NGbMGLGPpT/84Q+ycOFCeeutt+Spp55y2pimmXnBBRe446Yd+sQTT7jtePwxYesll1wiW7dulY4dO8pnn30mJgh99tln5eOPP5b58+fL8ccf76py7733ytdffx2PalEGBCAAAQhAAAIQyBgCCEAzpqtpKAQgAAEIQAACEEhuAp5Ac9euXQEtz8o1fumll9yutm3byrBhwwKHH3roIbfdoUMHse369esHjtlGo0aN5NFHH5V69co8QIUyQ69wQRS/3HbbbWJ+S8336KhRo2To0KEVcjctVhPsmj9TS1dccYWUlpZWOIcvEIAABCAAAQhAAALhE0AAGj47roQABCAAAQhAAAIQiCIB889pQYoshTKDN03K999/3x03f6EWlMhL99xzj4wePdppVQbv947bf/PhaQJSS1X5CHUHo/hn9+7dTgvVsvz5z38uhx56aMjcTTBrgk9LEyZMkKlTp4Y8j50QgAAEIAABCEAAAnUnQBCkujPjCghAAAIQgAAEIACBGBEwLdDrrrvOmYhb0KDu3bsHSjLfn+YD1JKnLeod3G+//cQ+odLGjRvFIrR//vnnThPTzjEt03ikxYsXS0lJiSvKottX53s0OHK8RYofOHBgPKpIGRCAAAQgAAEIQCDtCSAATfsupoEQgAAEIAABCEAgdQicd9558uc//9kJKF955RW5/fbbA5X3zN9NU7RPnz6B/cEbZmpumqBTpkyRadOmyaxZs2TVqlXBp8R1e/bs2YHy7r77brFPbZIJQEkQgAAEIAABCEAAAtEhgAl8dDiSCwQgAAEIQAACEIBAFAi0bt3aRW23rEwA6qV58+bJN998475W1v70zrnppptkn332kcsvv1wef/xxGTduXED42aNHD7nqqqukVatW3ulx+b906dKwylmyZElY13ERBCAAAQhAAAIQgMDeBNAA3ZsJeyAAAQhAAAIQgAAEEkjABJz/+te/xLQgLViRaXx6PkGDo8UHV9G0Rs0PqKVmzZrJr371Kxk8eLAzIx8wYIAUFha6Y++88477H86fmgITbd++fa9sPZ+jduDFF1+UU045Za9zQu3IyckJtZt9EIAABCAAAQhAAAJhEEAAGgY0LoEABCAAAQhAAAIQiB2Bk046yWlqrl69Wt544w0nAH311VddgaeeempAmOnVwMze//rXv7qvZhr/8ccfS/v27b3DFf6vX7/efbfgRLVNFr3d0s6dO6u8xO/3h/TvaZqnXjJz/MaNG3tf+Q8BCEAAAhCAAAQgECcCmMDHCTTFQAACEIAABCAAAQjUjkD9+vXForxb+uc//+kCGHm+NEOZv5upuwkgLV166aVVCj9nzJghmzZtcufVJQiSaZ1asmssoFKoNGnSpECwo+DjnTt3lgYNGrhdH3zwgVSnRWrCXguUZNqrX331VXA2bEMAAhCAAAQgAAEIREAAAWgE8LgUAhCAAAQgAAEIQCA2BDxB5/z58+WWW25xhZh/z2OOOWavAr3I8HbAfIWGSib4PP/88wOHqtPmDJxUvtGpU6fALvMtWjmZ6ftll11Webf7btqjV155pdueOHGi800a6sQtW7bIbbfd5oS9Y8eOld69e4c6jX0QgAAEIAABCEAAAmEQQAAaBjQugQAEIAABCEAAAhCILYH+/fvLgQce6Ap577333H8TYHrm6MGl23k+n8/tevbZZ+WLL74Qz8TdNC4nTJjgAiv98MMPgcuKiooC2zVtnH322ZKdne1O+8tf/uL8kdr1JSUl8umnnzq/nt9++63k5uaGzMoEuJ5JvglDb775Ztm6das71/IYM2aMq9/MmTPdPgvi1KJFi5B5sRMCEIAABCAAAQhAoO4EEIDWnRlXQAACEIAABCAAAQjEgYCnBWpFmYDzggsuCFlq165dZeTIke6YCRaPOuoosWjypi1qAZEOOOAA+frrr+Wss84SL0+Lzr5hw4aQ+VXe2bFjR2dab/uLi4vlvPPOcz5KmzZtKscee6yYxqaZ3tv+UKlRo0YyatQosXxMMHv33XdLQUGB0/I0QeeJJ54oX375pbv0tNNOk3vvvTdUNuyDAAQgAAEIQAACEAiTAALQMMFxGQQgAAEIQAACEIBAbAkMHz484D/ziCOOkG7dulVZoAkV77//fmnSpIk7xwIjffbZZ87np2mTmpalCSHPOeccd9zM5t96660q86t84LHHHnPm6y1btnSHzB+omb5blPc77rhDnnjiiYCWaOVr7fvhhx8uU6dOlYsvvtgJP00z1YIimem7pS5dushTTz0lr7/+erX5uJP5AwEIQAACEIAABCBQJwI+dRhf5jG+TpdxMgQgAAEIQAACEIAABJKPgGlomh/QBQsWOC3Nfv36SX5+flQrumjRIpk+fbpYxHkLchROWrJkiUybNs0JeE2D1QSpocz7w8mbayAAAQhAAAIQgAAEKhJAAFqRB98gAAEIQAACEIAABCAAAQhAAAIQgAAEIACBNCKACXwadSZNgQAEIAABCEAAAhCAAAQgAAEIQAACEIAABCoSQABakQffIAABCEAAAhCAAAQgAAEIQAACEIAABCAAgTQigAA0jTqTpkAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIVCSAArciDbxCAAAQgAAEIQAACEIAABCAAAQhAAAIQgEAaEUAAmkadSVMgAAEIQAACEIAABCAAAQhAAAIQgAAEIACBigQQgFbkwTcIQAACEIAABCAAAQhAAAIQgAAEIAABCEAgjQggAE2jzqQpEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAQEUCCEAr8uAbBCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgkEYEEICmUWfSFAhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQKAiAQSgFXnwDQIQgAAEIAABCEAAAhCAAAQgAAEIQAACEEgjAghA06gzaQoEIAABCEAAAhCAAAQgAAEIQAACEIAABCBQkQAC0Io8+AYBCEAAAhCAAAQgAAEIQAACEIAABCAAAQikEQEEoGnUmTQFAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQqEgAAWhFHnyDAAQgAAEIQAACEIAABCAAAQhAAAIQgAAE0ogAAtA06kyaAgEIQAACEIAABCAAAQhAAAIQgAAEIAABCFQkgAC0Ig++QQACEIAABCAAAQhAAAIQgAAEIAABCEAAAmlEAAFoGnUmTYEABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQqEkAAWpEH3yAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAIE0IvD/AeoswYrat+dGAAAAAElFTkSuQmCC" width="672" /></p>
<p><br /><br /><br /><br /><br /><br /></p>
</div>
<div id="measures-of-performance" class="section level2 page-break-before" number="1.3">
<h2><span class="header-section-number">1.3</span> Measures of Performance</h2>
<p>Squared Error</p>
<p><br /><br /><br /><br /></p>
<p>Mean Squared Error</p>
<p><br /><br /><br /><br /></p>
<p>Integrated Squared Error</p>
<p><br /><br /><br /><br /></p>
<p>Mean Integrated Squared Error</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
</div>
<div id="optimal-binwidth" class="section level2 page-break-before" number="1.4">
<h2><span class="header-section-number">1.4</span> Optimal Binwidth</h2>
<p>We will investigate bias and variance of <span class="math inline">\(\hat f\)</span> pointwise, because <span class="math inline">\(\text{MSE}(y) = (\text{bias}(\hat f(y))^2 + \text{Var} \hat f(y)\)</span>.</p>
<p><span class="pagebreak"></span></p>
<p>The roughness of the underlying density, as measured by <span class="math inline">\(R(f&#39;)\)</span> determines the optimal level of smoothing and the accuracy of the histogram estimate.</p>
<p><br /><br /><br /><br /></p>
<p>We cannot find the optimal binwidth without known the density <span class="math inline">\(f\)</span> itself.</p>
<p><br /><br /><br /><br /></p>
<p>Simple (plug-in) approach: Assume <span class="math inline">\(f\)</span> is a <span class="math inline">\(N(\mu, \sigma^2)\)</span>, then</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><span class="pagebreak"></span></p>
<p>Data driven approach:</p>
<p><span class="pagebreak"></span></p>
</div>
</div>
<div id="frequency-polygon" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Frequency Polygon</h1>
<p>The histogram is simple, useful and piecewise constant.</p>
<p><br /><br /><br /><br /></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(ISLR)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co"># optimal h based on normal method</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>h_0 <span class="ot">&lt;-</span> <span class="fl">3.491</span> <span class="sc">*</span> <span class="fu">sd</span>(Hitters<span class="sc">$</span>Salary, <span class="at">na.rm =</span> <span class="cn">TRUE</span>) <span class="sc">*</span> <span class="fu">sum</span>(<span class="sc">!</span><span class="fu">is.na</span>(Hitters<span class="sc">$</span>Salary))<span class="sc">^</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="do">## original histogram with optimal h</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="fu">ggplot</span>(Hitters) <span class="sc">+</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="fu">aes</span>(Salary), <span class="at">binwidth =</span> h_0) <span class="ot">-&gt;</span> p</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="do">## get values to build freq polygon</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>vals <span class="ot">&lt;-</span> <span class="fu">ggplot_build</span>(p)<span class="sc">$</span>data[[<span class="dv">1</span>]]</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>poly_dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="fu">c</span>(vals<span class="sc">$</span>x[<span class="dv">1</span>] <span class="sc">-</span> h_0, </span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>                             vals<span class="sc">$</span>x, vals<span class="sc">$</span>x[<span class="fu">nrow</span>(vals)] <span class="sc">+</span> h_0),</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>                       <span class="at">y =</span> <span class="fu">c</span>(<span class="dv">0</span>, vals<span class="sc">$</span>y, <span class="dv">0</span>))</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="do">## plot freq polygon</span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>p <span class="sc">+</span> <span class="fu">geom_line</span>(<span class="fu">aes</span>(x, y), <span class="at">data =</span> poly_dat, <span class="at">colour =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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veSEE06QF198sV1vkf/uu+9kwoQJ8uSTT9bblPqW/VmzZsnEiRPl/PPPlzvuuEPeeustqVLjF1IQQKBlAsGp05wDA9dPEkMlPSgIIICAFiiLiZFbDhgpG5OTLJCuKvl5i0qCJldUAoQAAggggAACCCCAAAIItLlAmydAda/PmTNnypYtW+S5556T448/XmLUFx2dTJw7d66ceeaZ0r17d7n00ktl/vz5bV6hmicsLCyU22+/XZYtWyabNlXPQl1zB7Wcl5cnF1xwgTz22GPy9ddfS25ursybN0/uuusumTx5spSXl+91BE8RQKAxgeD7H4jMrx4Co28fMc4+s7FD2I4AAlEmUBAfL5PHjpJc9VOXvuo2+L9996PEqtviKQgggAACCCCAAAIIIIBAWwq0eQLUDi4pKUnOOussefvtt2XDhg1y7733yv77729t1knGRx99VA455BAZNmyYTJs2rd4EpX2+lvzU19y2bVuDh952222Sk5Mj48aNkzfffFNee+01ef7552XAgAHyySefyIwZMxo8no0IILCvgDm1xtifk64SIzZ2351YgwACUS+wVfUAvXnsSNmt/lCqyyg1IdLVPywVUWMIUxBAAAEEEEAAAQQQQACBthIIWwK0ZoBZWVly1VVXyffffy8LFy6U66+/3hobVO+zdOlSue6666R3795Wb9HZs2e3Sa/Ld999V95//33p0KFDzVBqLevb8xcsWCA6Wat7imZkZFjbe/ToIffdd5/Vc1X3WtU9SSkIINA0AXP+AjE/+Ci0c1Y3MS44r2kHshcCCESlwKr0NJk6erhUVg+TcfjW7TJh2aqotKDSCCCAAAIIIIAAAgggEB6BdkmA1gx91KhRMnXqVPnxxx+t3pY68amLvkVe33p+xhlnSM+ePUWPJapvT29J0bff6wSmTmSeffbZ9Z7io48+srYdeeSRkpiYWGu/Tp06WZM46VvgdRKUggACTROoNfbn1X8RY6/fraadhb0QQCCaBL7v0kkeGDFE7H6fJ6/bIKesWR9NBNQVAQQQQAABBBBAAAEEwijQ7gnQb775xpoUafDgwXLSSSfJ+vV7vuDodXqilO3bt8utt94qBx10kDV+Z3PqH1Rjh+nenCUlJXLTTTftk9isea7FixdbT/Xt73UVPZ6pLj/88ENdm1mHAAJ7C/y4WKzZ3/X6jh3EuPjCvffgOQIIIFCnwIfZWfL0oP7Otj8uXy1HbN7qPGcBAQQQQAABBBBAAAEEEGipQLskQNeuXWvNrD506FA58MADZfr06bJixQorZt1L84YbbpDly5dbyU69r558KCUlRVauXGmNE7p58+Ym1+8///mPdZv9ueee69xmX9/BGzdutDbVd5u8vV6PEUpBAIHGBWKm36/G7gvtZ1x5mRipqY0fxB4IIIBAtcBL/XvLG717WM8M9e/ERT/J/jtz8UEAAQQQQAABBBBAAAEEWiUQtplJdu3aJXo8z3//+9/y2WefqfkM7BvbRBISEuTkk0+2Zl8/5phjJBDYk4fVt8TfcsstVuLzhBNOsG6D1xMp/elPf2q0onq2dz0D/ZAhQ+T8889vdP/i4mJrHzvRufcB6enp1ip7v72328+PO+44KSsrs5/W+tmtWzeprKxscDIm22bHjh1WD9haJ+AJAi4X0L2udQmsXSfGy69ay2ZysuSqmd/NRiYhs3bmHwQQQKCGwBP7DZRO6v/Un2/dIXHqs8ONamb4aw8eI2vSw/cHlcYmTKwRnusW7fdgHZges7yxzyyuqwABRb2A/TlYD32l7wSjIOAlgZrvwfr9V9+FSEHASwL2e3B+fj5zn3ip4aIwVjvnVvN9t7kMbZ4Afe+99+Thhx+2Zn/X42fWLLr35wUXXGCNy9mxY8eam/ZZPv7440Xvo2eM/+KLLxpNgGoMfdt8jJpJVt/6HtvIrNMarbS01LpuWlraPtfXK1Kre6/Z0HXupFZu2rSp3gRoly5drMP0GKeNldY0ZGPnZjsC4RZIfvgxMaqToSXnniOVamITNbhvuC/L+RFAwGcCpkqA3DNyqGSU/SAj8vIlWb2P3PLND3L1IQfI9qTa43W3VdWb8n90W10rnOfRX2L8UpdwOnFudwrwOdid7UJUTRfgPbjpVuzpPgFev+5rEyKqLdAWn3H3dL2sfe4WP7v//vtlzpw5zkzumZmZ1gzwixYtkq+++kouvfRSK7HZlAvExcVZu/Xt27fR3XXSVY8neskll0ifPn0a3V/3OtWzv+tSX4LTXh8fH9/g+fR2HWtdjwYPZCMCPhEIbN4iiS++bNXGVL8PJYz96ZOWpRoIREagQv0x87YDRsi6lGQrgE7qD6q3qiRoanlFZALiqggggAACCCCAAAIIIOBpgTbvAao1dO/LE0880ertqX821huzLkGd3b3ttttE3xKvJ0NqqOgeoq+++qo1vuhpp53W0K61tunemXp8T33LWF3FXq/HI22ofP311/VunjhxomzdulW6d+9e7z66J6ru6aqTxboHKwUBLwno3xPzsSfFqAglJgJ/PE+6jd7fS1UgVgQQcKFAsfrD4pSxo+Se+d9Kl7Jy6VW8W6Z8t0huPHB/KW/j/ysb+j/ahTS1QtK3XBYUFFjr9NA9jX1mqXUwTxBwgUCF+vygh4Hq1KmTNUyWC0IiBASaLKBvedfDN+ii7x6s787CJp+QHRFoZwGdd9FDAelhAe0OYu0cApdDoEkCdgfFmkNoNunAGju1eQL0yiuvlKeeespK5tW4TrMXdSLwoosuatJxusepLkuWLJHf/e53tY6xkT7++GP57W9/KxkZGda4pHqnxhKg9heKxm7Xr3VBniAQbQI7d0rSv5+zam2q39uYSVdFmwD1RQCBMAnsULe86yTo3Qu+k5TKKhmaVyCTflgiU0ePkCBjBYZJndMigAACCCCAAAIIIOA/gTa/Bf7YY49tdfKzucw6WaofOtmpe6PVfNgJUD0RkV5fVFTknF73uNRl9erVzrqaC/Z6PXs9BQEE6haIve8BMaoHfDdPP02Mfv3q3pG1CCCAQAsE1qWlym1jRkpFdcLzkG075eIlK1pwJg5BAAEEEEAAAQQQQACBaBVo8x6gkYCcOnVqvZd95ZVXRI9LetRRR8mUKVNq7afXvfPOO6InbjrnnHNqbdMDsX/wwQfWutGjR9faxhME2kvguOOOa69Lteg6ndXwDU98usA6Vk93dFnOGtng8phbVFEOQgCBiAr82KmD3DtqqFy7cInoOaJP2LBJdibGywsD+kY0Li6OAAIIIIAAAggggAAC3hBo8x6g3qh2KMpDDjlE9ARLK1askLlz59YKfdasWbJT3dqrJ1QaN25crW08QQCBkMDZq9ZJQvXM7+/3yJINqQ2Pl4sbAggg0FKB/2VlypP7DXQOP3flWjl6w2bnOQsIIIAAAggggAACCCCAQH0CvugBWl/lGltvqNvpLrzwQpk8ebLoXqR6MqVBgwaJnrFeL+tZ3SdNmiR6PwoCCNQWyNpdIkdv3GKt1LemPkdPrNpAPEMAgTYXeL1PT+lcWianrc2xzn3FkuWSmxAv33Tt3ObX4oQIIIAAAggggAACCCDgH4Go7gGqm/GII46wbpHPysqSDz/8UJ544gkr+al7ht5zzz0yatQo/7Q2NUGgDQX+sGK1xJqmdca3eveQ7WqyEgoCCCAQboGnBveXj7qHxvCOUe9B1y9cLIPyQ7Ogh/vanB8BBBBAAAEEEEAAAQS8KeD7HqCnnnqq6EdDZcyYMTJ79mzrlvecnBxrEiedEA0Eoj4/3BAb26JYoE9hkRy2ZbslUBoTkNn9ekexBlVHAIF2FVA9zv8+Yj/pUFYuo3flSWJVUKZ8u0iuGXeAbElOatdQuBgCCCCAAAIIIIAAAgh4Q4AMX4126ty5s+gJj7Kzs0l+1nBhEYG9Bc5fvlrsN49X+/aSfHULKgUBBBBoL4FK9QfKO8aMkNVqhnhdOpRXyG1fL5QMlRSlIIAAAggggAACCCCAAAJ7C9g5jL3X8xwBBBCoU2C/vHw5aMcua1tRbKy82qdXnfuxEgEEEAinQIl6/5kydqRsS0ywLtO9pFRuVj1BEyqrwnlZzo0AAggggAACCCCAAAIeFCAB6sFGI2QEIilwnur9aZcX+veR3XG+H0nDri4/EUDAZQK5CQkyeewoKah+HxpUUGiNCRoIhsYndlm4hIMAAggggAACCCCAAAIREiABGiF4LouAFwXGbt8pI3PzrdB3xcfLW72zvVgNYkYAAR8JbEhNkVvHjJSy6nG7D1Q91K9YssxHNaQqCCCAAAIIIIAAAggg0FoBEqCtFeR4BKJFQM22fO7KNU5t/zOwr5THxDjPWUAAAQQiJfBTxwy5e/9hYt/8fszGLXLuij291SMVF9dFAAEEEEAAAQQQQAABdwiQAHVHOxAFAq4XOFzN+j6woMiKc0tSovy3R5brYyZABBCIHoH5mV3k0WGDnQqfuXq9HJ+z0XnOAgIIIIAAAggggAACCESvAAnQ6G17ao5AkwUCqvfnOavWOvs/M6ifVFXfbuqsZAEBBBCIsMC8XtnynBqb2C4XL1kh47btsJ/yEwEEEEAAAQQQQAABBKJUgARolDY81UagOQJHb9wsvYp3W4esVePtfZqV2ZzD2RcBBBBoN4FZ6g80dg91PUjHpIVLZL/qsYvbLQguhAACCCCAAAIIIIAAAq4SIAHqquYgGATcJxAbDMpZq9Y5gf1rcH8xDcN5zgICCCDgNoEHhw2Rr7t0ssJKUO9hU75bJD2Lit0WJvEggAACCCCAAAIIIIBAOwmQAG0naC6DgFcFTly/UTJLy6zwf8pIl6+7dvZqVYgbAQSiRCAYMOTO/YfL8vQ0q8ZpFZVy6zc/SMey0HtZlDBQTQQQQAABBBBAAAEEEKgWIAHKSwEBBOoVSKyslNPXrHe2P61uLaUggAACXhAoi42Rm8eOlE3JSVa4+g85t6gkaJJ6X6MggAACCCCAAAIIIIBAdAmQAI2u9qa2CDRL4JS1G6RDeYV1zDfqdtJFnTs263h2RgABBCIpUBAfL5PHjpK8+DgrjP6FxXLjdz+KHtqDggACCCCAAAIIIIAAAtEjQAI0etqamiLQLIFUlfg8eV2Oc8yzA/s6yywggAACXhHYonqA3nzASCmNCX3kGb0rTyYu+knENL1SBeJEAAEEEEAAAQQQQACBVgqQAG0lIIcj4FeBM9ask5TKKqt6/+vWVVaq8T8pCCCAgBcF9PvXVDUmaFX1BG5Hbtkmf1y+yotVIWYEEEAAAQQQQAABBBBogQAJ0BagcQgCfhfopMbKO3H9JquaOgX6b3p/+r3JqR8Cvhf4Vk3gNmP4YKeep6ohPk5au6eXu7OBBQQQQAABBBBAAAEEEPCdQKzvakSFEECg1QLnrForCdVj5L3fI0s2pKa0+pycAAEEEIi0wPs9ukvn0nL5w8o1VigTlq2SnYkJkQ6L6yOAAAIIIIAAAggggECYBegBGmZgTo+A1wSydpfI0Ru3WGFXqNtFnxvQ12tVIF4EEECgXoEXB/SRt3plW9sN9e/VPyyV4Ecf17s/GxBAAAEEEEAAAQQQQMD7AiRAvd+G1ACBNhU4d8Uaia2eHOSt3j1ke1Jim56fkyGAAAKRFnhs6CD5IrOLFUacer8Lnny6mIt+jHRYXB8BBBBAAAEEEEAAAQTCJEACNEywnBYBLwr0KSySw9XkILroGZNf6tfbi9UgZgQQQKBBAVP1bp8+aqgs6VA9uVt+gVQd/zsxcxgTtEE4NiKAAAIIIIAAAggg4FEBEqAebTjCRiAcAucvXy32m8KrfXpJXkJ8OC7DORFAAIGIC5THxMitY0ZKTkpyKJaNm6TquN+KmZsb8dgIAAEEEEAAAQQQQAABBNpWwM51tO1ZORsCCHhOYL+8fDloxy4r7qLYWHm1by/P1YGAEUAAgeYIFMXHyeSxo0Syu4cOW/KTVJ00XszS0uachn0RQAABBBBAAAEEEEDA5QIkQF3eQISHQHsJ/GF5aFZkfb0X+veW3XGx7XVproMAAghETECPcxzz9msi6WmhGD79TIK/P0/MYDBiMXFhBBBAAAEEEEAAAQQQaFsBEqBt68nZEPCkwAHbd8qo3Dwr9l3x8fK2mvyIggACCESLgLH/KAm8+qKI6hGqi/nKaxL889XRUn3qiQACCCCAAAIIIICA7wVIgPq+iakgAo0LnLtyrbPTfwb2lTI1Nh4FAQQQiCaBwK9+KYF/zRQxQrU2H3pUgndNjyYC6ooAAggggAACCCCAgG8FSID6tmmpGAJNEzhMzfo+qKDQ2nmLuhX0vz2ymnYgeyGAAAI+EwicfaYEpt/l1Cp4/U0SfHaW85wFBBBAAAEEEEAAAQQQ8KYACVBvthtRI9AmAgHTlN/X6P357MB+UhXgbaFNcDkJAgh4UiBw9V/EmHiFE3vwT/8nwXf/6zxnAQEEEEAAAQQQQAABBLwnQKbDe21GxAi0mcBRG7dIr+Ld1vnWpqbIJ90z2+zcnAgBBBDwqkDg3rvFOHN8KPyKSgmedpaY337n1eoQNwIIIIAAAggggAACUS9AAjTqXwIARKtArJrh+OxVa53qPz2on5hG9eB3zloWEEAAgegTMNR7YeCZf4rxiyNClS8qlqoTThJzzZrow6DGCCCAAAIIIIAAAgj4QIAEqA8akSog0BKBE9dvlMzSMuvQZRlp8lVml5achmMQQAABXwoY8fESmDNbZOTwUP22bpOqY38j5o4dvqwvlUIAAQQQQAABBBBAwM8CJED93LrUDYF6BBIqq+T0Neudrf8a1N9ZZgEBBBBAICRgZGRIzNzXRXr3Cq1YsUqqfnOKmLtDQ4fghAACCCCAAAIIIIAAAt4QIAHqjXYiSgTaVOCUtTnSobzCOuc3nTvKIvWgIIAAAgjsK2D06BFKgnbsENo4/ysJnvl7Mauq9t2ZNQgggAACCCCAAAIIIOBKARKgrmwWgkIgfAKpKvF5yroc5wL/VmN/UhBAAAEE6hcwhg2VmNdfFklMsHYy35wrwYsvr/8AtiCAAAIIIIAAAggggICrBGJdFY0Pg6msrJTy8nLZunVrvbUzTdPatn37dtETL1AQCKfAGerW9xR1C7wu/+vWVVZkpIfzcpwbAQQQcL1AQ/9HO8EPGijxDz8gqRMuEUP9v23OfEoK1C3yJX+d6OwSiQX7M4S+dmFhoRQVFUUiDK6JQIsF7Ndwbm4un4NbrMiBkRKwX7/6+sXFxbKbIVIi1RRct4UC9ms4Pz9fCgoKWngWDkMg/AJlZaH5S4JqMueWFhKgLZVr4nHWTLKBgCQlJdV7hE6S6sZMTEyUgNqXgkC4BDqq15me/EgX/bYxa2BfvUhBAAEEolqgof+ja8GMP1UqduVK/F+vt1Yn3/t3iVHjg1adf26t3drzSUVFhfWHVn3NuLg469Ge1+daCLRWQH+RKSkpkYSEBImJiWnt6TgegXYVsL/H6YvGxsZKvJpAj4KAlwTs92D92tWvYQoCbhWwc2Wt6TTIKzzMras/yOk3kvT0+nvZlZaWWgnQtLQ0PviFuT2i/fS/X7lWEqr/YvJejyzJSU2JdhLqjwACCDT4f/Q+PNdMlKpdu8S8c7q1KeGqv0qgX18J/PbEfXZtjxW6x5G+00QX/YfUlBTe19vDnWu0nYBO4usEaHJyspUEbbszcyYEwi+gX7t2rySdxNff5ygIeEmgSo1prl/H+o/BTf6DsJcqSKy+EbDfa1uTAKW7oW9eDlQEgYYFsnaXyNEbt1g7VaihFp4f0KfhA/5/e/cBJ0V9/3/8PXsHHBwdpPciTREsgFGxYBQ19l5i+0k0Jhp7pVgAMXaNsf4twa5EERUsAaPGgliRokgHOXo/4O525//9zt7s7R17vW15fR+PYWdnvjPz/T4Hht3Pfgt7EUAAAQRiCqSNv1PO+eeG9wVDCp11ntwvv4qZl40IIIAAAggggAACCCBQ+wIEQGv/HlACBGpE4I8LFis9f7zZ9zq205oShmWokQJxEQQQQCCBBQJPPy7n6N+Ha2B+YAoef4rcXxYkcI0oOgIIIIAAAggggAACyStAADR57y01QyAi0HnrNh2StcZ7vzMtoNe70fozgsMKAgggUAEBx4y3GXjjZWm/geGj161XcPjxcrPCLe0rcEoOQQABBBBAAAEEEEAAgWoSIABaTbCcFoF4ErjAtP70/7G/1bmjNtVjgPZ4uj+UBQEEElPAadhQae++JXXrGq7A4iUKHnuiXDMbOwkBBBBAAAEEEEAAAQTiR8CPicRPiSgJAghUqUCvTZs1aO1675zbzIRcb3bpUKXn52QIIIBAKgs4rVsrbdoUqWWLMMN3Pyh06llyzcQuJAQQQAABBBBAAAEEEIgPAQKg8XEfKAUC1SZgW3/66bVunbTddNskIYAAAghUnYDTs0e4JWiD+t5J3Q//o9D/XSo3f9zlqrsSZ0IAAQQQQAABBBBAAIGKCBAArYgaxyCQIAL7rtug/hs2eaXdWLeu3u3UPkFKTjERQACBxBJwBh2gwGsvSWacZZvciS8pdPPIxKoEpUUAAQQQQAABBBBAIEkFCIAm6Y2lWghYATvzu59e6tFZu9LS/Le8IoAAAghUsUDguGMUeOLRyFndu+9T6B//jLxnBQEEEEAAAQQQQAABBGpHgABo7bhzVQSqXeBgM+t7zy3hiTiy6mfog/Ztq/2aXAABBBBIdYHA/12kwO2jIgyhv12r0KQ3I+9ZQQABBBBAAAEEEEAAgZoXIABa8+ZcEYFqFwiYcefO/XVJ5Dov9OiqYIB/7hEQVhBAAIFqFAiMvlXOiIvDVwi5Cp17gdxPP6vGK3JqBBBAAAEEEEAAAQQQKEmAiEhJOuxDIEEFhq3MUsft2V7pl2Y20H/btkrQmlBsBBBAIDEFAo89Iuf4Y8OF35Wj4Amnyp0zNzErQ6kRQAABBBBAAAEEEEhwAQKgCX4DKT4CRQXSQyGdvXBJZPPze3aT6ziR96wggAACCFS/gGPGXA688oI0ZFD4Yps2K3jMCXJXrqz+i3MFBBBAAAEEEEAAAQQQKCRAALQQB28QSHyB45atVKudu7yK/NykkWa2apn4laIGCCCAQAIKOA0aKO0dM/7nnj3CpV++QsHhx8vdvDkBa0OREUAAAQQQQAABBBBIXAECoIl77yg5ArsJ1MsL6rTFyyLbn+/ZLbLOCgIIIIBAzQs4LVoobdoUqU3r8MV/mqvgiafJ3RX+oarmS8QVEUAAAQQQQAABBBBIPQECoKl3z6lxEgucvHS5muXkejX8tkUz/WgWEgIIIIBA7Qo4Xbsq7b3JUqOG4YL891OFzr9YrpmwjoQAAggggAACCCCAAALVL0AAtPqNuQICNSLQMDdXJy9ZHrnWxJ5dI+usIIAAAgjUroAzcIACk16R6qR7BXFfm6TQ1dfVbqG4OgIIIIAAAggggAACKSJAADRFbjTVTH6B0xctU6bpAm/T/1q31IImjZO/0tQQAQQQSCCBwO+PVOCZJ6X8eenchx5V6N4HEqgGFBUBBBBAAAEEEEAAgcQUIACamPeNUiNQSKCZGUvOTn5kU8gsL/Sg9aeHwR8IIIBAnAkEzjtHgQnjIqUK3XCzQi+ZlqEkBBBAAAEEEEAAAQQQqDYBAqDVRsuJEag5gXN+XaKMkA19Sv9p30bLG2bW3MW5EgIIIIBAuQQCN1wr54rLw8eYYUBDF41Q6D/Ty3UOMiOAAAIIIIAAAggggEDZBQiAlt2KnAjEpUCb7B36/cosr2y5jqOXu3eOy3JSKAQQQACBAoHAg/fKOe3k8AYzeV3olDPlfv9DQQbWEEAAAQQQQAABBBBAoMoECIBWGSUnQqB2BM77dbHS82cSntqxndbUr187BeGqCCCAAAJlFnACAQVeeE4aenD4mC1bFTz2RLlLl5b5HGREAAEEEEAAAQQQQACBsgkQAC2bE7kQiEuBzlu3aeiqNV7Zdpov0691o/VnXN4oCoUAAgjEEHDq1VPa5Dekfn3Ce1dlKXj0H+SuXx8jN5sQQAABBBBAAAEEEECgogIEQCsqx3EIxIHA+QsWy/9HPLlLB22qVzcOSkUREEAAAQTKKuA0baq0aVOkDu3Dh/y8QMHjT5G7Y0dZT0E+BBBAAAEEEEAAAQQQKEXAj52Uko3dCCAQbwK9Nm3W4LXhVkLb0tP17y4d462IlAcBBBBAoAwCTocOSpv6ttS0STj3F18pdPYf5QaDZTiaLAgggAACCCCAAAIIIFCaAAHQ0oTYj0CcClxgWn/66fVunbS9Th3/La8IIIAAAgkm4OzVT2lvvS7lt+R3J7+j0F/+lmC1oLgIIIAAAggggAACCMSnAAHQ+LwvlAqBEgUGrtug/hs2eXk21q2rdzrld50s8Sh2IoAAAgjEs4Bz6FAFJj4rBRyvmO4TTys09q54LjJlQwABBBBAAAEEEEAgIQQIgCbEbaKQCBQW+GNU68+Xu3fWrrS0whl4hwACCCCQkAKB009V4IF7I2UPjbpdoWefj7xnBQEEEEAAAQQQQAABBMovQAC0/GYcgUCtChyUtUZ7btnqlSGrfobe79C2VsvDxRFAAAEEqlYgcOVf5Fx/deSkoT9drtB70yLvWUEAAQQQQAABBBBAAIHyCRAALZ8XuRGoVQHHdXXer0siZXihRxcFA/wzjoCwggACCCSJQODu8XLOPStcm7ygQmecI/frWUlSO6qBAAIIIIAAAggggEDNChA5qVlvroZApQSGrcxSx+3Z3jmWZjbQf9u2rtT5OBgBBBBAID4FHMdR4Nmn5Bx5RLiA5tkfPO4kub/+Gp8FplQIIIAAAggggAACCMSxAAHQOL45FA2BaIH0UEjnLFwS2fSvPbvJNV+QSQgggAACySng1KmjwL9flQb0D1dw7ToFh58g9/MvkrPC1AoBBBBAAAEEEEAAgWoSIABaTbCcFoGqFjh2+W9qtXOXd9qfmzTSV61aVvUlOB8CCCCAQJwJOI0aKe29yVKXzuGSLVyk4EGHK3jUcXI//SzOSktxEEAAAQQQQAABBBCIT4H0+CxWxUu1fv16vfbaa1q4cKFWr16tVq1aqWvXrjrzzDO1xx57xDzxrl279MYbb2jWrFnauHGjevbsqQEDBmj48OFKY3btmGZsrFmBjLw8nb5oaeSiz/XsFllnBQEEEECgcgL2//t4T+07tNa4VVlqaT6z2OR++B8FzfJr0yZ6tXtnfduyedxVYdo0Jm6Ku5tCgRBAAAEEEEAAgRQVSKoA6Mcff6zx48drx44dXuCyRYsW+uabbzRz5ky9/fbbuvHGGzVs2LBCt3rTpk26/PLLtXz5cm978+bNZT+w2+Xzzz/XmDFjVLdu3ULH8AaBmhY4cekKNcvJ9S77XYtmmm0WEgIIIIBA6gisNOM+X3rwIP1h+UqdtMT+n5DjVb7fps2645sfZXsGvNy9i2bt0SJ1UKgpAggggAACCCCAAAJlFEiaLvArV66MBD8vuugivf/++5o0aZL3ev7553tB0QkTJkQCnb7PnXfe6W0bPHiw3nnnHU2ePFmvvPKKunfvrk8++UQPP/ywn5VXBGpFoGFurk42X3b9NLFHV3+VVwQQQACBFBLYlZ6mSV076eKhg/Vk7x5aV69epPa9Nm/Vbd/O1sOfz9KBq9eaJqJuZB8rCCCAAAIIIIAAAgikukDSBECnTJniBTmPPPJIXXzxxaqX/6XAvo4YMUKHHXaYdu7cKZvPT3PnzvVah9avX19jx45VkyZNvF3t27fX/fff77UinTp1qrZu3eofwisCNS5w2qJlami6wNv0uRn385emjWu8DFwQAQQQQCB+BHLN8Dxvd+6gS0wg9J99emp1RkakcN22btOt38/RP//3tYauWq0AgdCIDSsIIIAAAggggAACqSuQNAHQ7777zruLhxxySMy7aVt42vTrr79G9tsu8zYdeuihyoj68mC32a7wgwYNUo7pYmaDoCQEakOgmRnr7Q/LVnqXDpk/J/ak9Wdt3AeuiQACCMSjQF4goPc6tdeIQwbroX69tLJB/UgxO23P1g0/ztNjn83UESuzFAjRIjSCwwoCCCCAAAIIIIBAygkkTQDUdlV/9dVXNWTIkJg3ccOGDd72pk2bRvbPmTPHW/eDo5Ed+Ss2AGrTjz/+mL+FFwRqVuDsX5cqI2RDn9L0dm20vGFmzRaAqyGAAAIIxL1AKODoww5t9WczRui9e/fWUjNeqJ/aZ+/QNT/N11OffqWjl/+m9Pz/U/z9vCKAAAIIIIAAAgggkAoCSTMJku3q3q5du5j3LM90H/Zbcfbr1y+Sx44balN0UDSyM2q7P0FS9L7odduSNBgMRm+KrGdnZytkvmzY7vfFJdvK1CY7G33AtOYgIeAJLFmio1au8lZzHUcv9egMDAIIIIAAAsUKhMz/FR+bH8s+bttaB5txQM8wQ6jYLvE2tTafQ66Y+4vOXrhUb3TtqA9MwDTHdKWvzlTSZ5/qvC7nTiwB+zndJvt52GXIhsS6eZRWuWasfj/Zv8s893wNXhNFwMYqbLJ/lx3zOYKEQLwK2HiZTZX5rJA0AdCSbtITTzyhFStWyI7tedxxx0Wybt++3VsvLgDauHF4rEU/X+TAIitXXnmlF7wsstl7279/f+8Gbdy4MdbuQts2b95c6D1vUlug0a1jlJH/RWBax3ZaY8aqJSGAAAIIIFCqgPkC81mbVt4yeM06EwhdKjtJkk0tzYfHy+b/qjPNNjuh0tQO7WQnV6qOVJbPPtVxXc6ZmALbtoWD9YlZekqNgLzgJwFQ/iYkqoCNeZQW90jUulHu5BAgAFqG+2hndLeLbVl5yy23RMb6jG6V2ahRo5hnatiwobfdh46ZiY0IVINA2vyfVe/Nt70z7zR/d1/t1qkarsIpEUAAAQSSXeArM3meXfZdu15nmaBn301bvCo3y8nVJT8v9IKjb3bpqHfMWKI70lPid/Fkv+XUDwEEEEAAAQQQQCCGQFJ/0n3yySc1ceJEL/g5cuRI2daYfrIBUTv7+44dO4ptvekHPuvWresfFvP1wgsvlN99p2gGO9O87QafmVn82I32WHutBg0a0Oy8KGCKvq97zwNy8lt/TjYz/W4yQzyQEEAAAQQQqKjAt3u0kF322rBJ5yxcov7m1abGuXm6YMFinbp4uez/N1NMIHRb3ToVvUyh40r67FMoI29SWsA2SrCfx+2EpGnVPCxDSkNT+WoR8L/H2ZPXqVNHpX1vrJZCcFIEKiFguxPbeIUdUjCdH0IrIcmh1S3g//2szFANSRkAteNXTJgwQR988IH3n9Do0aO9md6L3pCWLVvKju+5dWu4W1jR/f720j7AX3PNNUUPjby/+uqrvTGN/O70kR1RK7arhA2A2hanfPCLgknRVfermQpOfd+r/Tbzn9C/zVhtJAQQQAABBKpC4KfmTXVL8wHqvWmzNx7ofuvCk0Q2ND/GnmsCoycvWe61Bn2rSwdtKeUH4NLKU9Jnn9KOZX/qCNjP7TYAahsC2C/gJAQSSSC6MY39+1tcz8JEqhNlTS0BO5eJDYDaxmF2ISEQrwJ+A8XKBECTbsYdG7S89tprveCn/eD94IMPxgx+2ptqA6A2+YFO703UH1u25HcTa9YsaiurCFSvQOiW0ZELvGHGZ9tufk0mIYAAAgggUJUC85s20Zj9+uuqIfvpy1Yt5OafvIH5InTG4mV65r9f6v/MWKHNzA+0JAQQQAABBBBAAAEEEl0gqQKgNmB5xRVX6LvvvlOHDh30+OOPa++99y72HrVq1crbt2jRoph5/O19+vSJuZ+NCFS1QOiDD+VO/zh82jatNaVz+6q+BOdDAAEEEEAgIvBrk0YaO3Bv/fV3++uz1nsoPBeslGG6JZ+8dIUXCL103gLtsWNn5BhWEEAAAQQQQAABBBBINIGkCYDasStuuukmLVy4UL169fKCnx07ltx1eNiwYd79+uijj3a7b3Y8ounTp3vbBwwYsNt+NiBQHQKhkbdFThsYdbN2MRZWxIMVBBBAAIHqE1jaqKEmDOinPx88SDPatlYw/1J1zOer45et1FOffqW/zvlZbbJ3VF8hODMCCCCAAAIIIIAAAtUkkDQB0ClTpmj27Nlet/Z77rlHTZo0KZVsyJAh6tKlixYsWKCpU6cWyv/iiy9q/fr16ty5swYPHlxoH28QqA6B0KQ3pa+/CZ+6S2c5l1xcHZfhnAgggAACCBQrsDKzge7r30eXHjJYH7RvozzH8fKmm0Do8BWr9IQJhF49e546bNte7DnYgQACCCCAAAIIIIBAvAkkxSRIdjBU293dpnXr1unkk08u1rlHjx56+umnvf128NQRI0bITpI0fvx4ffHFF+rZs6cXSLXrdia/G264gZnZi9VkR1UJuKbFcWj07ZHTBe4cI6eSk09ETsYKAggggAAC5RTIalBfD+/VWy9376LTzJigv1+Zpbrm/6o0c55hv63W4Wb5tE0rvdatk2zrURICCCCAAAIIIIAAAvEskBQB0MWLFxeayMjOZFZcyjOznEanoUOH6oEHHvACoDNmzJBdbLItQ+0M7v3794/OzjoC1SLg/usFae788Ln79pZzzlnVch1OigACCCCAQHkE1tbP0GN999Qr3Tvr1MXLNXz5b974oLYL0aFZazTULF+0amkCoZ1lxxMlIYAAAggggAACCCAQjwJJEQDt3bu3Pv300wr7Dhw4UK+//rrX5X358uWykyO1adNGgUDSjBBQYRsOrH4BNydHodvHRS4UGH+nHP7uRTxYQQABBBCofYGN9erp6d49vBafp5hA6LEmEGpnjLcd5H+3Zp23fN2yuV41gVI7wzwJAQQQQAABBBBAAIF4EkiKAGhVgbZo0UJ2ISFQkwLu409JS5aGLzlofwVOPL4mL8+1EEAAAQQQKLPAFjM8y3O9uusN0/X9xCUrvAmSGub3rjlg3QbZ5fvmzUzX+c5lPicZEUAAAQQQQAABBBCobgGaOFa3MOdHoAQBd/t2hcbfHckRGH9HZJ0VBBBAAAEE4lVgmxkn/cWeXXXRoUP0rx5dtdm899OADRt199ffK++QIxT68CN/M68IIIAAAggggAACCNSaAAHQWqPnwghI7oOPSKvXeBTOkUcoMOwIWBBAAAEEEEgYgR3p6XrNtPa8eOgQPbNnN22MnsDvs88VOuoPyht8sELvvJcwdaKgCCCAAAIIIIAAAsknQAA0+e4pNUoQAXfjRoXufSBS2sC4glngIxtZQQABBBBAIAEEdqWn6d9dO5lA6GA9YcYKXWfGDI2kmbMUOv4U5Q0cpNC/35LrupFdrCCAAAIIIIAAAgggUBMCBEBrQplrIBBDIHT3vdKmzd4e5+QT5Aw6IEYuNiGAAAIIIJA4ArlpaZrSuYMuMYHQwGMPS12ixgL9/keFTj1Lwb0GKvTyq3LNJEokBBBAAAEEEEAAAQRqQoAAaE0ocw0Eigi4WVlyH/lneGvAUeDO24rk4C0CCCCAAAKJK5AXCChw2Z+UtmCOAs88IfXsXlCZufMVOucCBfv0V+j5iXLzJ1EqyMAaAggggAACCCCAAAJVK0AAtGo9ORsCZRII3TFeyt7h5XX+eK6cfn3LdByZEEAAAQQQSCQBx4wRGrjoAqXN+1GBF5+T+vUpKP6ChQpdOELBnv0UevJpuTk5BftYQwABBBBAAAEEEECgCgUIgFYhJqdCoCwC7uLFcp9+Jpy1jvliOObWshxGHgQQQAABBBJWwDFd4wPnnKW02d8q8PpL0oD+BXVZslShS/+qYPc+Cj3yqNwd4R8ICzKwhgACCCCAAAIIIIBA5QQIgFbOj6MRKLdAaPQdUm6ed5xz6Qg5XbuW+xwcgAACCCCAQCIKOI4Z9uW0U5T+3UwF3p4kDdq/oBorVip05bUKdu2l0H0Pyt2+vWAfawgggAACCCCAAAIIVEKAAGgl8DgUgfIKuHPmyn3plfBhDeorcOuN5T0F+RFAAAEEEEgKgcDxxyn9q88UeH+KdMhBBXVavUah625SsHNPhcbfLXfLloJ9rCGAAAIIIIAAAgggUAEBAqAVQOMQBCoqELpllBRyvcOdv/1VTps2FT0VxyGAAAIIIJAUAoGjfq/0T/6jwIz35RxxWEGd1m9Q6NYxXiA0OOYOuRs2FOxjDQEEEEAAAQQQQACBcggQAC0HFlkRqIyA+9VMuW+/Gz5F0yYKXH9NZU7HsQgggAACCCSVQOCwQ5X2n2lK+/xjOcccVVC3TZvlmskDg132VPDmkXLXri3YxxoCCCCAAAIIIIAAAmUQIABaBiSyIFAVAqFbRkdOE7jxOjnNmkXes4IAAggggAACYQHnwCFKe+9tpX3zhZyTjpecfJmt2+ROuDccCL3merm//QYZAggggAACCCCAAAJlEiAAWiYmMiFQOYHQhx/Jnf5x+CStW8m54vLKnZCjEUAAAQQQSHIBZ9+BSnvzdaX9MEvOGadKgfxIaPYOuQ88omC33gr+9Sq5y5YluQTVQwABBBBAAAEEEKisAAHQygpyPAJlEAiNvC2SKzDqZjmZmZH3rCCAAAIIIIBA8QLO3nsp7dUXlTb3Bzl/PEdKTwtn3pUj99HHFezRV8ERf5a7cGHxJ2EPAggggAACCCCAQEoLEABN6dtP5WtCIPTvt6SZs8KX6tJZzoj/q4nLcg0EEEAAAQSSSsDptafS/vWM0n6eLeeSi6Q66eH65ebJffpZBXvtreD5F8ud/3NS1ZvKIIAAAggggAACCFRegABo5Q05AwLFCrihkEKjbovsD9wxWk7dupH3rCCAAAIIIIBA+QScbt2U9tRjSls4T87ll0oZ9cInCIbkTnxJwX4DFDzrPLmzfyrficmNAAIIIIAAAgggkLQCBECT9tZSsXgQcCe+KM2dHy5K395yzj07HopFGRBAAAEEEEh4AadjR6U9+pDSFs2Xc/UVUoP64TqFXLmvvqHgPvsrePLpcr/5NuHrSgUQQAABBBBAAAEEKidAALRyfhyNQLECbk6OQreNjewPjLtDToB/chEQVhBAAAEEEKgCAadtW6Xdf4/Slvwi58ZrpUYNw2d1JfetKQru/zsFjz1B7hdfVsHVOAUCCCCAAAIIIIBAIgoQjUnEu0aZE0LAfeIpacnScFkP2E+Bk05IiHJTSAQQQAABBBJRwNljD6VNGKe0pQvkjL5FatokUg136gcK/u4wBY88RqGP/xvZzgoCCCCAAAIIIIBAaggQAE2N+0wta1jAzc5WaPzfI1cNjL8jss4KAggggAACCFSfgNOsmdJuH+0FQgPjbpdatohczP3PDIUOP1p5hxyh0AcfRrazggACCCCAAAIIIJDcAgRAk/v+UrtaEnAffETKWu1d3Rl2uAJHDqulknBZBBBAAAEEUlPAadxYgVtu9LrGB+65S2rTugDis88VOvp45Q0+WKEp7xZsZw0BBBBAAAEEEEAgKQUIgCblbaVStSngbtyo0D33R4pA688IBSsIIIAAAgjUuICTmanAdVcrbfHPCjx8n9ShfUEZZs5S6IRTlTdwkEKT3pTrmoFDSQgggAACCCCAAAJJJ0AANOluKRWqbYHQ382Xq02bvWI4Jx0vZ9ABtV0kro8AAggggEDKCzgZGQpc8RelLZynwBP/kLp2KTD5/keFTjtbwb33Vei1N+SGQgX7WEMAAQQQQAABBBBIeIH0hK8BFUAgjgTcrCy5Dz8aLlHAUWCsGXuMhAACCCCAQAoKDB8+PK5rHejRWYdn1tMZi5apffaOcFnnzFPozPO0skF9vdK9s/5rus2HzP/n8ZamTZsWb0WiPAgggAACCCCAQFwL0AI0rm8PhUs0gdCdZoyx/C9RznnnyOnXN9GqQHkRQAABBBBICQEb2PxP+7b688GDdM/efbQss0Gk3jYgeu3s+Xrq06/0+xWrlE6L0IgNKwgggAACCCCAQCIKEABNxLtGmeNSwF28WO7Tz4TLViddgdtGxmU5KRQCCCCAAAIIFAiEHEf/bddalx90gCbs01eLGmVGdrbeuVN/m/Oznv7kKx27bKXqBIORfawggAACCCCAAAIIJI4AXeAT515R0jgXCI25U8rJ9Urp/OkSOV27xnmJKR4CCCCAAAIIRARMIPSzNq28ZcjqtV7X+D23bPV2t9y1S5fPW6CzFy7VG107alqHdtqVnhY5lBUEEEAAAQQQQACB+BYgABrf94fSJYiAO2eu3BdfDpfWjBsWGHlTgpScYiKAAAIIIIBAUYEvW+8hu+y3dr3OXLRUfTdt8bI0y8nRiJ8XesHRN7t01Lud2mlHOh+ni/rxHgEEEEAAAQQQiDcBPrHF2x2hPAkpELp1tBRyvbI7f/urnDZtErIeFBoBBBBAAAEECgS+2aOF7NJ//UadZVp/9t+4ydvZJDdXFy5YpNMWL9NbnTvonc7tta1OnYIDWUMAAQQQQAABBBCIKwECoHF1OyhMIgq4M7+WO/mdcNGbNlHg+msSsRqUGQEEEEAAAQSKEfixRTPZpffGzTpn4RLtawKiNjXMy9N55v0pS5ZrSqf2mtylg7bUrVvMWdiMAAIIIIAAAgggUFsCBECrWT5kZg21y04ziH5xKcd0p7JplxlfKhBgXqrinOJ1e+DGkfLvWvDqvymvfn2ZGx6vxaVcCCCAAAIIIFBBgfnNmmj0/vuox+Yt3nigg0wXececq4GZHOlM0xr0xKUr9J4JhL5pAqEb69Wr4FVKP6ykz5WlHx1fOYL5E0vZz8OuG+5NE18lpDQIFC+Qa1qD+ynP/CCSTP82/XrxmtwCNlZhk/277JixsEkIxKuAjZfZVJnPCgRAq/nu2geK/c9w48ZwS4GSLrd58+aSdrMvDgXqfPKZmn78X69koZYtteHcM2VudhyWlCIhgAACCCCAQFUJ/Nqkse7cd2912brN6xr/OzNpkv0xNMN87rOtQf9gZox/v0NbTTLjhK6rn1FVl42cpyyfKyOZE2Rl27ZtCVJSiolAbAEb/CQAGtuGrfEvsH37dtmFhEC8ChAAjdc7E1WutLQ01TFjQrVq1Spqa+FVeyNt8LNFixay+UmJI+De92CksIFRN6tVly6R96wggAACCCCAQHILLGnUUBMG9FOHbdt1lpks6ZBVa2Q/ydU1gdDjTRB0+PLf9FH7NprUtZOyzCSJVZVK+lxZVdeoqfPYhgIbNmxQ06ZNVZfhA2qKnetUkYANeG7ZEp4kLTMzU3YhIZBIArYV/vr169W4cWNlZFT9D3aJZEFZ41vAD4BWpqUyLUCr+R7bm2OXkgKbfrd3m6ekfNVcVE5fToHQm5Plfv1N+KgunZV22Qg5BLDLqUh2BBBAAAEEEl9gRcNM3du/r17o0dWbNf7w31Yr3XTnrmOWY1as0lErszSjbWu93q2TVmY2qHSFk+nzot/90n4eTqZ6Vfomc4KEEPC/x9nClvadLyEqRCFTVoBncMre+oSpuP8ZoTIBUH/owoSpNAVFIB4EXNOyIzTqtkhRArePkkOrhYgHKwgggAACCKSigG3l+dBevTXikMF6r0M75eaPp5ZmAqFH/palxz6bqet/mKvOpus8CQEEEEAAAQQQQKDmBAiA1pw1V0oiAfeFl6Q588I16ttbznnnJFHtqAoCCCCAAAIIVEZgrRn385/99tT/DR2it82kSDvzJ7m0H7wPzVqjf3w+Szd//5O6b9lamctwLAIIIIAAAggggEAZBegCX0YosiHgC7hmhrzQbWP9twqMvV1O/hebyEZWEEAAAQQQQCDlBTZk1NOTfXrq1W6dvcmRjjVjgtY3463ZeXYPWr3OW2bu0cLs76SfmzZJeS8AEEAAAQQQQACB6hIgAFpdspw3aQXcJ56SFi8J1++A/RQ4+cSkrSsVQwABBBBAAIHKC2yuV1fP9uqu181kSCcvXa7jlv2mhmbyH5sGrV3vLd+1aKZXunfWnGZNK39BzoAAAggggAACCCBQSIAAaCEO3iBQsoCbna3QuLsjmQLj74iss4IAAggggAACCJQksK1uHU3s2U2TunTSCctW6ISlK9Q4NxwIHbh+o+zyk2kJ+nKPLvrBBERJCCCAAAIIIIAAAlUjwBigJepSegAANr1JREFUVePIWVJEwH3oH1LWaq+2zuGHKnDksBSpOdVEAAEEEEAAgaoSyK6Tblp7dtHFZozQZ/fspo0mMOqnvTZt1rhZP+i+L7/R/qZ1KAkBBBBAAAEEEECg8gIEQCtvyBlSRMDdtEmhv98XqW3grjsj66wggAACCCCAAALlFdiZnq5Jplu8nSzpKdNFfp3pKu+nXpu36rZvZ+shM2HSgavXSmYmeRICCCCAAAIIIIBAxQToAl8xN45KQYHQ3fdKplWGTc6Jf5AzeFAKKlBlBBBAAAEEEKhqgZy0NE3u0lHvmhnjj1qxSqcuXq7WO3d6l+m+dZtu/X6OlmY28FqNftZmj6q+POdDAAEEEEAAAQSSXoAWoEl/i6lgVQi4WVlyH340fKqA4838XhXn5RwIIIAAAggggIAvkBcI6D0TBB1xyGA91K+XfmtQ39+lztuzdeOPc/X4ZzMV+tcLcvMnUYpkYAUBBBBAAAEEEECgWAECoMXSsAOBAoHQ2AlS9g5vg3Pu2XL26lewkzUEEEAAAQQQQKAKBULmx9YPO7TVZQcP0r1799Yy0/rTT+3N55HQBZcouOdeCj31/+Tm5Pi7eEUAAQQQQAABBBAoRoAAaDEwbEbAF3CXLJFrvmB4yUxaELhtpL+LVwQQQAABBBBAoNoEQo6jj9u10eUHHaAJ+/TVokaZBddavEShP/1Fwe59FHr0Mbn5XeYLMrCGAAIIIIAAAggg4AsQAPUleEWgGIHQGDPZUU6ut9cZ8X9yunUrJiebEUAAAQQQQACBahAwgdDP2rTSlb87QHcO3Es6YL+Ci6xYqdBfr1away+F7n9I7vbtBftYQwABBBBAAAEEEPAECIDyFwGBEgTcufPkvvBSOIcZhysw8qYScrMLAQQQQAABBBCoXoGvWrVU+sz/KTB1snTQgQUXy1qt0LU3KthlT4Um3CN3y5aCfawhgAACCCCAAAIpLkAANMX/AlD9kgVCt46WQq6XybnyL3Lati35APYigAACCCCAAAI1IBAYfrTSP5uhwPRpcg4/tOCK69YrdPMoBTv3VOj2sXI3bizYxxoCCCCAAAIIIJCiAgRAU/TGU+3SBdyZX8t9a0o4Y5PGCtxwbekHkQMBBBBAAAEEEKhBgcDhhylt+vtK+98MOcOPKrjyps0K3TbWC4QGbxkld+3agn2sIYAAAggggAACKSZAADTFbjjVLbtA6BbT+jM/2eCn06yZ/5ZXBBBAAAEEEEAgrgSc3x2otKlvK+3r/8k54TjJyS/e1m1y77rH6xofvO5GuatWxVW5KQwCCCCAAAIIIFATAgRAa0KZayScQGj6DLn/mREud+tWcv7214SrAwVGAAEEEEAAgdQTcPbfT2mTJynt+6/lnH6KFMiPhGbvkHvfQwp2663gFVfLXb489XCoMQIIIIAAAgikrEB6ytaciiNQgoAdO8tPgVtvlJOZ6b/lFQEEEEAAAQQQiHsBp//eSnvtJbnzf1Zo3AS5L78qBUPSzl1y//GYgk88JefC8xW46To53brFfX0oIAJVJeDu3CnZltBm4jB3VZa3Hn7NX//N7MvLk/035Ow7UNp3gJwB+8hp3ryqisB5EEAAAQRqQYAAaC2gc8n4Fgi99bY0c1a4kJ07ybl0RHwXmNIhgAACCCCAAALFCDi9eylt4rNybxup0Pi/y534opSb5y3uU88o+Ozzcs49W4Gbb5DTa89izsJmBOJfwN2yxQQzs8LDPHiBzWLWzfi4ZUnunHnmh4PXCrJ27WICoiYYOnCACYoONK/7SE2aFOxnDQEEEEAgrgUIgMb17aFwNS3ghkIKjRwTuWzg9lFy6taNvGcFAQQQQAABBBBIRAGne3el/b8n5I65VaEJ98p95jlpV45p6RaU+/wLCprAqHPGaQrcepOcvfolYhUpc5wLDB8+vPwldF01zs1Vc/N31S7Ndu2KWrfv7fbwtnrmc3y1psVL5Npl0luRy2ypV1eLGzfSwsYN9at5XdSoodbWz4jsr6mVadOm1dSluA4CCCCQsAIEQBP21lHw6hBwX3xZMr/2eqlPLznnnVMdl+GcCCCAAAIIIIBArQg4nTop7Z8Pyx15k0J/v0+2FajM+KAKuXJfeV3BV1+Xc/KJ4UCo7f5LQqAaBALm71uznN0DmjaYGQ5q5gc8TZ40EwStimTPsrVOujbUq6eNJnC5wSzh13oF66bhg90fkKvuW7aZZat65L+2356ttCIFaWECsC3Wrtcgs/hpi7nGwqig6EITFF3VoL6ZmMyfmczPySsCCCCAQE0KEACtSW2uFdcCrvl1OTTmzkgZA2Nvl5NW9GNOZDcrCCCAAAIIIIBAwgo47dop7UETAL3lRoXue1DuP5+Qtm2XifvI/fdkBc3iHDdcgZE3yxkyOGHrScFrVsDdYYLpdnxNryt64fE1b5/1Q6T1pm3VWVXhwKCp4qZYwUy7LT+gaQOddskLlH0O4J+aN5Vd/FQ3GFS3rTYoGg6M2tdO5t9MnSIB2sZmiImB6zd6i39stvlOYVuJ+oFR+7ois4FCBEV9Il4RQACBahcgAFrtxFwgUQTcJ5+WTLcWL+2/rwKnnJQoRaecCCCAAAIIIIBAhQScVq2Udvd4uTdep9CDj8h95J8mmhQeI9F9d5qCZnGOPEKBUSYQOvSQCl2DgxJfwN20affxNbNsgDO8uPlBT20243AWk/YrZntxm3NMsDIcwPRbaoZbZ/qtN8MtOOtpc906cmsgkJhjgpjzmzbxFr/M6abbfWcTBLUtRW1AtId57bx1uzKKdMdvYIKne2/c7C3+sbtM/Rab1qF+93n7uqxhZrmCtP65eEUAAQQQKF2AAGjpRuRIAQE3O1uhsRMiNQ2MvyOyzgoCCCCAAAIIIJDsAnaG67Q7xsi99iovCGqDoVq/wau2+9F0Bc2iQw7yAqGB3x+Z7BwpUT879r3Wrds9sOkFNVflz5AebsWpnbuqzMS2hrTBy+iu6H4wM7w9HPDcXqdOlV2zuk5kW5SGW3U2ilwiYFqEdjDd5aODot1McNQGQaOTHbO0twkY28VPeSaQu9QEQaODoktMkHQXvdJ8Il4RQACBCgsQAK0wHQcmk4D78KNS1mqvSs7hh4oP9sl0d6kLAggggAACCJRVwDGzWju22/tVV8h97Emve7xWrwkf/un/FDrqDwoNPsAEQm9R4Lhjynpa8tWggB3WSfmtM90YwczwNhPYXGPuq5kEq0qS7c/esqXUto2ctm29V2+9TZv8bW100S23eN3Qkz2YZ7u125acdpnRLl/XBEXbmbF2I93nTVd6GxRtYu9VVEo3+brbbvZmOWqluUcm2Ttku8tHd5+3AdId6XyV94D4AwEEECijAE/NMkKRLXkFbJceOwmAn2j96UvwigACCCCAAAKpKuA0bCjn+mvk/PXP3kRJ3mellb+FOb76WqE/nKzQwH3CY4SaSZOcGuiCnGr3wjUTAGnbNjNzz9bw+Kzm1bXv7VitdtuGjXJjdUNfbybkqZp5g6R0Mx5+69aRIKbyg5uOCXTa9fCrWTd5nFJabGbZiYBSNZl/H7+ZIKZdPm3bKqKwx46d4ZaiJuDZY3O4G31ze9+jkp2RoLNpUWqXI1aFG2zY22snVrITLNlgaOjDj+QMHCCnpQlCkxBAAAEEYgoQAI3JwsZUEvA+0G804xqZ5Jz4Bwb6T6WbT10RQAABBBBAoEQBp359OVf+Rc5lI+Q+85xCd5sfjZcsDR/z3Q8KnXqW1K9PeNb4M0+XY7oEp2LyupNvN4FJL2Bpg5ThwKXrByujtntBTBPw8vPYgKbrBTnttvzg5hbTLbqqWmfGuiH1M7wAZrjFZpFgZnQrThNQI7gdC7Bqtq0198EuX7beI3LCpmZm+eju87bVaOudOyP77YptcGtblNrlkNVrvZbZXoZOHU0gdB85+w6UzOLsa4KiZsIzEgIIIICA+U0PBARSWcBdvVpe93eLEHBkZ34nIYAAAggggAACCBQWcMxs2s5lf5JzycVyJ76o0F1/lxYsDGeaM0+hcy6QbrtTATOrvHPu2XLivHuuawNK+UFKP+hoA5N33niTGpjAY4YZr7F+Xp7qe6/h9/72DLPfjucYnScjaMbTjIO0zbgXniTIzoReL3/MTX8yoXrKrhP1NXDrRtOi1Cy/zI2DGlAEO6P9N3u08BZfo6HpKh/pPm8CojZAaoOfu/3csGy5XLtMfsc/1LTObeUFQsMBURMUtQHSrl0L9rOGAAIIpIhA1P98KVJjqolAlIA38ZHpTmKTc85ZcvbqF7WXVQQQQAABBBBAAIFoARvYdC66QM7558l99XWFxk2Q5s4PZ/nlV4UuHCHdPk6Bm66Tc+H5soHTyibXTh4THaw06+EWk/mtJb194RaVJbaujG51WUzA8tbKFraSx+eartLZxninmfRmh+l+vsO87sx/jX6fnZau7SaIWXSW9Fwmy6nkHYjPw7eZ4QV+aNHMW/wSZpgAfTfzd9oGRi8bPETut99J88y/xaIth80Yvu7UDySzREZGaNbU6zIv20LUaylqWoz27JGyLbh9U14RQCC5BQiAJvf9pXYlCLhLlsh98ulwDvMBMnD7qBJyswsBBBBAAAEEEEDAF3BMoM378fjsM+VOelOhsXdJP8wO7168RKFL/yrdeZcCN5hxRM3YhIUCk/kBS2/bps1qZMasDOTkKrhjR36+gjEvvcCnGScxHpOdnKYgOJkeDlbmBy6LBjDtzOfhvCafH9jMz+sHOW3g006gQ0KgLAI7zd+XuSaQaZe/PBf+TuO1bP5xttzvvjcBUbuYoOjsnyTTrb5QMsN/udM/lswSCYqaSZs0wLQOtWOJ5gdG1bdP3LfmLlSvFHvj7tolZZvGPHYIDdMqWPYemonHnAwzxAUJAQR2EyAAuhsJG1JFIHTbWMl82LbJdudyunVLlapTTwQQQAABBBBAoEoE7PiQzmmnKGCW0JR3FbpzvPT1N+Fzr1ip0JXXlngdG+7zv6pHAjElHlGJnXbcy0aNTJCgoXk1i53oKWrd7nv1nXciAUobqPQCmV6gsnCrTLsvx2wnIRBPAl7ga9ABcsziJ9e0FNWcuV4wNBIU/eFHKb8XnJ/PGwris8/l2sXfmFFP2nuv/Fai4dai3vt6ZjupXALeOMF+sNIf69e2Zo9aV34r9UgLd+/HovAPQpFxgv2W7Hac4Fxzb2MlExQPj+/b1nv11k1g1L5Gb3caN451NNsQSFoBAqBJe2upWEkC7tx53vhVXh7zYTgw6uaSsrMPAQQQQAABBBCIG4Hhw4fHTVl2K0jzRtp3v/46c+FS9TOtOyuagiawaltG+kHIbD8Ymd96cofpAl7Q+jIcqNwtj2khVxDATJMbs3Wl+THcHwNzlSntnvwgXtF7xnHxKeCNx7tPfzlmkRm+wiYvGPfLgvygqGklaluLmlajKvpvdqdpYWh+0HDt4lfP/Bv0Wob6kyyZV9nz2x8TkijZ1pVnHHOsGQfYjAVshhWw4wHb8X/9cYH91+ixgG2+8Pv8/OYYf+xgm7/Gkp3g17by9YcnMReO3L+oQuw0k9aFxwyup5/N2LMb8peNJsBdsF5XW8wQDGY2tKgjK786bdq0yp+EMyBQTgECoAZsl3m4vfHGG5o1a5Y2btyonj17asCAAbIfLtP4Zbecf6USI3to5BgpFP5vwJvZtK35dYyEAAIIIIAAAgggUGmBb1s2l1323rBRQ1etUZrrRo1lWdAF3A9u2tfCwc505aXobPKVxucECJRBwLH/vnr3kmMWmXkQ/OQuWhTuOm+DoTYoarvQr1nr7w6/2jFGf/xJrl2emxjeZiaT1Z49wy1FTRd6b2xR25W+WbPCx1bTO2+c4O3+mMDhV2+IDdu60raU9PaZcYJNV/HIdttt3LawNHl2a11p95l6vlxN5a3Mae04wf6zs+h4wTbY2szENprn5KhRca1Doy6eEQqprRlixC4lpTxzzU1mPOfooOgGEyQtPOGaeW/yhOzfBRICcSqQ8gHQTZs26fLLL9fy5cu9W9S8eXPZXyPs8vnnn2vMmDGqWwWDt8fp/U/JYrlfz5L75tvhujdpbMamKrlrVkoiUWkEEEAAAQQQQKCSArObN5NdSAggkBgCdkgwb1gwM6SFn9yVK72gqEww1AZEbTd6meEtCiXbsGT+L3Lt8tKrBbu6dikYT9SOK2qDoq1byzXj/XrjVuYHICOBSb97txecNIFJrwt4eIKzcP4YwUqbJ9ucLw6TbfO5K78luz/Wb/jHnvCYwX4gM/pHIC+fd8zueezkZ2UNMKab4GYzM/arXZrboGhkPfw+vD1HTUywtLTBPNLNj1gtzTnsUlKyzYs2163jBUojrUhNLMUGSv2Wpn7QtKTzsA+B6hJI+QDonXfe6QU/Bw8erFGjRqlJkyZaaR7yt956qz755BM9/PDDuu6666rLn/PWgkDoltGRqwauNwPzm6A3CQEEEEAAAQQQQAABBBBAoLCA07697KLjj4vscNetC7cOzW8l6gVFTevR3fpZL14i1y6T3oocK9tCML8nXsHGOFmz4wTbrvz5YwPPW7ZMRScwi57gzA9qFs0TDnLW7jjBthX9WlMfu5SUHBPctEFQGyAtCJIWBEz9QKkNotYxeUtKtu1nUzPHhl201bS+LSHlNW1VaDzS6LFJo9cdE58hIVBVAikdAJ07d65mzpyp+vXra+zYscrIny2tvXnA33///TrllFM0depUXXrppWZMdDNgOinhBULTZ8j9aHq4Hq32kHPVFQlfJyqAAAIIIIAAAggggAACqStQ6+MC9+ikBp3bqbtpudl9y7b8Zavam4mWdmtdWEXBT3+c4EIByfzhNKLHB/bGCy7SCrMgYBkeZ9gfUzhUdJzLti2T/i+VHRt5k+nObhcTwi4xNczNzW9RaluWhoOksYKmDcoy3ulmMzSBWWyrYT/FDK/aAK4drq5NazneJE5t81/bFA6gtmwpb2gH/2S8IhBDIKUDoB9//LFHcuihh0aCn76R7Qo/aNAgffHFF14Q9IwzzvB38ZrAAoVaf956k5zMzASuDUVHAAEEEEAAAQQQQAABBGpfILtOujfkRfSwF/VMIKyr6dYeDoqGg6N2MqDoycnsetEJzMJBzYIu4H6LyuhgZ645jlSzAtvMZEh2Wd6w5O/Q9r43NxNo2bFIC7rhFw6adrGNz9av373VcNEq2fFJFy32Fj9A6r8Wymon5zLDK4Rbj9rgqAmamoBpJGhqAqj2vdqYbXZSJ1JKCqR0AHTOnDneTbfd32MlPwD6448/igBoLKHE2haaPEX66utwoTt3knPZiMSqAKVFAAEEEEAAAQQQQAABBBJEwI5/Ob9pE29JkCJTzCoQsPd9VWYDbynudHbOFde0KFVWlrQqS65ZtGpV/mvUetZqabVZ7ORbJSW7f+Vv3hIdII1e9w63/fRbtMgPjoaDpIW63HutTMMBVKdBg5KuyL4EFEjpAKgd69Ompk2bxrx1/nZ/gqSYmczGESNGKNf+442R8vLyvH3r7a8bxaSQGaDYJjsDvVO02X0xx7C5nALGuOFNIyNdMLKvu0q5dnBtEgIIIIAAAggggAACCCCAAAII1JhAJD5ig4zdu4WX4q5uvss76zfIMYHQwOo1Ba8mOBp+v8a8rpazZq2cnabFaEnJRkTXmdiMWdzZ4QZxNvtugVK7zYwFGzItR3OPO0a7Rt1ss5FqUWBX/iRcfvysIkVJ6QDo9u3hgXn9QGdRwMaNG3ub/HxF9/vvv/rqK/k3w9/mv/bv31+uGSw4xzT/Li0VF0Qt7Tj2l0HA3IPtV1yuzHvul5ueru0nnSBzU8pwIFkQQAABBBBAAAEEEEAAAQQQQKCqBMoSHyl0rSYmNmOXPXsW2lz0jWPGFQ2ssQHR/GXt2vC6v817NdvK0BjK2bZNab9uU46Z9Kvc5S1aMN5XWqAq7kHKBkBt1Hhn/q8DxU1w1NDO/mZSccHNSt9BTlBzAqZl7a6TT9Cu449V4LdVUoKMGfPss8/WnBFXQgABBBBAAAEEEEAAAQQQQCBBBVwTJA3apWePkmtgxhaNBErzg6NpkSBpftDUtjbdsEGhVmbGelJSCKRsADQQCHizv+/YsaPYAKcf+Kxbt26JN/vDDz/0WnnGyjRu3DitM78YtCrhH429zubNm81QFC1MXI7BnGM5Vum2du2q9HSpfjLbQtpvJW1bTWfYAa1JCCSQgP01cdOmTWrWrJnqMCh6At05imoFsrOztc20ULDJ/nDbgPGqPAv+SBwB2wPKDgNle2SV9pk7cWpFSVNFwDao2bLFzGZtUqaZXNUuJAQSSSBoJiyy3dFT8nucmRektOSaIQ0zzf9TDevXLy0r+6tZwI/PVWbYyJQNgNp707JlS9nxPbcW0/zZ317af2St7WxjxaR0093a3qCSAps2GGuTzVNSvmIuwWYEalUg+gFk/y7zd7hWbwcXr4AAz+AKoHFI3Aj4f39tgXgGx81toSDlEPDH8uLvbznQyBo3AtHP4NK+88VNoSkIAjEEeAbHQLGbbAO1evWK2cnmmhTw4wzR8YfyXj8ceSvvUUmS3wZAbfIDnUWr5f+aZ1sFkRBAAAEEEEAAAQQQQAABBBBAAAEEEEAg8QRSOgDqd0tftGhRzDvnb+/Tp0/M/WxEAAEEEEAAAQQQQAABBBBAAAEEEEAAgfgWSOkA6LBhw7y789FHH+12l2x3nOnTp3vbBwwYsNt+NiCAAAIIIIAAAggggAACCCCAAAIIIIBA/AukdAB0yJAh6tKlixYsWKCpU6cWulsvvviiNxhw586dNXjw4EL7eIMAAggggAACCCCAAAIIIIAAAggggAACiSGQ0pMg2cFTR4wYodGjR2v8+PH64osv1LNnT82ePdtbt7MB33DDDd4kRolxOyklAggggAACCCCAAAIIIIAAAggggAACCEQLpHQLUAsxdOhQPfDAA2rTpo1mzJihJ5980gt+2pah9957r/r37x/txToCCCCAAAIIIIAAAggggAACCCCAAAIIJJBASrcA9e/TwIED9frrr3td3pcvXy47OZINiAYCKR8f9ol4RQABBBBAAAEEEEAAAQQQQAABBBBAICEFCIBG3bYWLVrILiQEEEAAAQQQQAABBBBAAAEEEEAAAQQQSA4Bmjgmx32kFggggAACCCCAAAIIIIAAAggggAACCCAQQ4AAaAwUNiGAAAIIIIAAAggggAACCCCAAAIIIIBAcggQAE2O+0gtEEAAAQQQQAABBBBAAAEEEEAAAQQQQCCGAAHQGChsQgABBBBAAAEEEEAAAQQQQAABBBBAAIHkEGASpBq4j2vXrtVrr71W7JVyc3O1fft2NW7cmJnni1ViR7wK7Ny5U3axqUGDBqpbt268FpVyIRBTwH8GN2rUSGlpaTHzsBGBeBXYtWuXduzY4RWvfv36qlevXrwWlXIhEFMgGAxq69atyszMVJ06dWLmYSMC8SqQk5Oj7Oxsr3gZGRmyCwmBRBIIhULasmUL3+MS6aalaFnt87ayiQBoZQXLcPyyZcs0atSoMuQkCwIIIIAAAggggAACCCCAAAIIIIAAAghUpYDjmlSVJ+RchQXsr9r2VxUSAskq8OSTT+qf//ynV7277rpLxxxzTLJWlXohgAACcSfw6quvyj57bbrxxht19tlnx10ZKRACCCCQrALvv/++9+y19bvsssu8JVnrSr0QQACBeBBIT0+X4zgVKgotQCvEVvaDbHdKulSW3YuciSmQl5fnFdw+iOi+lpj3kFIjgEDiCvAMTtx7R8kRQCCxBexnX/8ZbGvC5+DEvp+UHgEEkluASZCS+/5SOwQQQAABBBBAAAEEEEAAAQQQQAABBFJagABoSt9+Ko8AAggggAACCCCAAAIIIIAAAggggEByCxAATe77S+0QQAABBBBAAAEEEEAAAQQQQAABBBBIaQECoCl9+6k8AggggAACCCCAAAIIIIAAAggggAACyS1AADS57y+1QwABBBBAAAEEEEAAAQQQQAABBBBAIKUFHNeklBag8gggUCmBhQsXasGCBd459tlnH7Vt27ZS5+NgBBBAAIGyCyxbtkxz5871Dujbt686depU9oPJiQACCCBQKYGsrCx9//333jl69uyp7t27V+p8HIwAAgggUH0CBECrz5YzI4AAAggggAACCCCAAAIIIIAAAggggEAtC9AFvpZvAJdHAAEEEEAAAQQQQAABBBBAAAEEEEAAgeoTIABafbacGQEEEEAAAQQQQAABBBBAAAEEEEAAAQRqWYAAaC3fAC6PAAIIIIAAAggggAACCCCAAAIIIIAAAtUnQAC0+mw5MwIIIIAAAggggAACCCCAAAIIIIAAAgjUskB6LV+fyyOAQIIK7Nq1S2+88YZmzZqljRs3ys58OWDAAA0fPlxpaWkJWiuKjQACCNSMwLvvvqt//etfuu2229SnT59iLzp//ny9/vrrWrp0qTIzM7X33nvriCOOULdu3Yo9piLP54ocU2wB2IEAAgjEocCMGTP06aefasWKFQqFQurUqZMOPPBA/f73vy+2tBV5NtbUMcUWmh0IIIAAAjEFmAU+JgsbEUCgJIFNmzbp8ssv1/Lly71szZs314YNG7z1oUOHasyYMapbt25Jp2AfAgggkLICs2fP1pVXXqm8vDw98sgj3o9HsTDsj0wPPfSQt6thw4bKycnxlvr162vChAnad999dzusIs/nihyz24XZgAACCMSpgA1IXn/99fruu++8EjZu3Nh73bJli/dqf8D/+9//LvtsjU4VeTbW1DHR5WQdAQQQQKBsAnSBL5sTuRBAIErgzjvv9IKfgwcP1jvvvKPJkyfrlVdeUffu3fXJJ5/o4YcfjsrNKgIIIICAL2C/gN96661e8NPfFuvVBknts9T+mDRu3Di99957mjZtmhc43bFjh6677jplZWXtdmhFns8VOWa3C7MBAQQQiFOBRx991At+dunSRU8//bRsC3y7PPXUU+rYsaO+//5778eoosWvyLOxpo4pWlbeI4AAAgiULkAAtHQjciCAQJTA3LlzNXPmTO9X8rFjx6pJkybe3vbt2+v+++/3ur9PnTpVW7dujTqKVQQQQCC1BbKzs3Xvvfd6AUw7bEggUPJHsOeff16u6+q8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" width="672" /></p>
<p><span class="pagebreak"></span></p>
<p>Let <span class="math inline">\(b_1, \dots, b_{K + 1}\)</span> represent bin edges of bins with width <span class="math inline">\(h\)</span> and <span class="math inline">\(n_1, \dots, n_K\)</span> be the number of observations falling into the bins. Let <span class="math inline">\(c_0, \dots, c_{k + 1}\)</span> be the midpoints of the bin interval.</p>
<p><br /><br /><br /></p>
<p>The frequency polygon is defined as</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>MISE</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>AMISE</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>Gaussian rule for binwidth</p>
<p><span class="pagebreak"></span></p>
<p><img src="data:image/png;base64,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l71795qZqlWrSu/evaFB4JoCYWFhov3Desprr71m3T3sWcYrAggggAACCCCAAAIIIICAvQVIgNr7/NF6BBBIJLBp0yZ54403zBJ9tFnv7vM84pxoMyYRSCIQEREh2mesFu0HNDw8XNatW5dkG2YQQAABBBBAAAEEEEAAAQTsK0AC1L7njpYjgEAigYsXL5rEVXx8vFk6YMAAqVatWqItmETg2gJTpkyR5s2bmw3i4uLk+eefly1btlx7B9YggAACCCCAAAIIIIAAAgjYRoAEqG1OFQ1FAIHUBIYNGyY//fST2aRy5cry+uuvp7Y56xBIIqCDZEVFRUmdOnXMcu1LtnHjxrJr164k2zGDAAIIIIAAAggggAACCCBgPwESoPY7Z7QYAQSSCWzfvl3+9re/maWayNJR34OCgpJtxSwCqQsEBgbKqlWrRPuO1XLkyBFp0KCBHDp0KPUdWYsAAggggAACCCCAAAIIIODXAiRA/fr00DgEELiewJUrV8yj7/rYspbu3bvLww8/fL3dWI9AigIhISGydu1aKVeunFm/Z88eCQ0NldjY2BS3ZyECCCCAAAIIIIAAAggggID/C5AA9f9zRAsRQCAVgfHjx8u3335rtihTpoyMGjUqla1ZhcD1BUqUKCExMTFStGhRs/G2bdukadOmcunSpevvzBYIIIAAAggggAACCCCAAAJ+J0AC1O9OCQ1CAIG0CuzcuVNGjhxpbT5nzhwJDg625plAIKMCFStWlOjoaMmfP7+p4tNPP5VWrVqZUeIzWif7IYAAAggggAACCCCAAAIIZI8ACdDsceeoCCCQSYGEhARp166dXLhwwdTUtm1b019jJqtldwQsgfvuu0+WL18uAQEBZtm7774rvXr1stYzgQACCCCAAAIIIIAAAgggYA8BEqD2OE+0EgEEkgnMmjVL/vWvf5mlxYsXl4kTJybbglkEMi/QsGFDiYyMFB1cS8u0adNEu12gIIAAAggggAACCCCAAAII2EeABKh9zhUtRQCB/wkcOHBAXnvtNctj5syZcsMNN1jzTCDgTQF99D1x0nPgwIGyaNEibx6CuhBAAAEEEEAAAQQQQAABBHwoQALUh7hUjQACvhHo2LGjnD592lTerFkzef75531zIGpF4H8Cffv2lR49epg57X4hPDxc1q1bhw8CCCCAAAIIIIAAAggggIANBEiA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pUePHiHOEadHAAEEEEAAAQScKaB9gI4aNcr0Abpy5UozaKQGPa2UmJgon332mfTu3Vsuuugiuemmm0T7WT969Ki1Ca8IIIAAAggggEBYChAADcvL7pxCT5gwQfRhXVPfvn2lUKFCzskcOUEAAQQQQAABBBwooK1lrr76atMH6N9//y1fffWV3HvvvVKqVCk7t2fPnjU/Mt91112iI8937dpV5s+fLydOnLC3YQYBBBBAAAEEEAgXAQKg4XKlHVjO48ePy9SpU03OcuXKJQMHDnRgLskSAggggAACCCDgXAF9htI+QN944w3ZvXu3LFmyRHr16iXFihWzM33q1Cl57733pFu3biYYeuedd8rChQvl9OnT9jbMIIAAAggggAACXhYgAOrlq+vwsk2bNk0SEhJMLrWJlo5oSkIAAQQQQAABBBDImkCePHmkffv2on2AxsfHy4IFC6R79+4pWtjoD9CzZs2STp06mWby99xzj3z66ady7ty5rJ2UvRBAAAEEEEAAARcIEAB1wUXyYhaTk5Nl/PjxdtF08CMSAggggAACCCCAQM4IREVFmT5ANdi5d+9eeffdd6VLly6SP39++wSHDx+Wt99+2wRNL774Yrn//vtl6dKlogMrkRBAAAEEEEAAAS8JEAD10tV0UVm0psFvv/1mclynTh1p0aKFi3JPVhFAAAEEEEAAAfcIaNBTm79rH6AaDH3nnXekY8eOokFSKx04cMA0o2/ZsqWUK1dOBg8eLN9++63oj9YkBBBAAAEEEEDA7QIEQN1+BV2a/9jYWDvn1P60KZhBAAEEEEAAAQQCKqADTmofoIsWLTLN5LU/9rZt24o2n7fSnj17TEsdHWipUqVKMmzYMPn++++t1bwigAACCCCAAAKuEyAA6rpL5v4M//HHH6avKS2JjlZ6xx13uL9QlAABBBBAAAEEEHCZgA6U1Lt3b/NcpgMovfbaa3LdddeJDqxkpR07dsioUaOkUaNGctlll8njjz8umzZtslbzigACCCCAAAIIuELgf083rsgumfSCwLhx4+zmVPfdd5/ky5fPC8WiDAgggAACCCCAgGsF9Edp7QN02bJl8vfff8vYsWOladOmEhERYZcpLi5Onn/+edHui2rWrCn/+te/7C6N7I2YQQABBBBAAAEEHChAANSBF8XLWdLO9nX0d03a1Kp///5eLi5lQwAB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IECAAAECBAgQIECAAAECBAgQIFAXBSRBqotvzT0TIECAAAECBAgQIECAAAECBAgQIFCQgABoQUwqESBAgAABAgQIECBAgAABAgQIECBQFwUEQOviW3PPBAgQIECAAAECBAgQIECAAAECBAgUJCAAWhCTSgQIECBAgAABAgQIECBAgAABAgQI1EUBAdC6+NbcMwECBAgQIECAAAECBAgQIECAAAECBQkIgBbEpBIBAgQIECBAgAABAgQIECBAgAABAnVRQAC0Lr4190yAAAECBAgQIECAAAECBAgQIECAQEECAqAFMalEgAABAgQIECBAgAABAgQIECBAgEBdFBAArYtvzT0TIECAAAECBAgQIECAAAECBAgQIFCQgABoQUwqESBAgAABAgQIECBAgAABAgQIECBQFwX2q4s37Z4JECBAgAABAgTqvsDu3btj2bJl8fXXX0enTp2ic+fO0bBhw7r/YJ6AAAECBAgQIEBgrxIwA3Sveh1uhgABAgQIECBQvwW2bNkSEyZMiF69ekWzZs2ie/fuMWzYsDjmmGOy78cee2yMHj06Vq9eXWsQa9asiQYNGmSfyZMn19o4OiZAgAABAgQIENg7BMwA3Tveg7sgQIAAAQIECNR7gSVLlsTgwYNj/fr1eZ91586d8cknn2SfkpKSeOihh2LEiBF56zpJgAABAgQIECBAoFABM0ALlVKPAAECBAgQIECgxgJp5ufpp5+eC36efPLJ8eSTT8YHH3yQzfZcvHhxPPvss1mdNMj27dvj8ssvj/nz59d4TA0JECBAgAABAgQIJAEBUH8PCBAgQIAAAQIEal3ggQceiHXr1mXj3HjjjbFgwYIYPnx49O7dOw499NA47rjj4vzzz4+5c+fG/fffn9X77bff4qabbqr1ezMAAQIECBAgQIBA/RYQAK3f79fTESBAgAABAgT2CoFXXnklu4+mTZvGnXfeWeU9XXvttTFkyJCszqJFi2Lp0qVV1neRAAECBAgQIECAQFUC9gCtSsc1AgQIECBAgACBoghs2LAh66dNmzYFZXo/66yz4vXXX4/99tsvli9fHl26dMl7H2mpfLqegqQpo3yjRo3iqKOOyj7dunWLfW6m2p0AAAtmSURBVPap+e/7a9L3rl274uOPP87uNY3fpEmTePfdd2PevHnRtm3bOPfcc2PlypXx+++/Z0mfUp2q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" width="672" /></p>
<p><span class="pagebreak"></span></p>
<p>In practice, a simple way to construct locally varying binwidth histograms is by transforming the data to a different scale and then smoothing the transformed data. The final estimate is formed by simply transforming the constructed bin edges <span class="math inline">\(\{b_j\}\)</span> back to the original scale.</p>
<p><br /><br /><br /></p>
<p><img src="data:image/png;base64,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gD6s4v73R44cMV9CrZrqJEjBZ/i11vOKAAIIIIBARAUSJUok77zzjukWP3fuXNG/LfpZRdPFixelV69eMmDAAHnrrbekU6dOkiNHjohmzX4IIIAAAggggAACCCAQhoBrAqAnT560g58tWrQwXcq0xd7t27dl6tSp5mfgwIHy7LPPSpYsWWwOq2uzjsNVvnx5e33whZw5cwZ/y7IPCOhkFY0aNZIrV66Y2lavXl06duzoAzWniggggAACsSEQP3580zulVq1asnTpUvnqq69EH+Rq0ge5I0eONOt0zOn3339fChUqZLbxDwIIIIAAAggggAACCERewDUBUP3yoF8YKlasKC1btrQlNAiqk9YcP37cfLHQ/XRMRytZAVANftasWdNazauPC/Ts2VN+/PFHo5AhQwaZPHmyj4tQfQQQQACBmBIoWbKk6M9ff/0lo0aNMkP56MR7OjmSDr2iP/r5plu3blKpUqWYKgb5IoAAAggggAACCCDgWgHXTIK0Z88ec5FKlSoV6sUqUqSIWa9d3oMn632uXLmCr2bZhwXWr19vuiQqQbx48cwYoMEnrfBhGqqOAAIIIBCDAs8//7xMnz5ddAgW7f6eLFky+2zr1q2TypUrS968eUXHp9aeCiQEEEAAAQQQQAABBBCImIBrAqAjRoyQOXPmSNGiRUOt+YULF8z6lClT2tv1y4N+yUiQIIE9xpZ2edZu8yTfFDh37pw0bdpU7t+/bwB03FhtdUNCAAEEEEAgtgQyZ84s//nPf8zkSP3795eMGTPap963b58Z5kfHBtWJlK5du2ZvYwEBBBBAAAEEEEAAAQRCF3BNF3jt6p4pU6ZQa6mBzpUrV5ptefLksffRrmbaxSxr1qymNcXChQtFZ5HXcbl0nQbCtLXF45LOEh5WS4yrV6+aLmx8QXmcondsf/PNN+XUqVOmMAUKFDDdDd187axAr1bYzfX0jruLUsSUgN7H+rucezimhMk3JgX03rXSw/exn5+fvPvuu/L222+blqGjR4+WgwcPmt115nhtJdq7d29p27attGnTRtKnT29lxSsCsSpg3cc3btwwvWdi9eScDAEPCOiQI1a6fv0697GFwaujBPQzscYl+EzsqMtGYf8nEDym9vBnYt3Faqj44MGDKJvF+7+Do350lE8buwfqF4bZs2fLk08+acZy1BlYNa1atUq0ZYWV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IIAAAggggAACCCCAAAIIxFGg0I8jjp6M4/W4FAIIJJDA7Nmz7eDBgy5HHTt2TKCckRUEEEAgPQS2bt1qCxcudIWtW7eunXvuuelRcEqJAAIIJJDA3Llzbc+ePS5HHTp0yJfRhxOouGQFAQQQSDiBXbt22bx581y+atasaeeff37M80gANOaknBABBBBAAAEEEEAAAQQQQAABBBBAAAEEEkWAJvCJcifIBwIIIIAAAggggAACCCCAAAIIIIAAAgjEXIAAaMxJOSECCCCAAAIIIIAAAggggAACCCCAAAIIJIoAAdBEuRPkAwEEEEAAAQQQQAABBBBAAAEEEEAAAQRiLkAANOaknBABBBBAAAEEEEAAAQQQQAABBBBAAAEEEkWgaKJkhHwggED8BH744Qd75513bP78+bZ7926rX7++NWvWzDQSfJEiReKXEa6EAAIIJKnAoUOHrF+/flatWjV77LHHIpYiN9+38TomYqbZgAACCCSwwIwZM2z27Nm2ceNGO3HihJ199tl2ySWX2M9//vOIuV6+fLm9/fbbtn79eitTpow1adLELr/8cqtbt26BHxMxA2xAAAEEElRgx44dNn78eFu1apUdPnzYjdjevHlza9euXcQcx+v9NqvrMAp8xNvDBgRSU2DPnj1211132YYNG1wBTz/9dNu1a5dbbtOmjQ0aNMiKFy+emoWnVAgggEAMBE6ePGkPP/ywffrpp6aXvVGjRoU9a26+b+N1TNgMsxIBBBBIYAH9Ufv73//eFi5c6HJZrlw5N9+3b5+b68f8v/zlL1aqVKlMpdCP/n/961/durJly1pGRoabtN+TTz5pLVq0yLS/PsTrmFMuzAoEEEAgwQU+//xzGzhwoB05csTl9LTTTrP9+/e75U6dOln//v1PqVQVr/fb7K5DE/gEf7jIHgKxFvjTn/7kgp8tW7a0f//73/bee+/ZxIkTrV69ejZr1qyIf8jHOh+cDwEEEEhGAf3K/dRTT7ngZ3b5z833bbyOyS7vbEcAAQQSTeC5555zwc/atWvbSy+9ZJMnT3bTiy++aDVr1rRFixbZM888kynbS5Ysce+2+nF/yJAh9p///MemTp1q9957r6u1pJr8W7ZsKZBjMl2UDwgggEASCGzbts3++Mc/uuDntddea2+++aa9//77NnToUNN3s75jR48efUpJ4vV+m911CICe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" width="672" /><img src="data:image/png;base64,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" width="672" /><img src="data:image/png;base64,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wNqX5YgRI0x/jBrQpF9Lm4YJPwrodThz5kxT63PgwIFy8uRJ2bVrl7Ro0cIE64cMGUJA3Y/ng0MhgAACCCCAAAIIIIAAAjkJOKqa09SpU03ws3LlyjJhwgT55z//KUuWLJEHHnjA9NP20ksvmf4CXSGee+45E/xs0qSJzJ8/Xz7++GMzmMVVV10lq1atktdff911daYRQMCPAtrcXUfabteunR381Frd9957r6nh/eijj4r+aEHw048nhUPlKKDN37UVQb169cxy7Rt06NCh5ke3vXv35rgNMxFAAAEEEEAAAQQQQAABBPwj4JgAqI7WrDU/temqDkwRFxdnprUJe+/evU2zdq0Nao3cq7ybN282TRW16ezzzz9v99l22WWXydixY03zd615piNEkxBAwH8C+r86evRoqVOnjrj29aldU3z++eeSmpoqVapU8V+GOBICbgjo9arN3x988EF77RUrVkj9+vUvuI7thUwggAACCCCAAAIIIIAAAgj4RcAxAdC5c+eKBkG7detmvmxm1xs0aJAMHjxYYmNj7UVpaWlmumXLlheNsKy1ym688UbJzMwUDYKSEEDAPwL6/2Y1H7b6+tRmxq+99pqpYUe/iv45DxzFM4HIyEiZNGmS6GeSfo5oOnDggKnJrJ9D2uc0CQEEEEAAAQQQQAABBBBAwL8CjgmAatNDTQkJCTkK1q1bVzp37nxBAFT7BtWkzd9zShoA1fTNN9/ktJh5CCDgRQHX5u46qram7M3dGZTMi+DsyqcCnTp1MgMk6Q9sVho3bpz5vNmyZYs1i2cEEEAAAQQQQAABBBBAAAE/CDhmEKSMjAzDdfXVV8uPP/5oam2mp6eLDoxUu3Ztueuuuy4aBf7nn38222jtspySNd8aICmndXTe8OHDzXFyWv77779LVlaW6GBLwZq0rzoraT416ERCwF8CWstT+9rVbidca8fpjxY66rv1A0Uw/w/5y4rj+F9A37+tpAMcub625uf2XKZMGfnoo49E+5/Wa/ncuXMmKNqoUSPzumfPnrltynwEchXQ+5rz588H9X1FrplngWMFuCYde2pDsmAnTpwwrfhCMvNk2jEC+nltJW2parVss+bxjIC/BbR1s34fCdXv1VasQMvgaXJMAPTXX381fX5qLTIdeEL77SxevLgJTG7dulU++eQTM//WW2+1rfSNSJMV6LQX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" width="672" /></p>
</div>
<div id="kernel-density-estimation" class="section level1 page-break-before" number="3">
<h1><span class="header-section-number">3</span> Kernel Density Estimation</h1>
<p>Recall the definition of a density function
<span class="math display">\[
f(y) \equiv \frac{d}{dy} F(y) \equiv \lim\limits_{h \rightarrow 0} \frac{F(y + h) - F(y - h)}{2h} = \lim\limits_{h \rightarrow 0} \frac{F(y + h) - F(y)}{h},
\]</span>
where <span class="math inline">\(F(x)\)</span> is the cdf of the random variable <span class="math inline">\(Y\)</span>.</p>
<p><br /><br /><br /><br /></p>
<p>What if instead, we replace <span class="math inline">\(F(x + h) - F(x - h)\)</span>?</p>
<div class="page-break-after"></div>
<p>This will weight all points within <span class="math inline">\(h\)</span> of <span class="math inline">\(x\)</span> equally. A univariate <em>kernel density estimator</em> will allow a more flexible weighting scheme.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>Typically, kernel functions are positive everywhere and symmetric about zero.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,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l0EAAQQQQAABBBBAAAEEEEAg1QJbt24VTXI6yU99hsSTTz5pplQrL/lZOu7OnTvL7NmzTa/POnXqmN07duyQAQMGmLJKH89rBBBAAIHkCJAATY4zV0EAAQQQQAABBBBAAAEEEPCgwJYtW0SHuOvDjHTRadT0mRL6IKOyplKrqBq33nqrrFq1yswFqsfqtGr6LIl33nmnolPZjwACCCCQAAESoAlApUgEEEAAAQQQQAABBBBAAAHvC+izHnJyctwHHekDjpYvX256bMYa/WWXXWbK6tWrlylK5wodN26crF27NtaiOR8BBBBAIEoBEqBRgnE4AggggAACCCCAAAIIIICA/wWOHTsmY8aMkb1795rKXHrppbJ48WJp27Zt3CrXuHFj84Ckvn37mjKPHz8uY8eOdXubxu1CFIQAAgggUK4ACdByediJAAIIIIAAAggggAACCCAQNIHCwkK56aabZNOmTaZqLVu2lHnz5skFF1wQ96rWrVtXZs2aJV27djVl//vf/5arr75aTp48GfdrUSACCCCAQGQBEqCRXdiKAAIIIIAAAggggAACCCAQUIHvf//7JuGp1dOnuGuCsk2bNgmrbYMGDcw1WrVqZa7xwQcfyO23356w61EwAggggEBJARKgJT14hQACCCCAAAIIIIAAAgggEGCBGTNmmCe8axXT0tJk0qRJcsUVVyS8xtq7dOrUqVKzZk1zrcmTJ8tzzz2X8OtyAQQQQAABERKg3AUIIIAAAggggAACCCCAAAKhENi3b1+JnpcPPfSQjB8/Pml179mzp/z2t791r/ed73xH3n//ffc1KwgggAACiREgAZoYV0pFAAEEEEAAAQQQQAABBBDwkEBxcbFJfh46dMhENXToUHn00UeTHqEOfb/tttvMdc+ePStf+MIXJD8/P+lxcEEEEEAgTAIkQMPU2tQVAQQQQAABBBBAAAEEEAipwPPPP+/O+6lzcv7tb3+TatVS85H417/+tfu0+Q0bNsgjjzwS0lah2ggggEByBFLzbp+cunEVBBBAAAEEEEAAAQQQQAABBGTv3r3y4IMPuhI6DN15IJG7MYkr+uCll19+2U3A/vKXv5TVq1cnMQIuhQACCIRLgARouNqb2iKAAAIIIIAAAggggAACoRP4wQ9+ICdOnDD1vu666+Szn/1syg369esn9913n4mjsLBQ7r77bikoKEh5XASAAAIIBFGABGgQW5U6IYAAAggggAACCCCAAAIIGIHp06e7Q9/r169f4iFEqSZ67LHH5JJLLjFh6MOQnn322VSHxPURQACBQAqQAA1ks1IpBBBAAAEEEEAAAQQQQACB06dPlxj6/pOf/ESaN2/uGZisrKwSCVl9KNP+/fs9Ex+BIIAAAkERIAEalJakHggggAACCCCAAAIIIIAAAiUEfvazn8mePXvMtp49e5ph5iUO8MCL0aNHy4033mgiycvLK5Gw9UB4hIAAAggEQoAEaCCakUoggAACCCCAAAIIIIAAAgjYAvrgo5///Ofupueee8596JC70SMrTz31lGRnZ5to9On0a9as8UhkhIEAAggEQ4AEaDDakVoggAACCCCAAAIIIIAAAghYAvrgo1OnTpkt2sOyT58+1l5vrbZu3Vruv/9+E1RxcbF861vf8laARIMAAgj4XIAEqM8bkPARQAABBBBAAAEEEEAAAQRKCqxbt060J6UuOs/m9773vZIHePDVAw88IC1btjSRLV26VGbMmOHBKAkJAQQQ8KcACVB/thtRI4AAAggggAACCCCAAAIIlCGgCc+ioiKz92tf+5q0aNGijCO9s1mHwP/oRz9yA7Lr4G5kBQEEEECgSgIkQKvExkkIIIAAAggggAACCCCAAAJeFFi2bJnMmjXLhNaoUSO57777vBhmxJhuv/126dixo9m3YcMGeeWVVyIex0YEEEAAgegESIBG58XRCCCAAAIIIIAAAggggAACHhZ46KGH3Oi0F2XdunXd115fqV69ujz22GNumI8++qgUFBS4r1lBAAEEEKiaAAnQqrlxFgIIIIAAAggggAACCCCAgMcEFi1aJPqliw57v+eee8y6n/65/vrr5corrzQhb9++XV5++WU/hU+sCCCAgCcFSIB6slkICgEEEEAAAQQQQAABBBBAIFqB0nNo6gOQ/LakpaWVmAt04sSJ9AL1WyMSLwIIeE6ABKjnmoSAEEAAAQQQQAABBBBAAAEEohV45513SvT+vOuuu6ItwjPHX3311dKjRw8Tj/YCffXVVz0TG4EggAACfhQgAerHViNmBBBAAAEEEEAAAQQQQACBEgJPPPGE+/qBBx6QmjVruq/9uPLDH/7QDfsnP/mJFBcXu69ZQQABBBCIToAEaHReHI0AAggggAACCCCAAAIIIOAxgbVr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W31igV5yySU2Fmomtkd1FgEREAERyD8CeBF8+eWXtgK8V6pWrZp/lcmHM9977702HmbFihVtzG2sI2MR4jni+j5u3DiryItkTQnn0047zWb/jqX8IO+L9SNxzW+++WZDZvlskZIlS5pzzjnHNveXX34x06dPz5amq50iIAL/EpACVLeBCIiACIiAL4F27dqZXr16GWc9cfLJJxusQYm5lY1CDKn58+d7HWgy9w4fPtyL6ZWNTNRmERABERCB2AmEWn82b9489gIy/AgUmCNGjDALFy40Rx99dFytITRNs2bNIh7LZC0Z01E0Y2H7008/Rdw3KBuwrN20aZNvcwhlRP8FIbZ7Nkno/RL6G8wmBmqrCGQrASlAs/XKq90iIAIiEAWBJ5980jz11FPengcffLB1+S5VqpS3LhsXDjzwQDNt2jRTrlw5r/lTpkwxPXv29P7XggiIgAiIgAhEIsCkootBiCIw29zfHZf99tvPkIU9WYLHyiGHHGKLP+CAA5J1moSXi4Ly8ccfj7lc4oPi5l2/fn2zfv36iMeTyPLuu+82TZs2NSSSyiYhYaezNp48ebL5448/sqn5aqsIZDUBKUCz+vKr8SIgAiIQmQDJjdq3b+/tgOUjsbpwH5IYw6Bt1apVnjs8TB588EFzxx13CI8IiIAIiIAI+BKYNWuWZ4145plnGt6xksQTKFOmjHnnnXcMSq/XXnvN8H+6y+LFi03Dhg1N586dzQMPPBB1dVHkkVAK5fonn3ySqwK1d+/eBgvIvffOLpUAinDixyLbtm2z90XUkLWjCIhARhPIrqddRl8qVV4EREAEUkegT58+pmvXrt4Jb7zxRrN69WpTuHBhb50W/o0j8++ggUFGjx49PByPPfaYufXWW73/tSACIiACIiACOQmMHTvWW5WN7u9e43NZ+Pzzz63HRS67+W4uX768ef755w3JGzNByG6/ZcsWW1W8TXbu3BlVtYsWLWreeusta/HapEkT89BDD+V6XLYpPx2Q0N9c6G/Rbde3CIhAMAkUCGaz1CoREAEREIF4CWARQDZWJyjzBg4caHDRk4QnwCCjSJEi1p2MPYYMGWJja/EtEQEREAEREIFQAtu3bzcTJkywq/AmwGU5qIKbdfXq1b1s7bG0c/ny5ebss882mzdvNigFL7roolgOz9h96VP8/fffZsaMGTZJz/777x91W1ycdiyKXbbzqA/Ooh1J4kloBJJ7zpw506xdu9aULl06iwioqSKQnQRkAZqd112tFgEREIGwBB555JHdlJ9dunSxsaGk/AyLa7eVZFMlbICTJ554wtx2223uX32LgAiIgAiIgCUQauHXoEGDpMbAzE/kKD/xKCHpzEsvvRRzVZiQ/fnnn82ff/5pM5a7ZIwxF5SBB8Bt3rx5cVmtklBq3333zcBWp67K8Ln66qvtCVE2u3i8qauBziQCIpAfBKQAzQ/qOqcIiIAIpCEBgu2jxHOCC3yoQs+t13dkAiiMBwwY4O0wePBgc+edd3r/a0EEREAEREAEcMd20qJFC7cYqG+USl988YVtE8srV66MuX3PPfecwVKvYsWKNgGjn7t2EJWjLlFPzOASdACKepTXf/31V4JKTK9irr32Wq9Cob9Jb6UWREAEAkdACtDAXVI1SAREQARiJ0AsJILtO2H50Ucfdf/qOwYCt99+u+nXr593BMtnnXWW978WREAEREAEspfAunXrzNtvv20BlChRwlx88cWBhLHPPvsYMpJfccUV5v77798tVna0DS5YsKAhSzcZ0f3ck6dPn25OPfVUA9ugy4gRI2xYomS3E4tdQjNgGXn99dfbxErJPmeqy69Zs6Y57rjj7GmXLVtmPv3001RXQecTARFIMQEpQFMMXKcTAREQgXQjQKZ3soA6ufnmmw2JfCTxEyATfGjygdmzZ5tGjRrFX6COFAEREAERCAQB3rdYRCK44BIDNKiCmzGKtPvuuy/uJhL/slSpUhGPnz9/viHhz5IlS0zdunVtLMeIO2f4hkGDBpk2bdoYJlqHDx8ed2s++OADL8lSpEL++ecfT+m5adMms2vXrki7ZvT66667zqv/6NGjvWUtiIAIBJOAFKDBvK5qlQiIgAhEReCNN94wTz/9tLfvMcccY4YOHer9r4X4CZAZvnbt2l4BU6ZMMbjzSURABERABLKXwJgxY7zGhypfvJUBW/BzW09EUwsXLmyTEFJW2bJlAxtPlfZ9/fXXNsEiy8QHjUfIEl+/fn07Kbtjx46IRaCcR8mKFSiu8LEkYopYaBpuwA3exbkPnZxIw6qqSiIgAgkgIAVoAiCqCBEQARHIRAJYTVx11VXeDD8ZQ4nXlezBSiayirfOCxYsMNWqVfMOv+mmm+xAwluhBREQAREQgawhgJst1nT16tUzZ555psEFV5I3AmQ9RxmIqz3u8rjNB1WGDBliUJrjuTNq1KiYm/n777/bmJ7bt283eKb06tXLt4xWrVrZMAZBTqhUrlw5+3sEBJngXXgKXzDaKAIikLEEpADN2EuniouACIhA/ASIc9SwYUNDJxghyQCWBQUKFIi/UB0ZlgADXhdoH7fHa665xsydOzfsvlopAiIgAiIQXAIorb777jsb0/Kiiy4KbkNjaBnvxW+++SaGI/bclSRJr7zyiilatOieGwO0BkvFkSNHmieeeMKzWoyleQceeKANSUDYhXPPPTeuuKyxnC9T9iXGqZN4FMvuWH2LgAikPwEpQNP/GqmGIiACIpBQAgy+LrzwQrN582Zbbq1atcyECRMCHYcsoQBjLAyLWgYsLtEFLmfEA1Ww/RhBancREAERyGACxFB08bZ5LwQl+/tXX31lFi1aFPeVadu2ralRo4bBK0WSO4G8eumcd955ZubMmWbq1KmBVxjnTvO/e1x++eVeGAWsiLHSloiACASTgBSgwbyuapUIiIAIhCVApw7l508//WS3V6pUyRAHtEiRImH318rEEMCyFusUFxP0t99+M1j/fP/994k5gUoRAREQARFIawK8azds2GDriPXdEUcckdb1jaZy69evt32Ks88+2/YlojkmdJ+BAwcaspozIUvf5Oeffw7drOUkETjjjDM06R3CFsthQiggO3futJnvQzZrUQREIEAEpAAN0MVUU0RABETAjwCduksvvdTG+WS/MmXKmOnTp5uDDz7Y7zBtSxABEjUwAEbpjPz444/WKhRlqEQEREAERCDYBPAEcEJsxSBIt27dzOrVq822bdtMly5dYs4U3rx5cy8O6qOPPmpKliwZBCxZ04YlS5bY6x+EBof+JkN/q0Fom9ogAiLwPwJSgP6PhZZEQAREILAE/vOf/xgsNFzWUOJAvfnmm4bER5LUEShRooQhA2vp0qXtST/77DNzzjnn2MFj6mqhM4mACIiACKSSwLp16+w7l3MWL17cXHbZZak8fdLONXjwYHP++eebQw45xE7wxZos59BDDzXvvvuuGTt2rGnXrp1vPceNG2e2bt3qu482GrN06VJDXNVky7Rp00zdunWtN8uvv/6a7NMlvXzaUqFCBXuexYsXK0xR0onrBCKQPwSkAM0f7jqrCIiACKSUQJ06dQwZyRHcsSdO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4k/gggsuMHPmzDGVK1e2sbAPOugg/wO0NSYC9CmwSCYWLX1GFPSxyueff27jYqKoZlIWd3o/eeihh+y1PPDAA/12S+ttbdu29UISYUFLUi+JCIhAZhOQAjSzr59qLwIikOUE7rnnHjN16lRLAYsJYnURvF2S+QRINkESDeKnISi2b7755sxvmFogAiIgAgEmMHv2bIOyCKlataqNhRjg5iasaaeddpp1zUYJKkk8geLFi5v33nvPjBs3Li6LTCw/cQtHuEahXirharv33nsbPpksxx57rA0bQBvWr19vcOeXiIAIZDaBzH4qZTZ71V4EREAE8kQAdyYSHzkZNWqUqVGjhvtX3wEgUK1aNeu2RiZdhGus8AYBuLBqggiIQGAJELfZSSZZf/7111+u2jF/ky0ed+cVK1bEfGzoAZmuMAttSzou5zUUA27gd999t1mwYIEpX758OjYx4XUK/Q2H/rYTfiIVKAIikBICUoCmBLNOIgIiIAKJJfDJJ5+YVq1aeYWSAMnNzHsrtRAIAvXq1TMDBw702tKlSxcza9Ys738tiIAIiIAIpAcBYjWTARs54IADbHzu9KiZfy2I04j3CF4Hscrff/9trr76ajNt2jRTs2ZNM3PmzFiL0P4ZQoBEVr17986qGK2NGjXyrF3nzZtnPv300wy5WqqmCIhAOAJSgIajonUiIAIikMYEyJZ62WWXeRk2GzRoYB544IE0rrGqllcC7dq1M61bt7bFYKVz1VVXmW+//Tavxep4ERABERCBBBIYNmyYcZaUJCdECZrusnbtWhtjetWqVTbGIy78sQhK36+++soeQlzyMmXKxHK49hWBtCZAbP3Q8ENDhw5N6/qqciIgAv4EpAD156OtIiACIpBWBJylxerVq229sNgYO3ZsxsdZSivIaVoZXK9q1apla7dx40bTuHFjs3379jStraolAiIgAtlFgAQpodmx27dvnxEAyAzuYk0T2xErzlikbNmyZvHixebcc881zz//vI0PGcvx2jf7CHz00UemTp06Zt26dRnR+DZt2pj99tvP1pU+9+bNmzOi3qqkCIjAngSkAN2TidaIgAiIQNoSoMM4Y8YMWz8ya06aNMkUK1YsbeuriiWOAJ1vAvCXLl3aFrp06VJz0kknJe4EKkkEREAERCBuAsTldgqds88+25A0JhOkXLlyNoHiTTfdZPsUhQoVirnaBx98sO2bXHrppb7HDh8+3FqbbtmyxXc/bUw9gblz5xoSayZbpkyZYhODkbST0E2ZkFm9VKlSXpiprVu3mueeey7ZmFS+CIhAkghIAZoksCpWBERABBJN4LbbbtstPteYMWNMpUqVEn0alZfGBHAtRAm6zz772FqScAJLUIkIiIAIiED+EghNUNexY8f8rUyMZy9cuLDBfR9laLJk0aJFBqtYYqRiZUo4H0l6EMCt+5xzzrHxPUeOHBl3pQinkJtnCskdixQpYs+BJeWGDRviPl8qDwz9TcOLcA8SERCBzCMgBWjmXTPVWAREIAsJEHQ9NPskiXFys7TIQkxZ0eTatWubpk2bem3FCvjdd9/1/teCCIiACIhAagmg3OODHHXUUYbEKZLdCXz//ffe5F316tVNiRIldt9B/+UbgW3btnmxa1GA/vPPPzHXhczwJ598smnbtq3vsfw+xo8fb2OZk3wrU2LGEoLo1FNPtW0jXi6WrBIREIHMIyAFaOZdM9VYBEQgywhs2rTJJj1yiRVwgZbCK8tughzNHTdunM3Y61aTgZfBpUQEREAERCD1BAYOHOidtEOHDorL7dH43wLuzu+9955VDuMKL0kfAl27drUTqzfccIMNZbDXXnvFVLlffvnFnH/++TYEBHFgn3rqKd/jiRf70ksvmaJFi/rul24b8cRyMmjQILeobxEQgQwiIAVoBl0sVVUERCD7COBi06xZM8NsM3LccceZL774QoOr7LsV9mjxsmXLvGQVuJA1adLE7NixY4/9tEIEREAERCB5BH788Ufz6quv2hOg0GndunXyTpbhJRO3evLkyQaXe0l6ESC5z4gRlSWpyAAAQABJREFUI8z+++8fc8WIAdu/f397HFagF198ccxlZMIBV111lReHfdasWebjjz/OhGqrjiIgAiEEpAANgaFFERABEUg3Avfee6956623bLUYWBE7S0mP0u0q5U99ChYsaOOBEpwfIQtvu3bt8qcyOqsIiIAIZCmBIUOGeO7DLVu2NMWLF09bEr///nvcdVu+fLk55ZRTzOeffx53GTowfQkUKFAgT5W7+eabbXIgrHyTGUs2T5XM48H77rvvbv2sxx9/PI8l6nAREIFUE5ACNNXEdT4REAERiJIAys4+ffp4e48ePTpjssp6ldZCUgkcfvjhhszDdMoRYneFxopN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6623TNmyZdO+3plaQXcP6xmcqVcwu+sdGucxm+7hb775xpx55pmG9mN1huVjqVKl8vVmWL9+vY3fHGuWd1dpQvFMnDjR4AFw4oknutWB/9YzOH0v8YoVKwz383777Ze+lYyyZoQBIF4pfX+EeKD8n1fJ1mdwXrnp+PQh4O7hvIzhdu7caWMB8x676qqr4mpc7FM1cZ1GB0UiwIO+UKFCkTZrvQgklMDWrVvNvvvuaz8JLViFRSRAspm2bdt6ys8KFSpYV7qiRYtGPEYb9iQAR156CPdwEDrJe7YytWuwtMC186OPPjK//PKLadWqlXn77bdtYq7U1iQ7zvb333/bGGm40GryIzuueZBa+eeff3pWkDx/47H2ykQejz32mFV+Undifx511FH52gzegzfccINBMYsC86yzzoqpPiRddFZ2l112mVm6dGnWxDMlhiv3MeMuGQLEdNskfefq1asn/RypOgH3V6dOnYyz/uzbt6+ZOnVqnk+/fft271nEZExelEh5rowKEIE4CBAnmImovOi+3H2fl2e4FKBxXLxEHOIuGoGjY42Xkojzq4zsJIAClMG3lG+pu/5Y2c2dO9eekN86naAjjzwydRUIyJl4aToFKINvPTfzfmFhSIyqGjVq2MQDn332mXFWoe4dlfezqARHgME39zHJqKTAd1T0nSkEtmzZ4ilAGbzkZQCTKW1etmyZee2112x1SXCCQiO/3z241zJphdx8881m1apVMV2Ls88+21StWtXwvCeTfcWKFW1Z2fCHPjAKUK6h3nHBvOJr1qyxFtr5/XwizBXx1Ul6On/+fGs57jLYx0veKfA5nueRJlLjJanj8osAFqAYtOTlPerGgnl5hisGaH7dATqvCIhA4Ancf//9nqUFM1YvvviiqVSpUuDbrQZmDgFi2U2aNMlLKIBbJB13iQiIgAhkOwGSHbnQK2R3Jk5hfgsxnM844wzrCfHSSy/FpPyk7rgZL1iwwIbgchZqkdr06aefekrvSPtovQjkRsC5gue2X163z549207oYiGd34KBU48ePbxqhD5LvJVaEAERyBcCUoDmC3adVAREIOgEcJvr1auX10xcYC6++GLvfy2IQLoQOO2008zw4cO96gwYMMDcdttt3v9aEAEREIFsI4AyhbjICIrP0MQm+cni0EMPNTNnzrQZt+vWrRtXVbAeY6LLz4KG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LQosOzCr4/4Wy1MUAQIECBBoXWDXrl3ld7/7XVPuSSedVNatW9f6NhRIgAABAoMFtm/fXnbs2NG8eMYZZ5Tjjz9+cEZLCRAgQKB1gXvuuac8/vjjTbnnnXdeWbVqVevbUCCBpSAgALoUjrJ9JECAAAECBAgQIECAAAECBAgQILBEBXSBX6IH3m4TIECAAAECBAgQIECAAAECBAgQWAoCAqBL4SjbRwIECBAgQIAAAQIECBAgQIAAAQJLVEAAdIkeeLtNgAABAgQIECBAgAABAgQIECBAYCkICIAuhaNsHwkQIECAAAECBAgQIECAAAECBAgsUYEVS3S/7TYBAgQITKDAnXfeWf7whz9MWfNjjz22XHbZZVO+7gUCBAgQGF/g+eefLz/60Y/KvffeW5588slyyimnlNNPP71ceOGF5bDDDhu/IDkJECBAYFoCzzzzTNm6devQdd7//veXN7zhDUPzeJEAgf8JCID+z8IzAgQIEOi4wE9/+tNy3333TVnLk08+WQB0Sh0vECBAYHyB3bt3l09+8pPlkUceaVZ6xSteUW6//fbm8atf/apcc801ZeXKleMXKCcBAgQIjC3w0EMPNTeghq2QG1ICoMOEvEbgpQICoC/18D8CBAgQ6LDA9u3bm9pt2rSprFq16pCaHnXUUYcss4AAAQIEpi/wxS9+sQl+nn322eXqq68ua9euLf/4xz/KZz/72bJt27byta99rVx11VXTL9gaBAgQIDBSoF7znnnmmeU973nPwPxplS8RIDC+gADo+FZyEiBAgMACCuzatav85z//Ka985SvL+vXrF7AmNk2AAIHFLfCnP/2p3H333WX16tXl2muvLUcccUSzw695zWvK9ddfXy655JJy2223lY0bNxY3nhb3e8HeESCwMAI1AJrg50UXXbQwlbBVAotMwCRIi+yA2h0CBAgsVoF6Ibhu3brFuov2iwABAp0QuOuuu5p6vPvd7z4Y/KwVS1f4t73tbWXPnj1NELQu95cAAQIE2hNIF/gk173tmSqJgACo9wABAgQITIRAfwB079695YknnpiIuqskAQIEJknggQceaKqb7u+DUgKgScMmpRu0nmUECBAgMFog17gPP/xwWbFiRcn49knpBZWJ6SQCBGYuoAv8zO2sSYAAAQLzKFADoLko3Lx5c7n//vvLvn37mu6XZ511Vsm4oOkeLxEgQIDA7AQy1mfSMcccM7CgurxOkDQwk4UECBAgMCOBnTt3lhdeeKG87nWvK7fcckv58Y9/XB5//PGyfPnyZtlHPvKRcsEFF8yobCsRWMoCWoAu5aNv3wkQIDBBArUr0M0339wEP0899dSmW9Bzzz1X7rjjjvLRj3601DwTtFuqSoAAgc4JPP30002daqCzv4JHH310s6jm63/d/wkQIEBg5gL1pv/f/va3ctNNN5Vly5aVTIb08pe/vPz1r38tmaTuuuuum/kGrElgiQpoAbpED7zdJkCAwCQJ5Ef2o48+2lT5fe97X/nUpz7VTM6RBVn++c9/vmTSji1btpRvfvObTZehSdo/dSVAgEBXBF588cWSG0tJU01wtGbNmuZ13TEbBv8QIECgVYF6Qz/n4Fzbnn766U35+/fvb1qD3nDDDeVnP/tZefvb317OPffcVretMAKLWUAAdDEfXftGgACBCRF48sknmwk1+qt75JFHNj/AMxNxugD961//ai4Ccye8ple/+tXlC1/4QrnssstK7phn5uJzzjmnvuwvAQIECExDIF0sc8599tlnpxxvrgY+V65cOY2SZSVAgACBcQQ2bNhQ3vve95a1a9eWXOfWlOvfSy65pGkFmm7x3/ve9wRAK46/BMYQEAAdA0kWAgQIEJhbgauvvrr8/ve/P2QjF198cbnyyiubMY9OOOGEksegdPzxx5c3v/nN5d57720GjRcAHaRkGQECBMYTOPbYY0vG93zqqacGrlCXv+xlLxv4uoUECBAgMHOBtPx84xvfOGUB559/ftMS9C9/+UtJq/3cuJIIEBgt4JMy2kgOAgQIEJhjgbQiWrVq1SGPww8/fOwtH3fccU3eDBIvESBAgMDMBRIATaqBzv6SMhtxUsajkwgQIEBgfgVy4z9pz549xVjM82tva5MtoAXoZB8/tSdAgMCiELj++uuH7seDDz5YfvOb35R0iV+/fv3AvLt27WqWv/a1rx34uoUECBAgMJ5AvaH08MMPN2PM9a+V5UnDWij1r+P/BAgQIDCewK233trM+n7hhReWE0888ZCV/vnPfzbLMiHdVGM1H7KSBQQIFC1AvQkIECBAoPMCGSM0s2DeeOONZefOnYfU94knnigPPPBAs/y000475HULCBAgQGB8gYw9l/SLX/zikJXS3fKOO+5olteJOQ7JZAEBAgQIzFgg597vf//75bvf/e7AMn75y182y13zDuSxkMCUAgKgU9J4gQABAgS6IpAf2cccc0zJ7Jff+c53yt69ew9WLbMVf+lLX2om7HjHO95RTj311IOveUKAAAEC0xfIzMJpdZSJ5W677baXFJAf5Rlq5PWvf305++yzX/Ka/xAgQIDA7AXOO++8ppDcbNqxY8dLCrzvvvtKWogmXX755S95zX8IEBgusOzAj8n9w7N4lQABAgQILLxAJjjKhEj52sq4cxdccEE57LDDyrZt28rf//73ctJJJ5Uvf/nLpY6LtPA1VgMCBAhMrkDOrZ/73OfKvn37Sn6Mn3LKKeWPf/xj+fWvf10yPvMNN9xQ3vKWt0zuDqo5AQIEOiqQ8+7mzZvL/fff39TwzDPPLHk89NBD5c4772yWfeITnygf+tCHOroHqkWgmwICoN08LmpFgAABAgME0s39q1/9avnzn/988NXVq1eXd73rXU1wNGOESgQIECDQjkB+fG/ZsqU89thjBwtMy9D8MH/rW996cJknBAgQINCuQHo4pcX9Lbfc0kx2VEs/4YQTyqZNmwaOz1zz+EuAwGABAdDBLpYSIECAQIcF/v3vf5dHHnmkGfg9F4LLlxvRpcOHS9UIEJhwgXR5zzk3kyO96lWvcs6d8OOp+gQITI5Ahn169NFHy+7du8vJJ59c1qxZMzmVV1MCHRMQAO3YAVEdAgQIECBAgAABAgQIECBAgAABAgTaE9Bkpj1LJREgQIAAAQIECBAgQIAAAQIECBAg0DEBAdCOHRDVIUCAAAECBAgQIECAAAECBAgQIECgPQEB0PYslUSAAAECBAgQIECAAAECBAgQIECAQMcEBEA7dkBUhwABAgQIECBAgAABAgQIECBAgACB9gQEQNuzVBIBAgQIECBAgAABAgQIECBAgAABAh0TEADt2AFRHQIECBAgQIAAAQIECBAgQIAAAQIE2hMQAG3PUkkECBAgQIAAAQIECBAgQIAAAQIECHRMQAC0YwdEdQgQIECAAAECBAgQIECAAAECBAgQaE9AALQ9SyURIECAAAECBAgQIECAAAECBAgQINAxAQHQjh0Q1SFAgAABAgQIECBAgAABAgQIECBAoD0BAdD2LJVEgAABAgQIECBAgAABAgQIECBAgEDHBARAO3ZAVIcAAQIECBAgQIAAAQIECBAgQIAAgfYEBEDbs1QSAQIECBAgQIAAAQIECBAgQIAAAQIdExAA7dgBUR0CBAgQIECAAAECBAgQIECAAAECBNoTEABtz1JJBAgQIECAAAECBAgQIECAAAECBAh0TEAAtGMHRHUIECBAgAABAgQIECBAgAABAgQIEGhPQAC0PUslESBAgAABAgQIECBAgAABAgQIECDQMQEB0I4dENUhQIAAAQIECBAgQIAAAQIECBAgQKA9AQHQ9iyVRIAAAQIECBAgQIAAAQIECBAgQIBAxwQEQDt2QFSHAAECBAgQIECAAAECBAgQIECAAIH2BARA27NUEgECBAgQIECAAAECBAgQIECAAAECHRMQAO3YAVEdAgQIECBAgAABAgQIECBAgAABAgTaExAAbc9SSQQIECBAgAABAgQIECBAgAABAgQIdExAALRjB0R1CBAgQIAAAQIECBAgQIAAAQIECBBoT0AAtD1LJREgQIAAAQIECBAgQIAAAQIECBAg0DEBAdCOHRDVIUCAAAECBAgQIECAAAECBAgQIECgPQEB0PYslUSAAAECBAgQIECAAAECBAgQIECAQMcEBEA7dkBUhwABAgQIECBAgAABAgQIECBAgACB9gQEQNuzVBIBAgQIECBAgAABAgQIECBAgAABAh0TEADt2AFRHQIECBAgQIAAAQIECBAgQIAAAQIE2hMQAG3PUkkECBAgQIAAAQIECBAgQIAAAQIECHRMQAC0YwdEdQgQIECAAAECBAgQIECAAAECBAgQaE9AALQ9SyURIECAAAECBAgQIECAAAECBAgQINAxAQHQjh0Q1SFAgAABAgQIECBAgAABAgQIECBAoD0BAdD2LJVEgAABAgQIECBAgAABAgQIECBAgEDHBARAO3ZAVIcAAQIECBAgQIAAAQIECBAgQIAAgfYEBEDbs1QSAQIECBAgQIAAAQIECBAgQIAAAQIdExAA7dgBUR0CBAgQIECAAAECBAgQIECAAAECBNoTEABtz1JJBAgQIECAAAECBAgQIECAAAECBAh0TEAAtGMHRHUIECBAgAABAgQIECBAgAABAgQIEGhPQAC0PUslESBAgAABAgQIECBAgAABAgQIECDQMQEB0I4dENUhQIAAAQIECBAgQIAAAQIECBAgQKA9AQHQ9iyVRIAAAQIECBAgQIAAAQIECBAgQIBAxwQEQDt2QFSHAAECBAgQIECAAAECBAgQIECAAIH2BARA27NUEgECBAgQIECAAAECBAgQIECAAAECHRMQAO3YAVEdAgQIECBAgAABAgQIECBAgAABAgTaExAAbc9SSQQIECBAgAABAgQIECBAgAABAgQIdExAALRjB0R1CBAgQIAAAQIECBAgQIAAAQIECBBoT0AAtD1LJREgQIAAAQIECBAgQIAAAQIECBAg0DEBAdCOHRDVIUCAAAECBAgQIECAAAECBAgQIECgPQEB0PYslUSAAAECBAgQIECAAAECBAgQIECAQMcEBEA7dkBUhwABAgQIECBAgAABAgQIECBAgACB9gT+DwtX+lpLpxvuAAAAAElFTkSuQmCC" width="672" /></p>
<div id="choice-of-bandwidth" class="section level2 page-break-before" number="3.1">
<h2><span class="header-section-number">3.1</span> Choice of Bandwidth</h2>
<p>The bandwidth parameter controls the smoothness of the density estimate.</p>
<p><br /></p>
<p>The tradeoff that results from choosing the bandwidth + kernel can be quantified through a measure of accuracy of <span class="math inline">\(\hat{f}\)</span>, such as MISE.</p>
<p><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,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6nF1adeuXeaSxYsXEwCtDstir2ug25U08E2qXuCrr76SW265xVz4u9/9TqZNm1b9TV5eMWzYMNEHCQEEEEAAAQRCV4AAaOj2PS1HAAEEEHCIgAZAXalBgwauQ8t91YCeTv/WqcHdu3e33G7oup7qgQMHjJuu2emLAKiuV6oPV/I2iBsZGSka9NXRvToyjmQvgQsuuED0vaiBUAKg3vUd09S9c+IqBBBAAAEEEKidAAHQ2rlxFwIIIIAAApYRaNiwoaxevdpssGPlAKiug6jBT02ea3paBdJzTU4dpRrspFP+dbr/22+/HeyqUH4NBV544YUa3sHlOnp9ypQpooHQPn36WApkw4YNMnfuXMnKypKRI0fKlVdeaan6URkEEEAAAQQQqF6AAGj1RlyBAAIIIICApQXq169vi02QdFSlTv3WoJ5nsNEquAkJCcZRR15qXYOdGjdubKqg67qSnCuwfv16ueqqq8x6rzfccIO89tprzm1sFS3ToKfVAp+u6m7fvt09JV+XtCAA6pLhKwIIIIAAAvYRIABqn76ipggggAACCNhaIC0tTfRRl6QbCOmUf52urg/dLEjP6YhSHbWpU8Z1lKmONtWHBjM12KpBYn1oYNMViI2JiTHBWFd99HUdTUtCIJAC+j3qWnohJyfnf9l7D3ApqnRte82ZMzOGQQUMRAFBco4CCkoSMeAoKCYMiCImTCOoGDArmBMqCqJjjoOjKEYEJIggOWcEBEH0mM7M9//ea86qqd107929d1V3VffzXlft7l1dtWqtu0J3PfWGbG46FtuiYBheoRQw4mFAuXLlst5v9zCCDeMFKhMBERABERABEYgfAQmg8dtn6rEIiIAIiIAI5D0BRMwffvjBVktHAOG9q6Ae5ODJtenydPK699572/8RpWQikA0CpK0gTyiv/nyx2dh2HLZx7bXXmocffth29f333zfdunXLerebNm1qXnrpJYMQKo/srOPXBkVABERABEQgEAISQAPBqEZEQAREQAREQATKSgAPL7yrvv32W4MnXDbyhOJByvaYnCF+Eg6PN6ibCNuXiUAYBOrUqWMF/jDazoc2/aIw14hcGMJn3759c7FpbVMEREAEREAERCAgAvo1HxBINSMCIiACIiACIpAZAcLVt2/fbjZv3my++eYbG9JeXAsIk4StO2858oniwUnoOgIlE8u4Ykt4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8RcGouJ8w4YNjT+XZbb6E9ftEPpPblQKQ23cuNFWfncefxTNQQjFG5Cq8YTMI5aS9zVX3r655Pztt9+a0047zXbhiCOOyGsB9NBDD80l6khvm3OBaw0PCii2JhMBERABERABERCB0hCQAFoaalpHBERABERABHJAgHBpZ9kSQMldOXDgQOuJ57ZNuDueigh5vA/bVq1aZcVCPMHYbj4IrnDDq5EQdxivWLHCIIBiThDlPflEySFaiAIoIjGCMSkDOAZkhUtg6dKl9sHAnnvumTGEiRMn2rQS5cqVM71797YFyDJuRCuIgAiIgAiIgAjEnkDeCaCE55EbaNasWWb79u22oio3DT179rQ3EWXZY2+//bZ55plnzI033mhzdJWlLa0rAiIgAiIgApkSwBMKARCxLBsC6KuvvmrOP/98Q85PZ4Td4/Xpz1noPgvrFUHQeX5RQCkO9vnnn5tff/3VFrNp3bp1SqGYfVq5cmVDGoFEIZRxEgZ/991323QHZfESvPPOO20bxx13XMYVynPFG/H39ttvNxUqVLDHfa76oe3mngDnR2ntnXfeMffff79dvX79+hJASwtS64mACIiACIhAzAnklQBKXqDBgwfbAgPsF34wv/vuu3aaOnWqoaom3iOlsXnz5pmRI0daLwREVpkIiIAIiIAIZJsAnphM5EYs7fdZOn1GbLzkkkvM008/7S1O8SI88vBazLa5okFsN4qV45PxQLQlXQBTOl6yfiGUHKvLly+3leBpm9QDhx12mDn66KPNHXfcYRo3bpxskynn8bvllltusSLyZZddZgXtMI+flB0pxQdXXnllKdbK7SqTJk2yHst4K/bo0cMWucptjwp764TOO8MLVCYCIiACIiACIlCYBMKPW8si15tvvtmKn+3atbOhem+++aZ54YUXTO3atc2nn35qHnjggVL1hoq71157rZd3rVSNaCUREAEREAERCIgAYiRFdTDELTwIKbDTr1+/Mm+BMHu8S/3iJ/kXeRCYC/GTATVr1sx069bNFiDJpudpaWHipYr3IqKm20/ptsU6VapUMXh74mn7hz/8wVuVSBRYnH322d7DXu/DYt4gyDkPWjjGRfwsZkiR/ojfm2eeeabp06fPLgXDIt3xHHbupptuMuedd5656qqrvFQQQXXnggsuMOQwfuSRR2xkWFDtqh0REAEREAEREIF4EcgbD9CFCxfa/D5UoMXLwd1wkFvrnnvuMSeccIIhBIZQvnSf/uK9wY8lhFQMD464hN7F6zBUb0VABERABEpLAO8mQqeZylo9GuEGAYLQbQyh7LbbbjOXX365FfNK20f/ehT2+e6777xiSvvtt5//45TvERSzVWX+q6++sl6SeG927tw5Y69Tfi+wHmP1F41KObgkH9AGHrf77LOPIYrFGb9Dxo4dax/wXnrppWbYsGFm7733dh8nfcULkTyIb7zxhunevXvSZaI087HHHrPHG8L+scceG9ixl60xulyubK80OSuz1c8obYdjk2JfGGJokEYKCiaZCIiACIiACIhAYRPIGwH0448/tnuSGw4nfrpdSyh827ZtzbRp06wIetJJJ7mPin0999xzrYcF3iaEYD333HM271qxK+lDERABERABEcgiAR7W8WAP0YVKyaUxRNQBAwaYl19+2VudXHlEUeBxGKQhCk6fPt02iTiUrgAaZB9Kaou8m04E5rW0Yfd4c5bV2xLRFy9Qcq9S/Gn16tU2NP7nn3825PUcM2aMuf76682gQYOKeIv6x8j6iKBMcTAEMAR9jg/nuRqHfrs+4snYtWtXe07mQ8EuN64wX3kognGsxsHLm77yMCKd9BYsKxMBERABERABEcg9gbwJgV+wYIGlSfh7MkMAxfDqSNfIKXrkkUeasb95WsTBYyLdcWk5ERABERCB/CFw4IEH2pyg5Ml86623Mh4Y3594R/nFT8J3KSYYtPhJ5xAMqOyNOZHR/hOhP4iWzuMUwTaXBis4kReUaJdly5aZc845xxNetm7davO1NmrUyHp45rKvQWwb8XnLli22KTxA42gnn3yyueaaa8ytt96atpj3008/2X1L2qU1a9bEcdhl6jPXLpwZXNRVmRoLceVx48bZHLw8dHrppZdC3JKaFgEREAEREAERCJpA3niAbtiwwbIhVCyZufnr1q1L9nHSeeQ/O+CAA5J+ls5MfsThmZHMXLgaT7y/+eabZItoXhkI8FSeSWzLAFGr5jUBRAZnPOzBU01WeAQIOx0yZIjBixQjgoIiO6eeeqqd5+YHTYb0NFhZvSOD7pdrDzGRKZVxzuChiJdsNsz/XQYz9lH//v3NiBEjzIcffmi7gDD6l7/8xbRv396QE71p06Ypu8Y6/Eah0NLw4cPNIYccknLZbH9AyoCHHnrI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3il+g9E3CgeRCoG8kBT6SgzJZ71hw4aZ+++/31BsKN8MD9DLLrvM5kelsJns3wR4GNSnTx9D0TRnpFjIlZGfFu9lZzfffLN7q1cREAEREAEREIEIE1ARpAjvHHVNBERABEQgNQG/F1nqpeLzyc6dO83MmTM9L7y9997bhoafcMIJ8RmEepp1As2aNbPHCXk2qUb9X//1n2fb3bp1M1RnJxcn1difeeYZM2DAgKz3MdkGW7RoYQjRJz8pXo94qP744492UQrLMOEVeuGFF5qzzz7blC9f3uAh6Wzz5s3urV5DJoAQjTcx19w6deqEvLVdmyddgksHst9++5m33nrLkLu2JCMn56uvvmoQlikqhadzUHbaaaeZESNG2ON31qxZVtSnSJ1MBERABERABEQgugT+8ys5un1Uz0RABERABEQgrwmQ74+baBeCjFfcPvvs44XB5/XgNbhSE6BqOqHghI1PmjSpiPjpGvV7qt12223eMeY+z/UrIudDDz1kqBJ/6623msqVK3tdQhyl6jaVvs8991z72ZNPPmnzLcbtwcCvv/5qVqxYYZYtW1bEk9EbbITfUJn+4osvNuPHj89JLyk0NH36dHPmmWfaQnCI+uTiLMngff755xvESh4OBGkUcLvmmmu8JuUF6qHQGxEQAREQARGILAEJoJHdNeqYCIiACIhAIRAg3B3PTxeeTHglYc147KkQSiEcAZmPkcruFA3iGEEcxBCFkhkpFVq3bm0/QlCManVxijEhKDEmQuFdn+k4oc8UvOnbt6957LHHbE5TPKSjZnjavv3222batGm2z+SHRHRu3LixTWOB92TdunXNHnvsYT0Sr732WrNkyZKoDWOX/pCuAMPj8cUXX9zl82zMoMDQ2LFjTceOHdPenP/66S8wlXYDJSzYv39/W7SLxfC8/u6770pYQx+LgAiIgAiIgAjkkoAE0FzS17ZFQAREQAQKmgDCDp6feIdhCCO77babx6Q4kYe8eJ988on1jMLTSVYYBBABEXPwikNQQ2TbsGGDoUJ2KvN7geJlWVze0FRtZGs+DwDw2OOhAILi6aefbv70pz95m+d8Oe+880ylSpVsOD+FkaJiFOk55phjTIcOHay3J8WMEDkpRJWYz3T58uVWHCWUm/Fs2bIlKsPYpR+I7c6CDoGn2BOMELaDNgoVUWDrpptuMkcffXTQzRuOVVIDIHhTvK6463XgG1eDIiACIiACIiACGROQAJoxMq0gAiIgAiIgAmUnQE47xBxX7R3hs1WrVp7X5x//+Mdiix8hnrLujh07vNyJZe+VWog6AYQ0lyvTeQ9WqVLF1KpVK2XXjz32WNO8eXP7OSHY5N6MmlGICS9Pwq2//vpr27127drZsGsEuDvvvNOrvM2HeE4/9dRT5tBDDzX16tWz4fN4j+bSSEngrEKFCtajlRB/jP3To0cPm0eT/jpjfz7xxBO2kvi8efPc7Ei9kjt269atVuTDmzUoY+wUtMJLljywQVuNGjUMAivFwMIQQOkvHtapvK+DHo/aEwEREAEREAERKBsBCaBl46e1RUAEREAERCBjAoS7I346IQsPNwp04AlKeDNWkjcRbfzud7+zy/q9Ru0M/clbAvXr1zcUgqGaussZW9JgOU78XqC33HLLLh6JJbUR9ucUqyHP54knnmi9mv3b23fffc1f//pXmz/z/fffNyeddJIt/OSWWbp0qbnuuuusyNipUyeD5+W3337rPs7a66mnnmqruJOrkpD+3Xff3RaemjNnji2WM3HiRFssZ/HixXYsV111lefdiico+zaqxngIP/d745a1rzy8cZ6xCMZxNsLt8VimeJdMBERABERABEQgmgRUBT6a+0W9EgEREAERyFMCiFZffPGF5+lJGCX5Dgl/p9qxM4ogFWf777+/6d69uxVNnRBa3PL6LD8IkIeRMPZM7S9/+Ytp0qSJwcsQAQ5Pyz59+mTaTGjL+70nqfiezDjOqWzPRIVv8pniBTp37ly7OA8PJk+ebKeLLrrIelySMqB37962qFiyNks7j3OVgkykICAMGhs4cOAuzaXKWUkoOSHzgwYNMsOGDTP33XefDakmPQFiGhPnONeHfDVSOVC8C7E6jByd2eLGsYtAzPGHpzVFyWQiIAIiIAIiIALRIyAP0OjtE/VIBERABEQgTwng7cTNsSuWQbV3wt7dzT8eUc5K8gBlOQQhPLIIl5cVBgGOmdIYxwqhwIRkE2p+/PHHe82MHDnSioWNGjWy1di9D7L4Bq9OwtyHDh1aJNQ9VRcQnC655BKDdyUC6JVXXmlIBeAMD2kKEl1wwQW2UA2hyozb/5DBLZvpKyIlYjJFm/A2LUvoPfuDwkKVK1e23cCLlIcf1apVMwsXLsy0a1lbHrGvrP3jutW1a1db3Oqoo47KWt+D3hCCPV7ZGLldZSIgAiIgAiIgAtEkIAE0mvtFvRIBERABEcgzAggGCDUuNJeqwYiffqEzUwE0zxBpOCETILycvKHnnHOO+e///k8Q0Pz58w2h5QhaeDTmwvDqJMz99ttvt+JfJn1o2rSpufvuu23f8SgcMGCA5/HZrFkzs3PnTht6Tog9xZNIH8DyeMKWxhChESoxxFCE1aCsXLlyXlP0O4p22WWXGULWEcyzfbywf998800rbkeJDcWvTj75ZOvRm25qiij1X30RAREQAREQgUIg8J9fv4UwWo1RBERABERABHJAAPGT0GNX6RlvPEIl/aG+FEVyBZHwCPULVDnosjaZhwQ47pIdV37PSXeMRnX4nCMbN240mzZtst6sCJrOeKiARyETYemIup9++qkVfV2IPV7YVOxmQnClUjjeoT179jSHH364TUXh2ivudfDgwfbhBYWNSGERlB188MH2wQgCIzlEo2iIvu5hzcyZM20qjrL2ExGZB0KuWFeq9hAauVZS4Ciswkaptl3c/CBF8OK2o89EQAREQAREQARKT0AeoKVnpzVFQAREQAREIC0CeJq5ytasgMeaC5l0DThBgf/9+T+pdo14g4gqE4EwCBBKvnLlSivAkys0ykauTERLcmsS4p7KCK9GICOsfvPmzebdd981559/vhdq7tZbsWKFefDBB+2yiI54orIOeXpdgR63LOH2Q4YMMU8//bRBbL3hhhtM+/btA83TefXVV9sCae+9916gwqobQxCveNVSmIrq50Gk3/jkk0/svoElOV2Lsz333NN+zHVRJgIiIAIiIAIiIAKZEJAHaCa0tKwIiIAIiIAIZEiAnHBr16711iJs1O+15j5weUH53y+Akl+QMFOEBoQHRBo8oMhx6HKHujb0KgKlIZDseCxNO9lYx99XvEDTMQoJHXnkkXZ69NFHrcD41ltvmQkTJtgcoq4NzqsPPvjATszjPOzcubP1DOUVoe7++++3i1Oxfdy4caZt27Zu9YJ5JcUAE0axpu+//77UY+fBUL9+/WwqATxLZ82aZVM0pGqQnK5c+/zXyFTL4i3MdROxWiYCIiACIiACIiACEkB1DIiACIiACIhASAQQL/Ewc1a3bt2U+Q0RdghPxhPU3dzj9elCkn/99Vdb8Gj16tW26ApiQZs2bYw/Z6Dbjl5FIF8J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gAIKKKCAAgoooIACCuRe4MDcH4EHoIACCihQs8DOnTvDD37wgzjS4j//+c8wZMiQMHz48HDmmWeGAw44oOb9uKICCiigQPcSuP/++8Ptt98errjiinD88cdXPPhNmzaF5cuXhz/+8Y+hqakpDBs2LEyYMCEcc8wxFbdxgQIKKKBA4wps27YtLFu2LGzevDm89NJL4fDDDw9HH310OP/888M73/nOsgfuPUtZFme2UsBR4FsJ6OYKKKBAXgT+9a9/hYsvvji8+OKLMctvf/vbwyuvvBLfjx07NsydOzf06tUrL4djPhVQQAEFOkhgw4YN4XOf+1zYs2dPuOGGG+KDs3JfzQO2hQsXxkV9+vQJu3btitMhhxwSrr322jBixIhymzlPAQUUUKBBBR577LFwzTXXhP/85z+xssVhhx0WCIju3bs3cG340pe+FE499dRmR+89SzMOP7ShgE3g2xDTXSmggAJdWWDevHkx+Dly5MiwYsWKcO+994a77rorDB48OKxatSpcf/31XTn75k0BBRRQoBME1q1bF2bNmhWDn9W+niAp1xEepF199dXhgQceCA8++GAMnHLjO2PGjLB169Zqu3CZAgoooEADCfzlL38pBD8vvPDC8OMf/zj88Ic/jK+f+tSnYlCUh2OpckY6dO9ZkoSvbS1gALStRd2fAgoo0AUFnn322fDUU0/FJ61XXXVV6NevX8zlu971rjB//vz4RHblypXh9ddf74K5N0sKKKCAAh0t8MYbb4RvfOMbMYBJlylveUv124bFixeHffv2hcmTJwdaFfTo0SP07NkzTJw4MZx33nlh9+7d4Z577unow/D7FFBAAQU6SeC+++6LQc7TTjstXHTRReGggw6KOeF16tSp4ZRTTgk7duwIrJeS9yxJwtf2EKhekmmPb3SfCiiggAIdLkDzE9K4cePCwQcfHN+nf2gK//73vz82UyQIalJAAQUUUGDKlCmxpUDv3r3DnDlzYn9tlVQIlvKQjXTGGWfst1qaR+sDmtGbFFBAAQUaX4AWBKSTTz657MHSKo30/PPPF5Z7z1Kg8E07CBgAbQdUd6mAAgp0NYHf/va3MUupoFGaPwKgpPXr15cu8rMCCiigQDcUoA82Ape33XZbOP3006sKbNy4Mdb+HDhwYDjyyCP3W3fo0KHhrW99a3j11VfDn/70p/2WO0MBBRRQ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" width="672" /></p>
<div class="page-break-after"></div>
<p>To understand bandwidth selection, let us analyze MISE. Suppose that <span class="math inline">\(K\)</span> is a symmetric, continuous probability density function with mean <span class="math inline">\(0\)</span> and variance <span class="math inline">\(0 &lt; \sigma^2_K &lt; \infty\)</span>. Let <span class="math inline">\(R(g) = \int g^2(z) dz\)</span>. Recall that</p>
<p><span class="math display">\[
\text{MISE} = \int\text{MSE}(\hat{f}(x)) dx = \qquad\qquad\qquad\qquad\qquad\qquad
\]</span></p>
<p>Now let <span class="math inline">\(h \rightarrow 0\)</span> and <span class="math inline">\(nh \rightarrow \infty\)</span> as <span class="math inline">\(n \rightarrow \infty\)</span>.</p>
<div class="page-break-after"></div>
<p>To minimize AMISE with respect to <span class="math inline">\(h\)</span>,</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>The term <span class="math inline">\(R(f&#39;&#39;)\)</span> measures the roughness of the true underlying density. In general, rougher densities are more difficult to estimate and require smaller bandwidth.</p>
<p>The term <span class="math inline">\([\sigma_K R(K)]^{4/5}\)</span> is a function of the kernel function <span class="math inline">\(K\)</span>.</p>
<div id="cross-validation" class="section level3 page-break-before" number="3.1.1">
<h3><span class="header-section-number">3.1.1</span> Cross Validation</h3>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
</div>
<div id="plug-in-methods" class="section level3" number="3.1.2">
<h3><span class="header-section-number">3.1.2</span> Plug-in Methods</h3>
<p>If the reference density <span class="math inline">\(f\)</span> is Gaussian and a Gaussian kernel <span class="math inline">\(K\)</span> is used,</p>
<p><br /><br /><br /><br /></p>
<p>Empirical estimation of <span class="math inline">\(R(f&#39;&#39;)\)</span> may be a better option.</p>
<div class="page-break-after"></div>
</div>
</div>
<div id="choice-of-kernel" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Choice of Kernel</h2>
<p>There are two choices we have to make to perform density estimation:</p>
<p><br /><br /><br /><br /></p>
<div id="epanechnikov-kernel" class="section level3" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span> Epanechnikov Kernel</h3>
<p>The <em>Epanechnikov kernel</em> results from choosing <span class="math inline">\(K\)</span> to minimize <span class="math inline">\([\sigma_K R(K)]^{4/5}\)</span>, restricted to be a symmetric density with finite moments and variance equal to <span class="math inline">\(1\)</span></p>
<div class="page-break-after"></div>
</div>
<div id="canonical-kernels" class="section level3" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span> Canonical Kernels</h3>
<p>Unfortunately a particular value of <span class="math inline">\(h\)</span> corresponds to a different amount of smoothing depending on which kernel is being used.</p>
<p>Let <span class="math inline">\(h_K\)</span> and <span class="math inline">\(h_L\)</span> denote the bandwidths that minimize AMISE when using symmetric kernel densities <span class="math inline">\(K\)</span> and <span class="math inline">\(L\)</span>. Then,</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>Suppose we rescale a kernel shape so that <span class="math inline">\(h = 1\)</span> corresponds to a bandwidth of <span class="math inline">\(\delta(K)\)</span>,</p>
</div>
</div>
<div id="bootstrapping-and-variability-plot" class="section level2 page-break-before" number="3.3">
<h2><span class="header-section-number">3.3</span> Bootstrapping and Variability Plot</h2>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,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w4YNS9rLUwQQQAABBBBAAAEEEEAAAQQQQAABBIoTuO+++8yECRMKyoQeoAWxcVEmgXvvvdfcdNNNmU7hmEcCO3fudHJq0KCBOe+88zzKlWwQCK/A4cOHTVVVlenQoUN4G0HNEfBIQO+HY8eOObm1bt3aNGrUyKOcyQaBcAqcOXPG7Nmzx7Rq1co0btw4nI2g1gh4JGDfD8quYcOGpl27dh7lTDYIhFfg4MGDRu8N3g/Bu4fV1dXmsssuK6piBECL4uPiVAL6BVpRUZHqEPs8FrDOCoDabY+LIDsEQiWg94GGrvB+CNVto7I+Ceh9oOlplLTN+8InaLINjYA+1Nr3Au+H0Nw2KuqTgH0/KHs+v/mETLahE9DvBvd7I3QNoMIZBQiAfspz4sQJ88orr5h58+YZRf379u1rhgwZYq6//nqj4FK+adWqVebll182mzdvNk2bNjWDBg0yV111lendu3farAq5ZsqUKWbatGlm27Ztzof+7t27m8svv9xcc801npaTNjMOIIAAAggggAACCCCAAAIIIIAAAgggEGABAqCf3JxDhw6Z22+/3WzdutW5VW3atDGTJk1y/s2cOdPcc889pry8POfbqEDqI4884pzfrFkzc/LkSbNgwQLz0ksvmQceeMBccskltfLK9xoFbH/4wx+ahQsXOnm1aNHCeVy9erWZPHmy+dvf/mZ+/etf1xrek285tSrKDgQQQAABBBBAAAEEEEAAAQQQQAABBEIkwLLRn9ysX/ziF07wc8SIEebNN980r7/+unnhhRdMnz59zNSpU82jjz6a8y1dunSpc74Cppqc9e2333YCqd/73veceenuvPNOs2vXrhr5FXLNb3/7Wyf4qdWvnnjiCfPWW285//74xz+abt26mUWLFpnHHnus6HJqZMATBBBAAAEEEEAAAQQQQAABBBBAAAEEQiYQ+wDoihUrzJw5c5yeklq8p2XLls4t7NKli3nooYec4e/vvPOOOXLkSE639umnnzbnzp0zt956qxk3bpypV6+eM6fKxIkTnZWqTp06ZV577bUaeeV7zfHjx50envXr1zc///nPTf/+/RP5DRgwwAm8aoeCuTrXpnzLsdfxiAACCCCAAAIIIIAAAggggAACCCCAQFgFYh8A/fDDD517N378+Fqro2oovFaZ0hB2BUGzJQUbFUxVuu6662qdbvcpMGkX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CCCAQI4CBEBzhOI0BBDILrBv377sJwXwjA0bNgSwVlQJAQQQQAABBBBAAAEEEEAAAQS8ECAA6oUieSCAgCMQxh6gqjgBUF7ACCCAAAIIIIAAAggggAACCERXgABodO8tLUOgpALV1dWhHUq+Y8cOo/qTEEAAAQQQQAABBBBAAAEEEEAgegIEQKN3T2kRAnUiENben8LSKphaDImEAAIIIIAAAggggAACCCCAAALREyAAGr17SosQqBOBsM7/abFWr15tN3lEAAEEEEAAAQQQQAABBBBAAIEICRAAjdDNpCkI1KVAmHuAym3r1q3m0KFDdUlI2QgggAACCCCAAAIIIIAAAggg4IMAAVAfUMkSgTgKhL0H6Llz58zSpUvjeOtoMwIIIIAAAggggAACCCCAAAKRFiAAGunbS+MQKJ3AgQMHSleYTyWtXLnSnD592qfcyRYBBBBAAAEEEEAAAQQQQAABBOpCgABoXahTJgIREzh69Kg5depU6Ft14sQJw1ygob+NNAABBBBAAAEEEEAAAQQQQACBGgIEQGtw8AQBBAoRiELvT9vuxYsXGw2HJyGAAAIIIIAAAggggAACCCCAQDQECIBG4z7SCgTqVODgwYN1Wr6XhWsxp40bN3qZJXkhgAACCCCAAAIIIIAAAggggEAdChAArUN8ikYgKgJRCoDqnsybNy8qt4Z2IIAAAggggAACCCCAAAIIIBB7AQKgsX8JAIBA8QJRC4Du3r3bbN26tXgYckAAAQQQQAABBBBAAAEEEEAAgToXIABa57eACiAQfoEozQFq78b8+fPtJo8IIIAAAggggAACCCCAAAIIIBBiAQKgIb55VB2BIAho5fTjx48HoSqe1kE9QPft2+dpnmSGAAIIIIAAAggggAACCCCAAAKlFygrfZGUiAACURLwcvj7nj17zKRJk8yWLVvMyZMnTcOGDc3FF19sRo4cac4777ySsy1atMh87nOfK3m5FIgAAggggAACCCCAAAIIIIAAAt4JEAD1zpKcEIilgBfD38+cOWP+9re/mY8++sicPXu2huP7779v9G/s2LHmy1/+sikrK92PrTVr1phRo0aZJk2a1KgTTxBAAAEEEEAAAQQQQAABBBBAIDwCDIEPz72ipggEUsCLHqAvvviimTJlSo3gp3p/utO0adPM//zP/xgvAq7ufDNtKzC7dOnSTKdw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QAABBBBAIDoCBfcAHT9+vLPAkYKfCobceeedZu3atWbSpEnmpptuSrs6sa5TUoDwa1/7mjOcU71F1ZNJSR/k9Tyffxp2X2jSyspKWjk4OaknygcffODsHjJkSPLhWs81J6KGpyqolGqBErVRvZB0jh3eV8g1tQrOYUepysmhKpwSIIFMAdBMQc5MxwLUvDqrir78cU/94XVF9DPWzku8YMECs379eq+LiFx+e/bsMW+88YZ56623jB2JELlGFtggDXufP39+gVd7f5nmIc73i1Dva0GOCCCAAAIIIIAAAgggECWBggOg7g+Ql112mVEgsVevXlltNHzz17/+ddoAadYMPD5BvT7VI0jBWw2TdKdnn33W7N+/35nPT4uNuNOMGTPM5MmTzcaNG927jeYyVXryyScTcynquT58P//889o0EydOdB7tf4VcY6/N57FU5eRTJ86tW4HkHl96vduUKciZqXeovT7uj1rIxa95J9XrXb3tbXr11VcJ6lmMLI/qDWq/cMtyamwOz5o1KzEKIyiN1nykJAQQQAABBBBAAAEEEEDAK4GCh8A/+OCDTiBTgUD1+tQ/BRK/+c1vmm984xumY8eOaev4wx/+0CgQunLlSqeXhyYz1TyimvfrP/7jP3Iabu7OXMPqC00atq8633333eb+++83+iCo4ekaDqhtDWO/6667ag3Fe+SRR8zOnTuda92BX/Vw1XB5te22224zV155pdHcauphquCSViS+6qqralS3kGtqZJDjk1KVk2N1OC0AApl6gGYKcmYKjgagWYGoQvPmzZ2fiQq4+ZH0s0U/o/RzRStna0Ek28Pej/KilKdWOlcvXS0qlel1HqU2p2vLjh07nN936Y7X1X59uaifT82aNaurKlAuAggggAACCCCAAAIIREig4ACohmDqn+ahe/jhh83LL79sNm3aZH784x+be+65xzn27W9/21xzzTW1gofy69evn/PPWmqouQKgX/7yl0u6CrzKHzdunNMGBUDVM8j2DlJA94477jCDBw+21cz6qA/Vjz32mJPfe++9Z9SLVEn7J0yYYGSS3CuskGuyViTFCaUqJ0XR7AqggKah0NBXd3LPAZouyKnXUaFz7rrLisO2fnb4FQDVlzP/9E//ZP74xz86lBrarak61DuUlF1AX3LpnwLV+tJLU5PELRiqKVn+/ve/m3PnzmUHK/EZGmWiuUCTR1+UuBoUhwACCCCAAAIIIIAAAhERqPfJBx9PPvls377d/OY3vzG///3va6xK3Lt3b/PLX/7SfOUrX8lI9pOf/MRZgfbee+91FkbKeLKPB9WbSnOPadEg9WJNDlbmU7R6fmpuPhF369bNNG3aNOvlhVyTNdMUJ/hRjnrrDBs2zPzqV78yN998c4pS2eW1gHohKykoaRe6yrUMrR7+zDPP1Dhd78PDhw87PZ//+7//u8Yx+6Rdu3aJqR7sPh7TC2jqCy3u5ldS7/klS5Y42Wv1efWij3PSiAL9fMvl522ykwL7PXr0MBpVYOdYTT4nSs/nzZvn9CIOapsUzNdc4aTCBfTz3E510rp1a9OoUaPCM+NKBCIgoC9+NC1Vq1atnMUKI9AkmoBAwQL2/aAM9MW6/sYnIRB3AX1G1nuD90PwXgn6nKcORvfdd5/TubCQGhY8B2hyYVqZWIFODcXU6vD9+/d3TlHvJw2Pz5YU+FSPSc0nWpdJPYDUi0qLBhUT/FQbysrKHAf1LMr1w3gh1xTiVapyCqkb15RGwH4otqWpR6g+LCvpg3K6lK5naLrz474/lwXUijFSz/KKigoni8WLFyeCocXkGddr9fpXr9C3337b+cMnyg7q/b1w4cJAN7GystIJVAS6klQOAQQQQAABBBBAAAEEQiHgWQDUtlarm3/nO99x5sB88803zec+97mUQ+Dt+TwigEDdCCTP/6lvu2zKNBSYAKhVyu1R033o56JfSb1YbrzxxkT2L774YqLHV2InG3kJaBSA5m32aIBEXmWX6uRFixaZ6urqUhVXcDlaoJCEAAIIIIAAAggggAACCBQr4HkA1FZIiwvdcMMNzkrpmiOUhAACwRJI7gHKCvD+3B9NT6DFdvxMY8eONZpuROnIkSPOnMx+lheHvNesWWPefffdSPYE1fARBUDDkNatWxeGalJHBBBAAAEEEEAAAQQQCLiAbwFQd7tZMMWtwTYCwRBI7gGaywJIqjk9QPO/fwqAKhDqV9J0Hbfccoszf5PKWLBggZk/f75fxcUmX/U+1EgGTQ8RpaTFCxUEDUPStASar4+EAAIIIIAAAggggAACCBQjUJIAaDEV5FoEEPBHILkHqDsAmm4IPCvAF3YvGjdunJgXubAcsl/Vvn17c9NNNyVO1FB4d6/exAE28hLYsmWLef3110MTMMzWuM2bN4em96dtC71ArQSPCCCAAAIIIIAAAgggUKgAAdBC5bgOgZALJPcAdQfL0vXy1OJIxS4OFnK2gquvFdr9TuPGjTMDBw50itH8jk899VQkh3D77Zic/86dO81f/vIXU1VVlXwoVM+PHz8eyrlN1RM3yvOxhupFRGURQAABBBBAAAEEEAipAAHQkN44qo1AsQKZeoCmC4Cm219sXeJwfbt27UzXrl19barmXr711ltN8+bNnXLU2++1117ztcy4ZL5v3z7z6quvhnqBqSlTphgFQcOWNAx+x44dYas29UUAAQQQQAABBBBAAIEACRAADdDNoCoIlErg7NmztQIhdgh8WVlZIoCWXB8CoMki+T0fMmRIfhcUcLaCn1/72teMgqFKH330kZkzZ04BOXFJssDBgwedIKgWmgpb2rRpk9mwYUPYqp2o76pVqxLbbCCAAAIIIIAAAggggAAC+QoQAM1XjPMRiICAhvIqCGqTFnlRLyslBTlt8Mwet48EQK1EYY89e/Y0mkbA79S/f39zww03JIp54YUXjOayJBUvUFlZaf7617+aMAVBz5w54wTCi2993eWgeUBPnz5ddxWgZAQQQAABBBBAAAEEEAi1AAHQUN8+Ko9AYQLJ83+qZ5tN6RZA0nECoFapsEcFlocOHVrYxXlede211xo776gCR7///e9ZFClPw3Sn2yCo/dIg3XlB2T9v3rzEFxxBqVO+9Th58mSoe7Dm217ORwABBBBAAAEEEEAAAW8FCIB660luCIRCIHn+z1wWQNIK8C1btgxF+4JcyQEDBpgmTZqUpIqaD7Rz585OWeqx+Pjjj4d6DsuSoOVYiIKgL730ktm2bVuOV9TNaQrSzp8/v24K97hUhsF7DEp2CCCAAAIIIIAAAgjESIAAaIxuNk1FwAok9wC183/qeLpenq1atWIFeAtYxKMCybZnZhHZ5HRpRUWF+c53vmN075T27Nljfvvb39aa/zWnzDiploCmknj99dfN4sWLax0Lyo5Zs2YZDYGPQtI0DmHpdRsFb9qAAAIIIIAAAggggECUBAiARulu0hYEchRI7gHqDoCmGwKfbn+ORXKaS+Ciiy4y5eXlrj3+barXroKgjRs3dgpRj0WCoN55ay7dadOmmSD2TtTK6WvWrPGusXWc07lz58zy5cvruBYUjwACCCCAAAIIIIAAAmEU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Z55pq4f/7ne/Mz/5yU9MgwYNvM0Q7vEIvf/++20uUe8FraSFwBtvvGGWLl1q20b8HDVqlE1HUJTO8PRF2Ka4FYZ4/cwzzxjywabSSKUgEwEREAEREAEREAEREAEREIFoAhJAo4nosQhkMYFID1Dn/cl0Y4W/87wEUChkznLRCzSaNmkACJ/+xS9+Ye644w5Tr149bxMK3zz88MNm9OjRNsek94JWUkaAUPVZs2Z57Y0YMcILZ/eejHOFY8n+DRs2tHtQ/OrZZ59Nadg6VecpwCQTAREQAREQAREQAREQAREQgUgCEkAjaWhdBLKcQH4CqDxAg3vgzz///LjCjIM7g9SNrEWLFubee+81N998s0EcdoZ34h//+Ecr1Cks3lFJ/v+mTZtsygHX0uWXX27zs7rHifwn3QYepO7mCvld33333USaynefFStW5PuaXhABERABERABERABERABEchNAhJAc/O4a9Y5SIDCMYcOHfJmXlgBJDZUDlAPV8ZW8M5F+JOdJNC+fXvz29/+1lxxxRWmRIkS9gVSOrz++uvmscceM3gBypIjwM0SQtQpfoR17NjR9OnTJ7lG/29v8g2TQ9QV+ZoxY0ZKc3euXbvW4F0qEwEREAEREAEREAEREAEREAFHQAKoI6H/IpDlBMj/STETZ5ECaCwP0JIlS5rSpUu7zfU/gwSoik4ORdlJAsWKFTMXX3yx+Z//+R/Trl077wW8Fv/1r3+ZmTNn5nm/extoJS4C48aN89IK1KpVy4aux7VjnBs1btzY9O7d29ua/hCxU2Hc7JEXaCpIqg0REAEREAEREAEREAERyB4CEkCz51hqJiJQIIHI8Hc2LCwHqLw/C8Tp64t4zLVt29bXPsPSGe9TKowTVl2+fHk7bLwW33zzTfPII494Il5Y5hOEcc6ePdusXLnSDoUbIfB1nrapHF///v1NnTp1bJOcj95///2UNb9s2TJz5MiRlLWnhkRABERABERABERABERABMJNQAJouI+fRi8CcROIrADPToV5gEoAjRutLxuSC9QJfL50GLJOEIgJiydU2xmh0H/5y1+MKoM7IoX/3759u3nrrbe8DYcOHWqqVq3qPU7lCl7Nw4YNyxMKn6oCRkePHvUq16dyzGpLBERABERABERABERABEQgnAQkgIbzuGnUIlBkAt98802efZwHKB5eZcqUyfMa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5xuXCsSDoRUREAEREAEREAEREAEREIGsJSABNGsPrSYmAicJFMUDVOHvJ7mFaa1u3bqGvJayxAlccMEF5s477/QEQQSyf/7zn1njLUjY99ixY/OEvrdq1SpxYGnes3fv3jZPH93glZvKapzkAn3jjTdsEbE0T0PNi4AIiIAIiIAIiIAIiIAIBICABNAAHAQNQQTSTaAoAqhCqdN9NNLXPh5zKuqQHN+mTZvavKBVq1a1DVFFmwrxH3zwQXINB2Bv8ptu2bLFjoTP+ZVXXhmAUeU/hHLlypnu3bvbDdLhBYoI+tZbbxlXTC7/kegVERABERABERABERABERCBsBOQABr2I6jxi0AhBPD64kLfWWEh8PkVRnL7639wCSB+urDh4I4y+COrVq2aueeeewxiKIb4hrfgyy+/HNriOV988YWZNm2aB/+6664LhVh+8cUXe16gS5YsSakXKDA4N06cONFkc9Er76BrRQREQAREQAREQAREQARymIAE0Bw++Jp6bhCIzP/JjJ0ASp7PWGKnQuDD/b4gDL5BgwbhnkQARk9ezDvuuMMQFu/s448/No8++qiJ9Kh2rwX5/6FDh8yYMWOskMs4e/bsaZo1axbkIXtjK1u2bB4v0Pfff997LVUrnBOnTp1qjh49mqom1Y4IiIAIiIAIiIAIiIAIiEDACEgADdgB0XBEINUEqHjs7MSJE2bfvn32IUVGKJ4TaYiiCoGPJBLOdXInBrGwTdho8vmgMNJVV13lFQZbt26duf/++83WrVtDM50XXnjB+9zXqlXLDBgwIDRjZ6C9evXyvEBTnQvUgcBD9sknnzRPP/20WbhwoXta/0VABERABERABERABERABLKEgATQLDmQmoYI5Ecg0gOUXHeExGOVK1c+ZRe8rYoVK3bK83oiXAQIhUcElaWGQI8ePcztt9/uhYxTHOmBBx6whXlS00P6Wpk5c6ZZuXKl7aBEiRLmpptuMsWLF09fh2lomVygLrUD6QjS4QXqhk1I/Lx582wf3333nXta/0VABERABERABERABERABEJOQAJoyA+ghi8ChRGIFED37NnjbR5LAFX4u4cn9Cv169f3RKPQTyYAE2jZsqXNC0p+UIyckc8//7x58803vZsKARhmniGsXbvWvP32295zw4YNM9WrV/ceh2mFXKBOuMULdNeuXWkd/ueff25zvqay8nxaB6zGRUAEREAEREAEREAEREAECiQgAbRAPHpRBMJPIFIAdfk/mVWVKlVOmZzC309BEuonOnToYLp06RLqOQRp8K44UuvWrb1h4WH58MMPB66SOJ/1Z5991pD2AiOXaadOnbxxh23FTy9Qx4Z0Ia+99pqZM2eOIY+qTAREQAREQAREQAREQAREILwEJICG99hp5CIQF4HIHKCFeYDGKooUVyfaKLAEzjnnHNO5c+fAji9sAyO9wK233mouvfRSLy/o+vXrzV//+lezevXqQEyHMO6nnnrKHDx40I6HolhDhgwJxNiSGUSkF+iiRYvM7t27k2kurn0RkJctW2a9fefPnx9Yb9+4JqONREAEREAEREAEREAERCCHCUgAzeGDr6nnBoHIitXyAM2NYx49Szz/zj///Oin9ThBAhQLQwAlL6grNsXn7PHHH7e5I12e3QSbT2o3QvMRP7dt22bbodjZLbfc4oWPJ9V4hncuX7686dq1qx1FunOBRk+VfKALFiywHqH79++PflmPRUAEREAEREAEREAEREAEAk5AAmjAD5CGJwLJEMB7KT8BVDlAkyEbvn3PO+88mxP09NN12k/V0SMv6K9+9SvTsGFD2yT/J06caP7xj3+YTOSORHglLymV6jGKHuGtigiaLUZxL5cLlGrtfniBRrIj9+jrr78euJQHkWPUugiIgAiIgAiIgAiIgAiIwKkEdCV8KhM9IwJZQ4AQWJcDkEm5EHiEEbypIg1RgSrwsuwlQE7QgQMHetXMs3em/s2MtBE/+9nPTP/+/c327dttx1u2bLEh8VOnTs3z+UvnqPD8JOfnJ598YrtB6B41apSpV69eOrv189+MbAAAQABJREFUvW3OW5EV4SdPnuz7GMgHSnEpUg3IREAEREAEREAEREAEREAEwkFAAmg4jpNGKQIJEYgsgHT06FHPG1TenwnhzIqd6tata4YPH26oEi9LDYEzzjjD9OvXz3pbukJihExPmDDB3H///Wbjxo2p6SifVhDinnjiCbNixQq7BSH6I0eONC1atMhnj3A/HZ0LNN0V4WPROnDggHnjjTdMZFqRWNvpOREQAREQAREQAREQAREQgWAQkAAajOOgUYhAWghECqDO+5OOYlWAr1SpUlrGoEaDR6BMmTLWE7RXr15eOHHwRhm+ETVt2tT85je/MaQbcIY36AMPPGDGjRtn0pE7klyff//7383nn39uu8Tz88YbbzQdO3Z0Q8i6/9FeoO+9915G5rh3717z6quvmk8//TQj/atTERABERABERABERABERCB+AlIAI2flbYUgdARiBRAIz2V5AEaukOZlgG3atXKXHPNNaZq1appaT8XG6Uo0nXXXWcLJBEe72zevHnmvvvus6HTkZ9L93pR/5Pvc/r06TbfqLu54XJ+kuog241coMwXW7JkiVf0ye954+k7Y8YMQ4V4mQiIgAiIgAiIgAiIgAiIQHAJSAAN7rHRyEQgaQJff/2114YTSXgilgeoC931dtBKThDguA8ePNjUrl07J+br1yTPPvts89vf/taGxhcrVsx2S55ORMvf//735pVXXjFbt24t8nCofk6oO16f5KGkTQwR+5577jGI2rlg5cqVMxdddJGdKkwmTZqU0WlTIf7DDz/0LedrRierzkVABERABERABERABEQghAT+c1UWwoFryCIgAoUTyK8CfCwBVCHwhfPM1i0ogEVxpHfeeSchUS5buSQ7LzwUKY50wQUX2OrwVC1HrMNr8KOPPrJLnTp1TLt27axwWatWLUMIeyyj2vny5csNQtuOHTvybHLuueeaoUOH5lxxK3KBzpkzxxw5csQWf9q8eXNGiz4tXbrU5nvt0qWLadSoUZ5jpAciIAIiIAIiIAIiIAIiIAKZJSABNLP81bsIpJVAfh6g0SHwFE2RAJrWQxH4xvFSHDRokFm7dq0NKY70GA784AM+QD5bhMX36dPHTJs2zSCEnjhxwo6aHKEsEydOtPlY8cQlx+WZZ55pvTu5iUF1+cibGW663MhA+GzZsqV7Kqf+k24AERR2GAL+XXfdlVEG+/bts+OpUaOGOf/88zMqyGYUhDoXAREQAREQAREQAREQgYARkAAasAOi4YhAKglE5hqMFLQicxPSH+GkVLKW5TYBvA+bN29uKOZDSPGGDRtyG0iKZ1+9enVz7bXXmgEDBtickeQFjfxcEs4eT8V42kFMPeecc3L+c9ujRw8za9YsKxBTCGr16tWBEITx0iVFQcOGDU3Pnj0NhcdkIiACIiACIiACIiACIiACmSMgATRz7NWzCKSVwOHDh22oLZ3gbUbFYoycj4Q8R1q0IBr5mtZzjwBCaL9+/cxbb71lvQ9zj0B6Z1yhQgXTt29fu5AHdOXKldbz9ssvvzR8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NI1HBERABERABERABERABEJLQAJoaA+dBi4CsQkgenIBjTnvT9ZVAR4Ksmwm0LRpUzNkyBBViE/wIFesWNH06tUrwb2T241QdXKOpsuaN2/u5TH94YcfbCj83r1709Vd0u0ePXrUiqBHjhxJui01IAIiIAIiIAIiIAIiIAIiYIwEUL0LRCDLCDjvT6YVmf8zWgClgjY5+GQikE0EKKpz6aWXmosuusioSnz8R5a8n5n2oMULtFixYvEPuohbDhw40DRq1MjudejQIfPss8+a48ePF7EV/zbfv3+/ef/99w2CrUwEREAEREAEREAEREAERCA5AhJAk+OnvUUgcAQiBdBID9DoEHjl/wzcodOAUkSAkPi2bdua6667zhO8UtR01jZDCoHomyR+T5YbMq5gUTr6RuS96aabvMrz5AMdO3ZsoAVGxrh8+fJ04FCbIiACIiACIiACIiACIpBTBCSA5tTh1mRzgcCBAwe8ae7atctbr1atmrfOigTQPDj0IAsJlCpVynqDNmnSJAtnl7opkYOzffv2qWswiZY6duxoSpYsmUQLBe9KVfubb77Zq2y/bNkyM2HChIJ3yvCrc+fONXiDykRABERABERABERABERABBInIAE0cXbaUwQCSSBSAI30AI327pIAGsjDp0GlmMDpp59uq4zjWZjO8OoUD9u35sqXL2/69OmT1irsRZkMaQvOO++8ouxS5G0bN25sRowY4e03bdo0M2vWLO9x0FbI6cwYqRAvEwEREAEREAEREAEREAERSIyABNDEuGkvEQgsgUgB1HmAlihRwuD5FGmqAB9JQ+vZTAAR9MILL7ThzxTbkf2HACHh5EsNWq5UvFHPP//8tB6mTp062ZynrpPXX3/dzJ8/3z0M3P/t27ebyZMnmxMnTgRubBqQCIiACIiACIiACIiACISBgATQMBwljVEEikDA5QA9ePCgodAHFh3+znPyAIWCLJcIIPR169bNIH7JjC0UFevcEAQ2eIGmWwTt37+/fT+4+Y4bN84sXrzYPQzc//Xr19uiSBJBA3doNCAREAEREAEREAEREIEQEEhfudUQTD5yiEePHjWvvfaaWbRokdm3b59p2rSpzYlGVVy8ZIpqn332mRk/frzZtGmTKVOmjGnTpo3p1atXgQU5/Nhn5syZ5pNPPsl3OhTKufbaa/N9XS8EmwAhkt9++60d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Y/Nf//Vf3vl5//795qGHHspIXs7169eb2bNnB4qPBiMCIiACIiACIiACIiAC6SIgATRdZNWuCPhEgAtobN++febo0aN2PdL7kydUAd5i0R8REIEcI9CzZ09TsWLFQM2a8/PPf/5zU7VqVTuuQ4cOmUceecSsW7fO93F+8sknhsJIMhEQAREQAREQAREQARHIdgISQLP9CGt+WU/AVYCPDKOUAJr1h10TFAERiINAyZIlzaWXXurl3oxjF182IScznqC1a9e2/R05csQ8/vjjZvXq1b70H9nJggULzJo1ayKf0roIiIAIiIAIiIAIiIAIZB0BCaBZd0g1oVwj4DxAt23b5k1dAqiHQisiIAI5TqBKlSqmR48egaNQrlw5c/fdd5sGDRrYsR0/ftw89dRTZsWKFb6PdebMmRkpyOT7RNWhCIiACIiACIiACIhAzhKQAJqzh14TzwYCx44dM1T0xVz+T9ajBVBVgIeKTAREIFcJtGzZ0pATNGhWunRpWxjJ5Sr97rvvzDPPPGOWL1/u61ARX9977z1VhveVujoTAREQAREQAREQARHwk4AEUD9pqy8RSDEBF/5Os/mFwJcoUcLgaSQTAREQgVwmQD7Q4sWLBw4BYfq33367QaTFTpw4YUaPHm2WLFni61j37t1r5syZ42uf6kwEREAEREAEREAEREAE/CIgAdQv0upHBNJAwIW/c8HsPEARO8uWLev1Rvjnaaed5j3WigiIgAjkIgHOjV26dAnk1BFmb731VtO6dWs7Ps7pzz//vFm8eLGv4/30008N1eFlIiACIiACIiACIiACIpBtBCSAZtsR1XxyioDzAP3qq68MoZNYdPi7qzScU2A0WREQARGIQaBNmzambt26MV7J/FPFihUzt9xyi2nbtq0dzA8//GDGjBnjuwg6Y8YMQ2V6mQiIgAiIgAiIgAiIgAhkEwEJoNl0NDWXnCPgPEB37drlzb1GjRreOisSQPPg0AMREIEcJoA3/MUXX2wIOw+inXHGGeamm24y7dq1s8PLhAhKXunJkyfbUPwgMtKYREAEREAEREAEREAERCARAhJAE6GmfUQgIAScB6gLf2dYtWrVyjM6CaB5cOiBCIhAjhMgFP7CCy8MLAVE0BtvvNG0b9/ejtGJoH7mBN26dauZO3duYBlpYCIgAiIgAiIgAiIgAiJQVAISQItKTNuLQEAIfP/99+abb76xo9m5c6c3qsgQeC6kK1Wq5L2mFREQAREQAWNatGjhFR0KIg/O3TfccEMeEZScoEuXLvVtuAiua9as8a0/dSQCIiACIiACIiACIiAC6SQgATSddNW2CKSRwL59+7zWIz1AI0PgzzrrLMOFtEwEREAERCAvgR49epjKlSvnfTJAj5wIGpkTFBF0+fLlvo1y6tSpvvbn28TUkQiIgAiIgAiIgAiIQM4RkACac4dcE84WAnv37rVTOXbsmNmzZ49d52K+VKlS3hSrVavmrWtFBERABETgJAGKDvXv39+ULl365JMBW0MEJScoxZswqsOPHj3arFixwpeREn4/e/Zss3DhQl/6UyciIAIiIAIiIAIiIAIikC4CEkDTRVbtikCaCTgPUMLfuUjFateunafXKlWq5HmsByIgAiIgAicJVKxY0QwZMsSUL1/+5JMBW3MiaKtWrezInAi6atUq30Y6b948s3btWt/6U0ciIAIiIAIiIAIiIAIikGoCEkBTTVTtiYBPBL766ivb0/bt270eowVQFUDy0GhFBERABGISqFChghVBSRkSVMNb9eabb/byln733Xfm6aef9jVH57Rp07xog6By0rhEQAREQAREQAREQAREID8CEkDzI6PnRSDgBFzYe6QAWqdOHW/Up512mpEHqIdDKyIgAiKQL4EyZcqYq666KtDnzOLFi5tRo0aZZs2a2Xkggj755JNm3bp1+c4rlS/Q38SJEw1pV2QiIAIiIAIiIAIiIAIiEDYCEkDDdsQ0XhH4kcDx48fN119/bVlECqCRHqBUf+eCWSYCIiACIlA4AfInX3nllaZmzZqFb5yhLTin/+QnPzFNmjSxI+C74N///rfZsGGDLyPie2fGjBm+9KVOREAEREAEREAEREAERCCVBCSAppKm2hIBnwgQ/k7eTxZXAZ6L98gQzurVq/s0GnUjAiIgAtlB4Mwzz7QiqBMYgzirEiVKmNtuu800bNjQDg+PzMcff9xs3rzZl+GSC/TTTz/1pS91IgIiIAIiIAIiIAIiIAKpIiABNFUk1Y4I+EjA5f/kvwtHjPT+ZCgSQH08IOpKBEQgawhQdKhfv36mU6dOhlQiQbSSJUua22+/3dSrV88O78iRI+axxx4zW7du9WW4VIZ3hfh86VCdiIAIiIAIiIAIiIAIiECSBCSAJglQu4tAJgjEyv8pATQTR0J9ioAIZCMBhM/OnTubAQMGGLzrg2iM64477jDu3H/o0CHz6KOPelEB6Rwz+UCnTJliqEgvEwEREAEREAEREAEREIEwEJAAGoajpDGKQBSBWAJoZAEkPJgqV64ctZceioAIiIAIFIVAgwYNzHXXXWfatGljTj89eD+ZSpcube68805To0YNO61vv/3WPPLII2b37t1FmWZC2+7atcssWLAgoX21kwiIgAiIgAiIgAiIgAj4TSB4v+b9JqD+RCCEBFwIfH4FkKpVq2YQQWUiIAIiIALJESAvaI8ePcyIESNMy5YtAyeEli1b1tx1112matWqdqIUKnr44YfN3r17k5t4HHsvXrzYuBtycWyuTURABERABERABERABEQgYwQkgGYMvToWgcQIfPPNN+bo0aN2523bttn/eCY5DyCeUP5Pi0V/REAERCBlBCpVqmR69+5thg0bZhAdg2Tly5e3IqgrhLd//34rgh44cCCtwyQEfvr06QqFTwFl8rjiVfv999+noDU1IQIiIAIiIAIiIAIiEE2gWPQTeiwCIhBsAs77kwtbxFAM8bNYsZMf50gxNNiz0ehEQAREIFwEqlSpYoYMGWLeeecdX7ws46WDQHv33Xebhx56yCCA8l3xxBNPmFtvvTWtgi2i3fLly02HDh3iHWrWb0cqAo7B4cOHDWkKKFpVokQJ6z3McSFFAa/zPX7w4EGD+OlubLI9LJs0aWIQtmUiIAIiIAIiIAIiIAKpIXBSMUlNe2pFBEQgzQRcuOHmzZu9niLzf/KkPEA9NFoRAREQgZQTKFeunBVBKQS0cePGlLefaIPkfiYcHhGUG2QIbc8++6wZNWqUIZQ/XTZv3jxTt25dgzicK4anJmkGEIARMxEyST+AwHns2LGEMVDM6qOPPrILha5IbcBxbdSokalVq1bC7WpHERABERABERABEch1AhJAc/0doPmHjkBhAigXTPIaCd1h1YBFQARCRgCvPqrEz58/3yxcuDAwoycHtBNBEdN27NhhRo8ebYslpSt0n6rwkyZNsukB4JKNRs7tTZs2GW4+4rmJ12a6DQ9S+mNZunSpadiwoenUqZNucqYbvNoXAREQAREQARHISgISQLPysGpS2UwAbxMs0gO0du3a3pTl/emh0IoIiIAIpJXAaaedZjp37mxzYFIQKChWs2ZNK3hSDAmhbuvWreapp56yzxGKnQ5DFJw2bZq57LLL0tG8r20Swo73LAIynrRr1661Xp6+DiJGZxs2bDAspDsgTL5Vq1YxttJTIiACIiACIiACIiACsQhIAI1FRc+JQEAJkCOMEDvsyy+/tP/J/RkpeipEzmLRHxEQARHwjUCXLl1svsdVq1b51mdhHRGSfsstt1jhk5BshLMnn3zS3HbbbaZ48eKF7Z7Q6+vXr7f5QNu1a5fQ/pneCaFz7ty51sMz02MpqP99+/aZGTNmGLxSe/TokScHeEH76TUREAEREAEREAERyGUCqgKfy0dfcw8dAcLff/jhB5t3DA8VDE+fM844w5sLj2UiIAIiIAL+EujVq5fp2LGjv50W0luDBg3MyJEjPYHs888/t+Hw6aw0Tv5Kl6qlkOEF5mUExQkTJpjJkycHXvyMhLZ69Wozfvz40PGOnIPWRUAEREAEREAERMAvAhJA/SKtfkQgBQQKC39HCI30Bk1Bl2pCBERABEQgDgKEw3ft2tX06dMnz02pOHZN6yYUz7n22mu9Ma1cudKMGTPGhu2no2PE1ffff98cP348Hc2ntE1ybBK2P27cuEAVsyrKJBGbX331VZsjlBukMhEQAREQAREQAREQgdgEJIDG5qJnRSCQBGIJoJEV4Cl+EekNGshJaFAiIAIikMUEWrRoYfr16xeoc3Hz5s3N9ddfbxBpMQrqIPqlSzCjOvq7775r0ulpmuxbiLyoL7/8ssGL8sSJE8k2l9H94fzhhx+aiRMn+lKcKaOTVeciIAIiIAIiIAIikCABCaAJgtNuIpAJAhRlwPIrgKTw90wcFfUpAiIgAnkJ4HWJCEqO5qBY27ZtzXXXXeeJoAsWLDCvvfZa2oa3ZcsWWxk+aCIo+VDnzJlj3nzzTeNSyaQNgs8Nk+cVUfeLL77wuWd1JwIiIAIiIAIiIALBJyABNPjHSCMUAUuAi7b9+/dbjx1XAIlCFlWrVvUISQD1UGhFBERABDJKwIWe8z8o1qlTJ3P11Vd7w0EIfOedd7zHqV7ZuHGjmTp1ato8TYs6Xr47X3zxRbNs2bLAjKmocyhse6rWT5o0yeY05XeDTAREQAREQAREQARE4D8EJIDqnSACISHgCiDt2LHDVhtm2IS/n376yY+xBNCQHEwNUwREICcIlC9f3lx22WWmZ8+enudlpidOntJBgwZ5wyAHJjk702VUVv/444/T1Xzc7X7yySdW7M02r8/8ACA+v/XWWwqJzw+QnhcBERABERABEcg5AieVk5ybuiYsAuEi4PJ/EuLmrH79+m7VVKxY0ZQqVcp7rBUREAEREIFgEGjdunWg8oJSsb5///4eHHJHzpw503uc6pUlS5ZYr8tUtxtPe4Tgz5gxw8yaNSv0uT7jmW/kNjt37rQi6HfffRf5tNZFQAREQAREQAREICcJSADNycOuSYeRgBNA169f7w2/Xr163nrt2rW9da2IgAiIgAgEi0CTJk1s+HnlypUDMTBylCKEOiMnZjo9NSnSQ8EhP+3rr7+2eU4//fRTP7sNVF/kDp89e3agxqTBiIAIiIAIiIAIiEAmCEgAzQR19SkCCRDAkwOL9ACNFEBr1aqVQKvaRQREQAREwC8CVapUMcOGDTOtWrXyq8sC+yEUvlu3bt42r7zyilm0aJH3OJUrVJzHE3PVqlWpbDZmW3h9Ll682Ob7dDcPY26YI08iAJOKQCYCIiACIiACIiACuUxAAmguH33NPTQEDh8+bAsgHTx40LhK8NWqVTOlS5f25iAB1EOhFREQAREILIEzzjjDel6Si/O0007L+DiHDh1qzjvvPDsORMoXXnjBLF++PC3jOnHihJk+fboNy6aoXzrswIED5tVXX7XerAr9PkmYFAf79u07+YTWREAEREAEREAERCDHCEgAzbEDrumGkwCFj7DI8PfIysJly5Y1FNuQiYAIiIAIhINAx44dzaWXXmqKFSuW0QEjwo4YMcK0b9/ejgOR8rnnnkurpybV2MeNG2c++OADc+jQoZTN//PPPzcvv/yyoWigLC+Bo0eP2srw3FCViYAIiIAIiIAIiEAuEsjsr+5cJJ4Dc8arwwl2OTBdX6ZIyCCVa7m4cxZZ8b1q1api7sDof04TwIMN0zkop98GoZl8mTJlzIUXXmi9IvHwT6cdOXKkwOYHDx5sEMfWrFljCCF/+umnzQ033GAaN25c4H7JvDh37lyzYMECww29li1bmkTzoyKi0tbmzZuTGU7W78vviBdffNEW5Mq08J4p2O47gt+qeAvLRCCXCbjPAwyOHz+u3065/GbQ3D0C7nOhawkPSWBWuJmLcbM+UZMAmig57ZcvgZIlSxou6mSpI8CP9BIlShi8ZpxRUMMZYqiYOxr6n8sE+GIk7FWfh1x+F4Rr7rxXhw8fbubPn2/Fx1SOns+C+5GI4HX66QUH/tx0003mmWeesfki2Xfs2LHm1ltvNQ0bNkzlsE5pa9OmTYalYsWKVnClv7POOuuU7dwTfM75Pty2bZv19ty7d6+dJ9+TsoIJ8Hti1qxZ1vu4ePHiBW+cha/yeUAwP/PMMzPufZ2FeDWlkBFA6HE33/h+iEytFbKpaLgikDIC3DDmu0Kfh5QhTVlD7uZtMimkJICm7HCoIUegVKlSply5cu6h/idJgBMwFyzkjXMCKIzr1Knj/Wgh/6eYJwlau2cFAX7M472mz0NWHM6cmQTv1wEDBtgw9ClTpnjn9mQB8HmIFEDdD8f82kVAvO2228xjjz1mU64cO3bMeoLeeeedpkGDBvntlrLnEaZWrFhhlwoVKpgaNWqYSpUqWbGKuXzzzTdm69atNhe2mxedFzavlA0wSxpCMKYg1cCBA+3N1SyZVlzT4PvBCaD8lpKJQC4T4PPgBFCuM/TbKZffDZq7I8ANYF1LOBrB+u9udCcjgBbsChCs+Wo0IpCTBMhlxokY7xjCUzDCBd0HHy8G5f/MybeGJi0CIpBlBLixdc0115jatWtnbGb8uLz99ttN/fr17RjwtkQQ9Tu8nBt/hOPPmzfPfPBjrlC8FpcsWWJ27tzpiboZg5QFHW/fvt1MnDjRXuRlwXQ0BREQAREQAREQAREolIAE0EIRaQMRyCwBl39k7dq13kCaNm3qreMhIxMBERABEcgOAoRcDRo0yCtKlIlZcWPtjjvuMHXr1rXdEw726KOP+i6CZmLuudTnli1bzPvvvy9BOZcOuuYqAiIgAiIgAjlMQAJoDh98TT0cBPDSwPITQAl/l4mACIiACGQPAXKxde/e3fTp08dQ5M55/Ps5Q8KDCX133qgUSJII6ucR8KevL774wnz88cf+dKZeREAEREAEREAERCCDBCSAZhC+uhaBeAgggBICv2HDBrs5F6XugpQnJIDGQ1HbiIAIiED4CLRo0cKGxI8aNcr06tXL5sT0cxZ4o951113e94wTQUnJIsseAkuXLjXr1q3LnglpJiIgAiIgAiIgAiIQg4AE0BhQ9JQIBIUAOdAo+rBx40Yv/yfV310lX5KVly1bNijD1ThEQAREQATSQICQ9FatWpmhQ4eaTp06paGH/JukSv3dd999igi6fv36/HfSK6EjMH36dLNv377QjVsDFgEREAEREAEREIF4CUgAjZeUthOBDBAgPxcWGf6OAOpM3p+OhP6LgAiIQG4Q6Ny5sxVD/ZytE0Ep0oSRE5TCSBQpkmUHgWPHjplJkyYZ/stEQAREQAREQAREIBsJFMvGSWlOIpAtBL788ks7lUgBtFmzZt70IkPhvSe1IgIiIAIikNUEevToYfOCrly50rd5IoISDu8qwiOUPfHEE+bGG280bdu29W0c6ih9BPbu3WumTZtmLr300ozknU3fzNSyCGSWwPHjx20011dffWUOHTpkbyKRUuTo0aP2psP3339vihcvbooVK2b/E92Fw0ODBg3s48yOXr2LgAiIQPYQkACaPcdSM8lCAlu3brWh74TAY+Rjc16fhMHXrFnTPq8/IiACIiACuUOA83/Pnj3td8DMmTNtnmg/Zu9ygj755JM2ZyT5qZ955hmbp/SCCy7wYwiB7ePEiROGtDWIiPv37zdff/21+fbbbw0iBwsCCLx++OEHW9iKbUqUKGHI643YUbFiRVO5cmVTvXp1U6FChYzNk6JIixYt8j3VQsYmrI5FII0EOCcsXLjQRnLx+S+KkZcXURQhFOeHKlWq2OuAorShbUVABERABPISkACal4ceiUBgCLi7xPwAcj+amjZt6nll1KhRQ3eFA3O0NBAREAER8J8ARZK4KCZ0mQttP4x8pLfffrt59tlnzapVq6yg99JLL1nB75JLLvFjCBnvg9zcmzdvNqSp4Ublzp07ze7du73v6sIGiBhaUNEhhGbSDTRq1MiKH/zHM8wvmz9/vjnrrLNM48aN/epS/YhAVhEgn+7ixYttmhBujiRqnCtWr15tF9rg/Mu1QOvWre25P9F2tZ8IiIAI5CoB/35N5SphzVsEEiTg8n9ygemsZcuWbtXUrVvXW9eKCIiACIhAbhJAAB02bJgNXfarMBGei7feeqt58cUXrbcg5CdOnGj27NljvUHPOOOMrDoYu3btsh5ceEeyJFssqDBBhBDZzz//3C6AhHfz5s1Nx44drfBRsmTJtPLFS3XKlClmyJAh1ls1rZ2pcRHIIgLcDFmyZIk9T/A5SrWRf3nFihV2Ofvss02XLl2sF3mq+1F7IiACIpCtBCSAZuuR1bxCT6AwARSPEO4My0RABERABHKbAILYZZddZpYtW2Y+/vhjQz65dBsi5/XXX2/Kly9vZsyYYbvDc5DohVtuucWQMzSsRl6+zz77zHq44n1FuHphBoeqVataz8lKlSpZLuXKlbMhq4S5E8rKctpppxkEUCI7+A4/ePCgDZUndB5227dvt0tkMSLWneiBGIoQ2q1bN1OvXr3ChpXw64wPURtxnfHLREAEYhNA6Ny0aZMVPvEI98twkNiwYYN3Y4Rzg0wEREAERKBgAhJAC+ajV0UgIwS4OOJHFCF1LBj5PrmowrjQwuuHCyWZCIiACIiACECgffv29nvi3XfftSJbuqkg5g0aNMjmrnzttddsODyh3X/729/MqFGjQhWpgNflJ598YkVkvC9d6plohsyZ7+P69evb+VGMkMeEpqbK+A3A9zvepgixjMcJovyfN2+eXbgR2qdPH9OqVatUdZ2nHUL9Sa/AMc42r948E9UDEUiQAJ/RuXPnJu0VnmD3Nr/wRx99ZD3xyQtNeLxMBERABEQgfwISQPNno1dEIGMEduzYYStDRoa/R17gKC9Xxg6NOhYBERCBQBNAmKNKvPPK9GOw3bt3tzflRo8ebasbEyL+4IMPmquuusp07drVjyEk1IfzrKRICUJjrNB0BE9SzlCEBHGhYcOGKRU7Yw2cIlcIqywXXnih9RTFE5WcgniCOnGWlAdPPPGE9QQdOHCgHWOs9pJ5btu2bWbWrFmmV69eyTSjfUUgqwhQnJRiYUFxRMBrffLkyTYfMWHxnENkIiACIiACpxKQAHoqEz0jAhknQCgNFimAkuvHGV4fMhEQAREQARGIRYAbZuSKmz17tm+pUshRfe+995qnnnrKXoQT3v3KK6/Y77FrrrnGEA4eBCNcFS9VwvVJGeA8KyPHhjcn37kUGmFemQ7nJ3S+bdu2dqGyPGNHlHSh+RRkeuSRR6wnKKIzofiptE8//dQK3IxBJgK5SoDUImvXrjVLly61+Y6DyIGxkU6DgnTpzhUcxPlrTCIgAiJQGAEJoIUR0usikAEC3FnmosxVieViDK8TjFxchNvJREAEREAERCA/Auecc46pUaOGFcrcTbX8tk3V89WqVTP33HOPoSo8F+IYHouEiQ4ePNh06tQpVV0VuR0KNC1YsMAuCATRxncrAl+HDh2sJ6WfVdejx1LQ47Jly5qLL77Yevkyn/fff98KHuyDULlmzRr7et++fW3O0YLaKsprc+bMsflNqU4vE4FcIoBnOJ8tPMXJ2Rt043w/fvx4M2DAAFOxYsWgD1fjEwEREAFfCUgA9RW3OhOBwgng3cGFGhcxrshRixYtvPxbeH8SkicTAREQAREQgYII4HVJXrgvv/zSejsSJplu44bdTTfdZD0ouQjnZh75NceOHWvIVYeHYjqL90TO7/Dhw3beCIWIsNGGyIm3LMIsHp9BFT2jx81jcnJecMEFduyIk4S/Ml/C4xFFEaBHjBhhUhUxgghEH1SGl6gS64jouWwjgMcnaSYQPilQFiYjDQnn3379+oUqF3OYGGusIiAC4SQgATScx02jzmICzlPHec8w1TZt2ngzVv5PD4VWREAEREAE4iDgclgilBFh4Iedf/75pkmTJubll1+2N/ToEzHh/vvvt8Wa8FBMhzchNw5JH0O+zJUrV3r5MiPnTJ7U8847z+AlW7p06ciXQreOaIvIjYg7YcIEW5CFSezatcs89NBDNnfnZZddlhJxF4GVPhBBVRk+dG8VDbgIBMgJ/OGHH9qbCkXYLVCbkgblnXfesXmEI68jAjVIDUYEREAEfCYgAdRn4OpOBAojwMUpF3BcuGFc3JCHDONCjQtZmQiIgAiIgAgUhQCemYRE4s2ERyS5MNNtlStXNnfeeaftjwvxr7/+2nZJ7k0WBFKKJHFxXqJEiYSHQ7VyBAu+NwlVjZXXs3z58lb0RJitXr16wn0FdUdC44cPH26Y37hx46wAyjGePn26oYDSjTfeaFMiJDt+8o6qMnyyFLV/kAmQtoMcu36cI9PNAc/tDz74wHCOxGNcEWTpJq72RUAEgk5AAmjQj5DGl1MECLchVJGLFe7cYhRgcJ4WVKFVZcecektosiIgAiKQMgJc/OL5SK7OqVOnet8zKesgn4bos127dlaM42Lcfb+R55qFIj+kemnevLlp0KCBzXPNc7GMffFupPoyERN4lVKpPJYhqpLXE+9I2s6F709C3n/961+biRMnmpkzZ1oRBz5///vfbR5WKkQna7RHOPyll16aE0yT5aX9w0GAsPHly5fbvMXhGHH8o8QjnlQk5A+WCBo/N20pAiKQfQQkgGbfMdWMQkyASq54f0aGv1OQwRkCqEwEREAEREAEkiGAyDhs2Di5VjoAAEAASURBVDArkpFz2g+jInH//v1t8R5C8VmcRyjfe3hdsTjDo5Hq6wiheGKRv5QCJIRhF2Rsz41DvjuT9SwtqJ8gvwaDQYMG2fmPGTPGIOzAmHQEVLG+5pprkq4QjfCMmN2rV68go9DYRKBQAjgeIBDyP5sN5wpyBJN+JBduBmXzsdTcREAEEicgATRxdtpTBFJO4PPPP883/J2iA9kYtpdyiGpQBERABESgUAKEhJPLccaMGYbvHr+MVC6XXHKJ6d27t1dZmQvz6LB1CgKyxGOE2uPhSSEj/iO2yowhZzjeoAifpBzAEHq2bNlibrnllqRD4kk3gJGDVF5lFoX+hITA3r17bWE0PND9ugkUBDTcAEH8RASViYAIiEAuEpAAmotHXXMOJAHuym7YsMFeELpKvXixkLcNk/dnIA+bBiUCIiACoSWApyBiJLmlqdDuQtP9mBBVzAlPZ8E7EY9CvgMJa6fiMgJFpCiKwEY6mEqVKhkEz5o1a5ratWubhg0bmgoVKvgx5FD2geB8880324Iub7zxhvUA27lzpy1Gde2111pP2WQmhgjK8UPQ5pjKRCCoBPidjQBIruAdO3YEdZhpH9eaNWvszQ/OvTIREAERyDUCEkBz7YhrvoEl4IofzZs3zxsjFWoxLvzIjyYTAREQAREQgVQTwHMSIXHKlCmGVCx+G0IsnpsskUYBD8Q1vgOTKZIU2Waurnfr1s3Ur1/fPPvss1ZgRlwePXq0FZwHDhyYVEgsHsSkM+jXr58pV65criLWvANKgJspiJ4USnMOBgEdqm/DosI9uaCrVq3qW5/qSAREQASCQOD0IAxCYxABETD2rvSBAwdsASR44LVB/jIM7xx5uFgU+iMCIiACIpAGAnhXXn755aZVq1ZpaD2xJgnVJJxd4mdi/KL34rfEL3/5S5sqwL1GCoTHHnss7nQDbr/o/3jUvfLKKzaPq0SmaDp67DcB8gbjUf7666+bF1980RY30vvy5FGg6OqECRPsDZCTz2pNBERABLKfgDxAs/8Ya4YhIICHCx6g8+fPt8UeGPK5555riz+w3rp1a/7JREAEREAERCBtBBAcKWpDmPncuXMNF8my7CLAzdXbbrvNvPfee7aSO7PDg5Mq8eQFrVevXsITpkAVhZEocEXUSqdOnRLyCKVa9a5du8z+/fttyD6pGUiLwE1i+uB9SYEsCmWxTmgz6+S1ZZ39Ebv4bYUQxvsaEZ25V6lSxZx11lmGvOqy7CPA+4Ewd4qJ5lJuz0SOJJ+rd999194QCdKNr0Tmon1EQAREIF4CEkDjJaXtRCCNBFzxo8jw9wsuuMD2yA92QhNlIiACIiACIuAHASqo16hRw7z//vvmm2++8aNL9eEjAVIK9O/f34qdVIlHCKFS/IMPPmiGDh1q3O+PRIeECEVuUEKOSWtAMSa8TwvLEYoXKb+D4qnGTcg9izME0ngMcQyBlLzqHTt2tGkB4CELNwHec8uXL7fCJ8dXFj+BhQsX2s9Ely5d4t9JW4qATwS46cV3FDe3ItPhkMaFG1yk0CFShCgWmQjEQ0ACaDyUtI0IpJkAFwqRlSi5UKC4A0ZuNrwXZCIgAiIgAiLgFwGKDF1zzTW2SvwXX3zhV7fqx0cCRJfce++95umnn7ZFYbjAfOmll2xEypAhQ7wolESHhCi1atUquyB+ksqHHKFcxNIXOV5ZWOdiNlLQTLTPePbjopliW1u3brUXzdWrV7e/uRBF8STNhHGjYfv27dbTFQ7ffvut9W5lrMWKFbMX+I4fF/p4wPIZzU9UZj88aBGVEQ8oqFmrVq2sS6fEewyhfcGCBUmncfDzuDNuhB0n4tA3XsocJwQdv43rED6LV1xxhf18+t2/+hMBCPC5IA8552bOh9HFEAuihAiKdz83b7mOrlOnTr7nx4La0WvZT0ACaPYfY80w4AQI0aEi66xZs7yRdu7c2a4jfCosxcOiFREQAREQAR8JcDGOp+CyZctslXgukGXZRYBCKPfcc48ZN26c9Z5jdqQ/wAvzpptuSlmRFC5suZhlCZIhQm38MQURy8cff2waNGhg8ITjQjqdRog+4iSc169fb8P7i9ofghnj5RiStgIhGSGV35RbtmyxAltkm/ymRPQmxRICapgN4ZDoqSVLliTEzq+58xsfQWfbtm32eOOpzGeA911+hsCN2E2BoiZNmth0DRQwS/d7kurws2fPNhdddFF+Q9PzIpAWApyvKFTGeZjUJYkY51REUxZSYHB+5KZW9+7d7U2kRNrUPtlJQAJodh5XzSpEBDjh79692xYOYNj88DnvvPPsDJo2bWpzWoVoOhqqCIiACIhAlhFo3769FVgmT55sPZaybHo5Px08ZxA7EdPefvtt6wnGBSl5QUeMGGE4/rlgeE1SOAfvUKJvCN/HyzIVIfJ4dSJ0Ik7ymw/vTPpLxpwIiBAYj3ED45NPPrG/N4ky4ngjquGVy3uABW/TIBuiMb+bSWWA4Bs0Q+hESCSqi+N98ODBIg8RcZTFee8yVwyRm9y6OEbwH4En1cb7g3aTTYOR6nGpvewjwPmIz8rixYttCpZUz5DzI+cKzrkDBgzImHd/quel9pInEOxvueTnpxZEINAEuMvFyf+DH4sGuB/CeB7wI5Qf3OSnkomACIiACIhApgnggURYNHlB4823mOkxq/+iEejZs6fNCzp69Ggbjk7o9LPPPms9Iq+66qq0CC5FG6E/W3NhzoUzC17QeE66CuKsE3bOf0KVWQibJ+wSrz0X2o+QyO84ijkhivE/KMbvTQRulmgj7zyiaMuWLQ034fMLsY/eL52PEQP5rbx69erAFTZCZGFsvFcII48njYPz8OQ/v/d5L3FMeI8xV9pwwimfQWfk6cU7mwWREm/e888/3wr1tJEqW7RokU2bgCdoKttN1fjUTrgJ8F7npg35nuP5vCQ7W244kdqFz0vbtm1D7/2eLA/tb4wEUL0LRCCDBMhbhBcA1d8xfmhceOGFdp2LTaqVykRABERABEQgCAQqV65srr76ahsOv2LFCu/GXRDGpjGkhgAFi37961+bsWPH2tyKtEpoOB5tI0eOTKpKfGpG6G8rkQIUPRPKHx2iSZjzxh9DN7PBKCDEgjj60UcfGQqiIRykw9uwMF6EihPKisAI96CY8ywjNQg5bnkcyxDByUXI73nyESKSk64AUb0wo00nnuORjGcyeRGdswSvE/7PUrFiRdO1a1frtVm+fPnCmo7rdQRd0in069cvI8c+rkFqo9ARIDydlG+Ikn4a53GEfc4n5EJu1KiRvXHADQhZ7hGQAJp7x1wzDggBPAz44TJnzhzvxxMen4S4YOecc05ARqphiIAIiIAIiMB/CHBRj2cQYZh4InFx7i7KxSg7CBAS/dOf/tRMnz7dvPvuuzYkHjHmgQceMH379rVL0EOls+NIZHYWCKGIoISo8nlv06aNDZdP96jwguTcgrgYlHMLAixOC1RMRxyMJXri8YvYSXg6uQdZT7SgEYIzoimLS4uFVyhjcMKrE+JxpJg4caIhRQnXDr169bIiT7LHiXP7q6++asOHEVllIpAoAT7T3EjDizuTn2k+x+RdZuEc43IiSwhN9MiGcz8JoOE8bhp1FhAgpw/5fbjAcEb4GcaPJu5QyURABERABEQgiASIULj88sttCJsLTz1w4EAQh6oxJUAAMad37942DHrMmDHWY4cbt4gseNFcc801Bm9RWfYTwHsKEZTjzk16BPKGDRvaMPlUh8gTRo7o6lIOZJounr2InjgsuLD0yDEhcJIvFnEYkTidxaVoG4GThWPC8SCMGO9QDHFnwYIFdmEs3KzgOCVjhN2PHz/eXHbZZbouSQZkDu/L9S5en4igQTLnRc3vF27q6vssSEcnvWORAJpevmpdBGIS4O4XPyanTZtmf8SwEXlJCJXhooNQFpkIiIAIiIAIBJ0AIZedOnWylaUJm6XwBzkPyROaSU+PoHMLy/i4IUtIPMWRiFjBKCrx0EMP2WM+cOBAG4IblvlonIkTQADnc82CMOg8Q3mPcEOE36+JGMId4d14NuJ1mGkj9B7REzExVqguoicCI1FbiJ+ZSA9AGD2Filg431K9nTE7r1CEZBa8US+99NKkhFDEVj7/tNOgQYNMHx71HxICCJ4zZsywvwmCPGRubEyaNMl6bZOGjty8suwmIAE0u4+vZhdQAlwgsnBHDONHI3dXMX5MkWdNJgIiIAIiIAJhIcD3GDfxWDDyIpJzi9yR2SqEEgbuPOK4aHJCCP95jLCDKEz4uBMmEIzx5OK5oHnE5PdeYz5Dhw61gg/FJBg7xvFdvny56d69u+nTp09avd/yG5uezxwBCpgQRspC8SS8DZs0aRJXnljOCQh3hJPjweg+H5majfOoRETknBVtnN+aN29uRX8cFuLJ4xndRroeEzGGRzaVrrlJwbUF6QswQuZZuLbgOsOdn4s6Fop7IRK59CdF3T9d2/M+4r3DuZZjxDlZ6TnSRTv+dvkMffBjgd+wfMcxMwoz8X198cUX24J28c9WW4aNgATQsB0xjTf0BPiSJg8KPyTcD75zzz3X1KxZ0+YKoqKjTAREQAREQATCTACPMApoEEKJqMDFRZiFUEJ9ERoQEJibEz656C7I2rdvH/NlWCASI7zgWcc6ghDelUG9aHQFkvDqmTp1qs2DyO8YHhO23KVLF9OjRw8vl3nMievJrCSA4Oa8DrmJj0iIZyjh8s7wtMKj0hX1ochOJo3f44S/4ulJUTf3mzxyTHzmycHJ7/RUFRiKbD+V62XLlrVemuQA/fDDD22KrW+//dZ2QT5VFs5HCKHVq1cvctfw4rPO8SNll1+ecoiveB1zjuT7hIV5sZAqIfp7BQEUQb5ChQr2XEThKeZ71llnFXnO2qFoBAgrR4BHdA+jcR6bMGGCPXcR2SLLTgKn/XjS+CE7p6ZZ+U2ALyLy0vz1r381gwYN8rv70PRHiM/zzz9vHnzwQTtmvqh/97vfWa9PvCjyu1iKNUGq6WFcmPEFLxOBXCeARwriQSI/7nOdneaffQT4PLi8dQh2mfRa4nOJdwXFB7iAdhfmQaXO9yqej3hrEkaKB5VfhRI4bnjFcRHpvC2DxonCKxRIQtyOvJQ4/fTTbWEJUvngMcfjIBlj5TPBZ0GeYuk/Mk4ARaiKVTgo/SM4tQfC9/FeJq9nrPMQQieCJ8JnmPPxwxwhlJsVziMUGty0wdmCkHaKG7nvCD6rCIfxGNshglJNO5XG55MUBNwIok4C/3nMTaJkjXN5vXr17JgR51OdvzbZ8YV9f27g8V7j+yvsxo1JbihceeWVpkaNGmGfTlaNn/MaN9j+9Kc/mSFDhiQ0NwmgCWHTTrEISACNRSXvc1wAPvfcc+a+++4zTrzEQ6Z///72BMsHuTBvksgWXRsSQCOpaD2XCUgAzeWjr7lHEwiSABo9Nrx4uCjn4hsxDaFv8+bNNpQxett0Peb7Fm9OFoQAPJq46MFTyAk36eo73nbxuuJiDA8oRFGWTHvORY4dgeK9996zBVkihVC2gSE3dam0S2h0ohWxI/tLdl0CaLIEw7k/4gyCJwuehNHGe5OLakTPIAr30eMtymPOHzNnzrQL6864AcCNCjy3+awWRQB1beAV3rlz54S9K/mO4loGz2C+A/jvh1DO8W7atKkt5BVmkdsdh0z+5ztq/vz59rMV/R2QyXEl0zefE0R3fg+4HOdBu5mXzPzCvK8E0DAfvSwcuwTQwg8qoSP//Oc/rdcEW1etWtX85je/sZ4Iw4YNK3LuTwmghTPXFrlFQAJobh1vzbZgAkEWQGONnN8Rn3zyiVm9enUej6VY2yb6HJ5LhOjiCdSsWTN7gZNoW5naD/EYL9ovvvjCigdBuOhEVEJkwSM0UmRxjBAc8LoiT2SdOnVs2h+EZ7+9MCWAuiOS/f/5jUyldCKv8CaMNm6AIIIhcLRr1y6jHvLRY0vHY242TZkyxeYJJazcGZ9NiimR35PrkqIaHBFC8QblvJpfaDxOIJy3OBZ8N3FTJ5YHblH7T3Z7bni1adPGiqGwkMVPAO9c3lOxioXF30rwtnQCqPOIJqqsb9++KvgXgEMlATQAB0FDOElAAuhJFrHWCLn517/+ZSunulCOO++8095p7tatm+nQoUOs3Qp8TgJogXj0Yg4SkACagwddU86XQNgEUDcRviMJl8e7EG9HPEwIR3chi1xIUzUaD1LC02rXrm2FTLw1WAh1ROhy37V4brCvW1w/2fA/MrUA6QU45pk0Lk7wsounABbCCXn68L7FA41jh3hCeDrHGzECgZTjxjFkYR8Wt+5e4z/bsg8L+5OygIXXnEkAdSSy7z/HFi9ybqJQnCu/9BHk8SVlFwvvv1wzPO4nT55s5s2b550jYcBnhirYhLYn6gHvPtMIRqQS4PPMORwPXEQyd04OInPOO61atbJe6074CuI4gzAmPmvcWKAAGt/P2WbRAijzcx7TiOW8z2WZIZAKAVRFkDJz7NRrjhHgREpS5ed+DH93X/6EnBBmw13TRMTPHEOo6YqACIiACOQIAcQtPIlYCjIuvCLFrYK2zdbXEBjwYmPB8A5FbEAgRkA+cOBAnhyd6eaA4Ig3GQtiLFW+8eilCBZibaRxEY0Yw5JOQ9iBE6IG4jhCB8IXAg0LYk/kurzA0nk0Uts2F8O8tyjAxHstvxsA3Cjp2LGjXXI9Zz43HKgaT7Vr0lcsXrzYniMIPZ82bZotYsPnFyEUb/mimF+f6aKMKd5tuVaDBcIeOZ95v3BekOUlwHcK7xO+Z/w03lt4LrvraHdzzK8x0DcFntavX28oNKb3hl/kU9+PBNDUM1WLInAKAb4oHn/8cXthwotUfB88eLD9Ac4PEJkIiIAIiIAIiEDRCOS6+BmLFsWuWPBkwhA1iBbBO5QLNy5e/TIuELnZy8LFK4IsIbBcOBMG66o6R4bjpmNsMGCJd+6IpZGCqPNOxUMVEZWFbViclymiKcJ9PIZwz5ypOh65MEYeu/+ssx0L+3DhzwJLFucNy+eAxXm/MiZEXhYEXzfeeMYW9G2YP+I+oifCOu/p/N4//NYmBy0L67K8BAh3v/766w1RaKToWrFihX1f8b6bPXu2DZWHHV6hOGvkivFZgwWiOgXwKIiVi57C0cebcw7iMJ7D+X3movcpymPOz67wFekRCK/nOW5qcPMMgZoxRBrnQHdzi/M0x4mUBgj3eCFz4yPVQiXfpePGjbP5c8lvLW/QyCMSjnUJoOE4ThpliAmQD+uPf/yj/aHGNPBEuPnmm+0JeeDAgb5VlQ0xQg1dBERABERABEQgAQL85iD3JgtCByIk1eURkLig9Mu4SORilCXSuKAllQEXueQodBe6iID5iX9OBHSCIIKFExXZBwEHz0DaYI60SR88H4+xPQusimIIoE6MjBRDmSNjdeOMvogvSh+Jbsu4EAicSIBQgCegE8wRDXjMdkEyjhnpMCj+Rc7bdevW2WMTa4y8xxo0aGCLGVHQKJF8lrHazfbn8IjFI7RPnz5W9CR9hfuMkUOVhUJBeIUiBiKq54LBYNWqVfZ8Sb5ocsXyGclF42YVInlRz4n5seJ8z2eaG2KkreAzzjm6qOa+P9g3VnEz2uPGFWlyiChxeag5DyZjnJc++OAD+z2KpzTnT1l4CKgKfHiOVeBHqhygpx4i7kzfeuut9kuDV/lxhvhJ3qErr7zylAuBU1so+BnlAC2Yj17NPQLuTjF3fmUikOsEnKgEB4QOPMJkIgCB/7+9M4GSq6rz8I0QCCRsguwRwiJgABEUgixhX+SogKAiDIqQw+LAyICArKLCsAmEDEdUhkWHAQEVRIzsyCID4qBkMDjIjgwwhLCKYau539X7eF1d1dVLdVV113fPef22u373vdf1fu9//xcxDjGJYcOtHsrYrh7gpZXfqvgiZJuXZvwTcp9UL4N5GW9Xu5pVLr9REXiwnspWVHmbfUTT4RRIEcARWLgeEUSwtGKba7VewPoLKz0snhm2jNhh6D8BBCS4ExDtsRbG8g5xB/+OfEgoB+LAG9ddWL91ixia+ay22mpJCO0WwYv+Z4Z3LGIRhAcbcM3y0EMPpYUPGfXEylr55+uS3y980MvPoPyxK3/gGsiHJUR/rJoRtunTagtfPpzRXu6HRoH6MInahhtumKzwG8X3/NAIcE3ygeukk04Ku+2226Ay0wJ0UNhMJIHGBHix2GuvvdI/jhx79913T/84d9pppyGLnzlP1xKQgAQkIAEJSGAgBHhpww85CwIIH1TzUHmGH47GwBBxBD7WvEzjQ65e4OUacZQF0ZQ1nFjyCzcvydnSFEGVpWzlyQs0oiILL/EwZ8mTNeU1L/V5+Hp5Ox/LaciDhfxy4KWfMrO1LHXI9ULEZaHOuQ3EqxfIC6GCpVagXIaTIhawsI0lFaJj9q3K8HvqTdtyPTOTbJGb68TwVhYENwQR6tkokO+kSZOScMG1i1UXTAzNI4C4t+uuu4Ydd9wx3HPPPckqNE8ola0isYykf1eOFrf0Az6Isa7j+h2tgbZjOY+Qx4z3WMOOVn+yuZ8Z7s7zbqCBNHD64x//mJZ8/dTLh2cGVsa4qsCAYamllkofYnjO8HzJz5J66akvzzieJ/z/4nnCcHoW/q/xXCwH6sOCyE9gZAJi6FprrZUE0XLcRts835j4j7ZiJc0Hgkb1bZSn54eXgBagf+fLD5grr7wyzVrJP34e5Pg92WGHHYovDQPpCoYXXXHFFcm0mx8FzBiGw1wemPVCJ6epV+fycR48WDaeeuqpYeeddy6f6rptvpbhV4eHfw6InnBh2Huz/mFqAZrpupbA3whoAeqVIIF3CWgB+i4Lt/pPgN9z+cV1tImh2eKtkQDaf1ojKybiYxYemXwqC570M9uIkYgJnRIQWPOwVd6hEDwRSwzNIZDvB3JDSK5n8caINt5t8AFZTxBD9EHAYrgxghLvOtlyGBFroEI11yHCVf7IkN1icAwhH+GJ+rPk+uePBVwj3OMstAnhfDjCiiuumCZL4rocDaIXLOlrhE+eBf0N9BXD2dEyWNju6znCdcL9jIDO/c21MtDrYyB1QwilTo899lhypdGXIEs9qBeWoVga0scDqRviLX6vaZeh+QSaYQGqABr7hR8ABx10UBpqQTfxsM43PY6fTzjhhAF90UJInT59eupxHvg8sFkYpnHKKaekB2U6WfrTyWlK1exzUwH0b3jOOOOM8PWvf734ks0/xM985jPpa+r222/fy8y+T6gNTiqANgDk6a4joADadV1ug/sgoADaBxxP9YsAYgfDkvm9wcKLY7U1Tb8y6pBIWfDpVgG0UTcgWvBexHsQomheZ6GUc31ZkTbKv955LAfx2Yn1VxbREB661ediPU7NPp7vB/JF5KkngOZy6Xs+jtx///1pkiD+x/Qn8C6UJ+fKFsJZVKIOXHfkzZLfm5t5nVE2Ynq2YOa64n2fJVsbDsV6FRczDIPGGnYo+fSH5XDEycIn81bgIqQ/gf8FWMQieGLwU08YJ69sYYmVJUPP2+06AYt+RmpSb9rQlyDKPUG/5gW3IP0JtBm/sQiho0Ec70+bWxFHAbRJlA877LBk4r/RRhuF4447LglUzDB4zDHHpK8En/rUp8Lhhx/er9LwkfHlL385fZ1EON1ss83Sw/yqq64K55xzTjrOzGHcFDl0cppcx/6su10A5avovvvum8zgMy8eml/4whfCnnvuGaZMmTIoa+KcV621AmgtKh7rZgIKoN3c+7a9moACaDUR94dKAKECYSwPLeTFEYvCvqx9hlpmM9NnwUcBdPBUGapOn2cXAexjWcrQe5YsZMGagNCFZR4iFAu/jRFAEKQY4op4xPZICrSHuufrnjZh6JJDdm+QZ6gmPoHjCGSIgHnhGEuOk10YICjxso94Aks+PCAOcp5z2WKX/cGGfD+Qvj8CaLkc0vIegoiEX0cs7KjTSA2IolgisuQZxHlfp5/7G+hThDKGUpff9fubvtXxuKYQMHmH5eNGX4FnfZ6IjD7vKz73MxwYDs56IAz7qsNwneO6RdiHBYIomka9gGjOSGEsRFkaCaKcZ1Qx4i/3uWFoBJohgHZ9L+DDBP8m/INipm5+EBEw3z/zzDOT1d7MmTPD/vvv369/zhdffHH6J4XvR6xHCTwM8f2II28sPRFDDzjggHSOP52cpqikG3UJMEwAsfuGG24ohmEQmYfiEUccka6hRg/Hupl7QgISkIAEJCABCXQIAUQSLPVYcO9EYChqFkIYYtjXy2OHNMNqDIEA4mW7LbiGUP0BJ0WwRBxDqGXNtY91Ku93wxEQiQcSsNJl0iiMd1j6ssQbSL6N4iLM4reRZerUqSk69z7PAj6Q8KGEJQvlCLUs9SzIyQ+miEQwYJs1/PPCMRbEYhaeR1kgRpDlWZStSBFKYIFAz0LdiFMvIOixIICVA9oAYmZ5QSBFCKPscqBtTCzHwvWC6IVYxnYnBfpn9uzZqa2I6tUBblxTiNrM1v5YfK7Tj/UCfcaQdoRfRE+uiWo29dJ2wnH6B0MlFq4RhF6uA6xEaT/XVQ7cb7iDYCFgVVwezs+zoXwPcw/cdNNN4c477yz4YHVsaB+BrhdAb42z3BF4cGfxMx2If3iwMaMXDnIRQRnG3Ffg6ydiKoGhztWBYwigP//5z8N+++2XHvCdnKa6/u6/S4ChH/TjBRdckB6S754J6Uch/j+PPvroMHHixPIptyUgAQlIQAISkMCoIoAQwUsfCwHLY16wsRhi+DzrZg5nHVXwbExHEcB1GeINhjC8B2K51uliL/VkwV8h4g2CC0IoQiT3X3+HqTejI+CH4MfSV0BQytazxMtiZl9phnqO8hBBs9AJJ8QsJsxh2Df7ZaErl4doiwDIUg4IsdltA2ssRxG2WBDFsCrMQhkCG5N3MRwaFw+0t5WB64JrAWGPBQtuAu2l/dnNSRbRGw2DR9zkeY91Zx7WDo/REHLbeA58/OMfT1bXCKFYiGL5ijBcDtxfWNCyEEiPQM4zhDxYEM+5Bu677760cI3gCoBFI6kyzdZsd70A+sADDyTSDH+vFbIAiuDVSADlSwoPGEQvLvbqwBcRTMJ56DzxxBPpa0Enp6muf7fu80+ABxZf87D2vP3229MP+2oeCOif/vSnkyXxytF5skECEpCABCQgAQl0GwFe/ll4MSYgPCAGID5gicULIyIEv6/4TcxvZ4MEWk2AYeuID1m8QqQYaUPxq5khvmQRDp+UBKz5ELlYuA9ZuP8wwmlXQABstQiItWh+NjFpUXXgOYUIygcbPuAgCrJmqeVmAGtPRneyVAfEQAQvhGmshlly2YjqiKGIxAhgXH+ca2agLdQfnSH76OR5S7/T/7QzC8DEbRToK/QNLB0Z4Ui9yy4fGqUfyeexPv7gBz+YFtrB/7DsCoAJoxBEywz5f5avm9/+9rdF07GS5d7kmcOSrw00I/JnRAVcO/2DS9GgEbzR9QIoXzoIPJhqhXz8ySefrHW6x7FGeRGZ/DAhJz8eIp2cpkfj/r7DP4B6XxLzkAseArW+oNXKbyQcO/fcc8OJJ55Yt6o8rPbee+9w8MEHF//AWt1+HratLrMuEE9IoI0EeP54P7SxAyy6owiUhaXR9r+5o0BbmYYE+P2bf1OXI/O7MoszWGOx8JLO8NXhCPlFlXujfH8MR1nm2T4CiA2IUAxFRajBMhGRCfGJBXGqloAzGn9LI+BkS7Ryj2CVzTsdAg7vcLQdUZg14h73INvcJ/m3FWk4zrDp8rqc70jdLovHCFLlwDMpi1oIi3nho06tAD+EVJa+AmVyHbJk1xKs6Ye8ZDcACLiE/L+cZyd9gJCNKJddDVAnllpD2/uqS/kcoiyCJ0IxRj1Ye1ZbeI7m52duW16X2dAviJXZBQycMWzDQhh9h23+j1UH7p18DVWfy/vcq3yE4fmUBfQsmHI8XxtcLxhesWT3EBzjeqKfeP6xIFzzvBtNM9LnZ3StvskcG627XgDlgUGo9aOM4/mLTI7HsXohx6mXF+mq8+vkNLXaed111yW/lrXO5S8W/DNt9MCvlb5Tj1V/DeZhwjCTbbbZJmy77bZh7bXXTlXnHxFLOwL/DEcT83YwtMzRRcD7YXT1p60ZOoE85G3oOZmDBJpLoJZAw4s9L/H5JZ81L5p5QWDI4gwvfdkXIL+HeNFkIU5es825HMifZSCBMvgNmMW1vM4voKwRK4hDPcm/XF+2y3Ur12cg9RgJcTMn6sqLKu2ubi/9luOxzkt+gc8CJi/5Wcgkv9zfOW3mX37pJ05fIYtFfcXplnNYvg4lcB8ioCLEsS4v+T7j2ucezPdAFjGGUm4r03ItIgiylANtzR9wylaVCKZ9+czMeXBvwI2F9K0M3COIY1glIngybDtP/sT9Vg75OVY+1g3bWadp1FbcGrBsvPHGKSrXRRY7eR9h4TppdE3AOV9HjcqsPr/BBhuEssVpPr/ddtuFiy66KO+O+HX+v60AOsiu5B9xFqyqRa6cJV8MCRl2Pl5rzcOLUC8vzuX8crmdnIb6GkLYbLPNwuc///k0lIuvPQwp4euPQQISkIAEJCABCUig+QR4Aa9+CR9qKbww8ds/r/M2++Uli2cIbFn0ZM3SzECZCEEs1IV1PlauW3m7Vj2pV65z3mafJde5Og/2CeRXHaqP5TxYV2+zTzlZvMzr6jzL+zn/XOfyObdHHgH6nPfb/I7bnxZwDXC9I4zn659rMt8DnC9fs3m7nHe+jqrXteKUj7VqGzEri18MP8/CVnZDgMEQC6IYH3toezMCHwTQIliy5X22Isyz3CN6I9jx0cDQOgLoP7hMyP55sSTOAjpWo9k9xWCuBT4w1Ar5WV/rXLce6+qrnn/amAuj0tcTOPNxHiaNQraA5IFXL+T88o+6Tk5Tqw18IcIvaq0AozvuuCM9TPvDq1YenXiMIe7nnHNOJ1YtfUnNFRtNzHObXEtgoASylYn3w0DJGX80Esj3A23jRSeLF6OxrbZJAv0hgFjCi6L3Q39oGWe0E8j3A+1EkMbS0dA8ApMnT+53ZmgEWBxmC9psdYkYloVhMit/cOC3LguGOWgaiND2Yb+R143IbyfujeFgmYfO1y08nkAUZ9QOSxbIuTaytTBCKtcLS75OELwx0sofFfJ6/fXXT9dIX+WNpHP5g8dQ6tzVAijgMPvGX0M9k+R8PAuVfcEmLwJfc+qF6vw6OU2tNnzsYx8LLLUCX68wv+bhy5cmw/AT4AsSga+vMh9+3pbQ+QR4/vLj0fuh8/vKGg4/Ae6HPISLH8cMJTVIoJsJICRglcVvVQQDgwS6mUC+H2DARwF/O3Xz1WDbMwEsMbk32nU/tKvc3P5OXmdjwqF80G/uWI5OplWnblmAzMJkdbQsZuKItlFolBfpq/Pr5DSN2ut5CUhAAhKQgAQkIAEJSEACEpCABCQgAQl0OoGuF0DxhUF45JFHavZVPr7WWmvVPF8+mPPCorSWHwbMmPHvgGK9+uqrp6SdnKbcNrclIAEJSEACEpCABCQgAQlIQAISkIAEJDASCXS9ALr11lunfrvxxht79R9OY2+++eZ0fL311ut1vvrA8ssvH9Zcc83kyPjuu++uPh1uueWWZE5NnDyJTien6dUAD0hAAhKQgAQkIAEJSEACEpCABCQgAQlIYIQR6HoBdMqUKWHllVcODz30UJg5c2aP7rvkkkvSjG0rrbRS2GijjXqcu/POO8MNN9wQHn300R7H99hjj7R/4YUX9vArir+hSy+9NJ3bfffdR0yaHhV1RwISkIAEJCABCUhAAhKQgAQkIAEJSEACI4xA10+CxExq06ZNC8cff3w4+eSTw1133ZWGp8+aNSttM/vXEUcckWZcK/ft9OnTAxPQkHbSpEnFqalTpwaGy8+ePTvst99+Ycstt0yzcWFhOmfOnLDJJpuErbbaqojPRien6VFRdyQgAQlIQAISkIAEJCABCUhAAhKQgAQkMMIIdL0ASn9tvvnm4ayzzkoCKMPUWQhYhh566KFh3XXXTfv9+cNs3DNmzEj5XX/99QErUgLHd9ttt7D//vsnH6DlvDo5TbmebktAAhKQgAQkIAEJSEACEpCABCQgAQlIYKQRGFOJYaRVejjri5UmkxgxOdGyyy7bS6wcSNlvvfVWePjhhwOIJ06cGMaPH98weSenaVT5V199NWywwQbh1FNPDTvvvHOj6J5vAgGskAmI6HlCrSZkaxYSGLEEXn755fD666+HZZZZZsS2wYpLoFkEuB9ee+21lN0SSywRxo0b16yszUcCI5LA22+/HXBLtfjii4eFFlpoRLbBSkugWQTy/UB+jHpcaqmlmpW1+UhgxBKYO3dumrfF+6HzunDevHnJOPGkk05KxoWDqaEWoFXUllxyycDSjDD//POHNdZYY0BZdXKaATXEyBKQgAQkIAEJSEACEpCABCQgAQlIQAIS6AACXT8JUgf0gVWQgAQkIAEJSEACEpCABCQgAQlIQAISkIAEhomAAugwgTVbCUhAAhKQgAQkIAEJSEACEpCABCQgAQlIoP0EFEDb3wfWQAISkIAEJCABCUhAAhKQgAQkIAEJSEACEhgmAgqgwwTWbCUgAQlIQAISkIAEJCABCUhAAhKQgAQkIIH2E1AAbX8fWAMJSEACEpCABCQgAQlIQAISkIAEJCABCUhgmAgogA4TWLOVgAQkIAEJSEACEpCABCQgAQlIQAISkIAE2k9AAbT9fWANJCABCUhAAhKQgAQkIAEJSEACEpCABCQggWEioAA6TGDNVgISkIAEJCABCUhAAhKQgAQkIAEJSEACEmg/AQXQ9veBNZCABCQgAQlIQAISkIAEJCABCUhAAhKQgASGicD8w5Sv2XYxgbvvvju88cYbXUygdU1/8cUXU2Hvec97wqKLLtq6gi1JAh1K4PXXXw9vvvmm90OH9o/Vai0B7od58+alQsePHx/Gjh3b2gpYmgQ6jMA777wTXn755bDwwguHBRZYoMNqZ3Uk0FoC+X6g1Pnmmy8sssgira2ApUmgAwm89tprgXvD+6HzOqcZGpMCaOf164iv0U9+8pPAYpCABCQgAQlIQAISkIAEJCABCUhAAhKQQLsJjKnE0O5KWP7oIYDllaF1BDbccMNkbbvCCiuEa6+9tnUFW5IEJCABCXQ8gRkzZoR/+7d/S/U888wzw1ZbbdXxdbaCEpCABCTQGgJz584NW265ZSps/fXXDxdccEFrCrYUCUhAAkMgMP/884cxY8YMKgctQAeFzUT1CDi8rh6Z4TmO4PzWW2+lRfbDw9hcJSABCYxUAnzj5n8EAVcp/p8YqT1pvSUgAQk0nwAiQv4f8fbbb/s/ovmIzVECEugwAk6C1GEdYnUkIAEJSEACEpCABCQgAQlIQAISkIAEJCCB5hFQAG0eS3OSgAQkIAEJSEACEpCABCQgAQlIQAISkIAEOoyAAmiHdYjVkYAEJCABCUhAAhKQgAQkIAEJSEACEpCABJpHQAG0eSzNSQISkIAEJCABCUhAAhKQgAQkIAEJSEACEugwAgqgHdYhVkcCEpCABCQgAQlIQAISkIAEJCABCUhAAhJoHgFngW8eS3OSQMsJnHXWWYFZGxdaaKGWl22BEpCABCTQ2QQ+8YlPhMmTJ6dKrrvuup1dWWsnAQlIQAItJTBhwoQwffr0VOYSSyzR0rItTAISkEA7CIypxNCOgi1TAhKQgAQkIAEJSEACEpCABCQgAQlIQAISkMBwE3AI/HATNn8JSEACEpCABCQgAQlIQAISkIAEJCABCUigbQQUQNuG3oIlIAEJSEACEpCABCQgAQlIQAISkIAEJCCB4SagADrchM1fAhKQgAQkIAEJSEACEpCABCQgAQlIQAISaBsBBdC2obdgCUhAAhKQgAQkIAEJSEACEpCABCQgAQlIYLgJOAv8cBM2fwkMA4EHH3wwXHHFFeHxxx8P48ePD+uss07YaqutwiqrrDIMpZmlBCQgAQm0ksC1114bfvCDH4Svf/3rYa211qpb9GD+F7QqTd1Ke0ICEpCABAZMYM6cOeHyyy8PDz/8cHj22WfD0ksvHSZNmhQ++9nPhve9730185s3b1648sorw7333hvmzp0bVl999bDeeuuFHXbYIcw333xtTVOzcA9KQAISGGYCzgI/zIDNXgLNJsAPmenTp6dsJ0yYEN544420LLTQQuGUU04J66+/frOLND8JSEACEmgRgVmzZoVDDjkkvPXWW2HGjBnpZbVW0YP5X9CqNLXq6zEJSEACEhgcgVtvvTWcfPLJ4fXXX0/C5ZJLLhkQRN9+++3A7/8jjzwybL311j0yf/HFF8NBBx0UnnzyyXT8ve99b3jhhRfS9uabbx5OOOGEsMACC7QlTY9C3ZGABCTQQgIOgW8hbIuSwFAJ8GJ8zjnnpB8sJ510UvjFL34RfvnLX6aXZX4UHX744eGZZ54ZajGml4AEJCCBNhC47777wjHHHJPEz76KH8z/glal6avenpOABCQggYER+POf/1yIn/vss0+47rrrwo9//OO03nvvvZMoigFEFjpz7t/85jfTsY022ij8/Oc/D1dffXW47LLLwqqrrhpuu+229D6R4+Z1q9Lk8lxLQAISaDUBBdBWE7c8CQyBwMUXXxwqlUrYa6+9Al9vx4wZE8aOHRt23333sNtuu4U333wzXHXVVUMowaQSkIAEJNBqAn/5y1/CGWeckT5mMUzxPe/p++fZYP4XtCpNq9lZngQkIIHRTOCaa65JIuc222wTvvSlL4UFF1wwNZf1tGnTwhZbbBH++te/BuLl8Ic//CHcc889yTr0W9/6VlhsscXSqRVWWCGceeaZyYp05syZ4ZVXXslJQqvSFAW6IQEJSKANBPr+hd2GClmkBCRQmwAvyPyYIWy//fa9IuVjfOVl6KRBAhKQgARGBoH99tsvWecsvPDC4fjjj09+3erVfDD/C1qVpl6dPS4BCUhAAoMjwMgAwmabbVYzAyw8CX/605+K8wyZJ0ydOjWMGzcubec/DIXfcMMNk/ssRNAcWpUml+daAhKQQDsIKIC2g7plSmAQBGbPnp2sPydOnBiWX375XjmsueaaYZFFFgkvvfRSeOKJJ3qd94AEJCABCXQmAXy18RHroosuCttuu22flRzM/4JWpemz4p6UgAQkIIEBE8D11Y9+9KMwZcqUmmmzX8/FF1+8OP/AAw+k7SyOFif+voEASrj//vv/fiSEVqUpCnRDAhKQQBsIKIC2AbpFSmAwBPABRCj/wKnOJ5+r9gNUHc99CUhAAhLoHAIXXnhhOPbYY8Nyyy3XsFKD+V/QqjQNK28ECUhAAhIYEAGGumP4wAiB6sCIr2zFOXny5OJ0o2d+rfeFVqUpKumGBCQggTYQUABtA3SLlMBgCLz22mspWf7RUiuPRRddNB3OcWvF8ZgEJCABCXQWgWWWWabfFcrP94H8L2hVmn43wogSkIAEJDBkAt/97nfDU089FfDtudNOOxX5NXrm13pfaFWaopJuSEACEmgDAQXQNkC3SAkMhgA+3AgMc68XJkyYkE7hDN0gAQlIQAKjj8Bg/he0Ks3oo22LJCABCXQmAWZ0Z2HSvKOPPrrw9fnOO++kSZGodb13hvy+MG/evNS4VqXpTJLWSgIS6CYCCqDd1Nu2dUQTGD9+fKr/G2+8Ubcd+YdMniGybkRPSEACEpDAiCQwmP8FrUozIoFaaQlIQAIjjMD3vve9cO655ybxE/cp6667btECBNGFFloo7ef3guLk3zfy8QUWWCAdaVWa6nq4LwEJSKDVBBRAW03c8iQwSAJLLbVUSvnyyy/XzeGVV15J5/LLbt2InpCABCQggRFJYDD/C1qVZkQCtdISkIAERgiBN998M3zzm98MP/zhDwPi5Te+8Y2aE+flZ35+L6huXj5efl9oVZrqurgvAQlIoJUEFEBbSduyJDAEAo1+mJB1FkeXWGKJIZRkUglIQAIS6FQCg/lf0Ko0ncrMeklAAhIY6QQQLQ877LBw/fXXB3x4nn322WHq1Kk1m9XomV/rfaFVaWpW2IMSkIAEWkRAAbRFoC1GAkMlsPTSS6csmOGdL8DV4aWXXgovvPBCGg6z+uqrV592XwISkIAERgGBwfwvaFWaUYDXJkhAAhLoOAIIlgcffHC47777woorrhjOO++8sM4669StZ37mP/LIIzXj5ONrrbVWcb5VaYoC3ZCABCTQBgIKoG2AbpESGAyB5ZdfPqy55prh1VdfDXfffXevLG655Zbw9ttvpzgLL7xwr/MekIAEJCCBkU9gMP8LWpVm5NO1BRKQgAQ6i0ClUglHHXVUePjhh8Maa6yRxM+JEyf2Wcmtt946nb/xxht7xWPCo5tvvjkdX2+99YrzrUpTFOiGBCQggTYQUABtA3SLlMBgCeyxxx4p6YUXXhiy/x4OPPfcc+HSSy9N53bfffe09o8EJCABCYxOAoP5X9CqNKOTuK2SgAQk0B4C11xzTZg1a1ZgiPrpp58eFltssYYVmTJlSlh55ZXDQw89FGbOnNkj/iWXXBLmzJkTVlpppbDRRhsV51qVpijQDQlIQAJtIDAmflWqtKFci5SABAZBAAvPAw88MMyePTtg0bPllluGt956K/CFlx8zm2yySTj55JPTMPhBZG8SCUhAAhLoAAJf/OIXk7XPjBkzQtlCJ1dtMP8LWpUm19G1BCQgAQkMjQCzte+yyy6F0cN8881XN8PVVlstnH/++cX52267LRx//PFpdBjvC7jHQki96667wtixY5MP0fLs8SRsVZqikm5IQAISaDEBBdAWA7c4CQyVAD+GzjrrrOQEPfsC5QcRP5D233//MG7cuKEWYXoJSEACEmgjgUYCKFUbzP+CVqVpIzqLloAEJDBqCDz44INh2rRp/WrPqquuGi666KIecfEZimHEM888UxzHMvTQQw8N66+/fnGsvNGqNOUy3ZaABCTQKgIKoK0ibTkSaDIBLD/xB4QRN76Axo8f3+QSzE4CEpCABDqdwGD+F7QqTaezs34SkIAEuoEAo8SYRJWJjpZddtl+jRRrVZpu4G8bJSCBziGgANo5fWFNJCABCUhAAhKQgAQkIAEJSEACEpCABCQggSYTcBKkJgM1OwlIQAISkIAEJCABCUhAAhKQgAQkIAEJSKBzCCiAdk5fWBMJSEACEpCABCQgAQlIQAISkIAEJCABCUigyQQUQJsM1OwkIAEJSEACEpCABCQgAQlIQAISkIAEJCCBziGgANo5fWFNJCABCUhAAhKQgAQkIAEJSEACEpCABCQggSYTUABtMlCzk4AEJCABCUhAAhKQgAQkIAEJSEACEpCABDqHgAJo5/SFNZGABCQgAQlIQAISkIAEJCABCUhAAhKQgASaTEABtMlAzU4CEpCABCQgAQlIQAISkIAEJCABCUhAAhLoHAIKoJ3TF9ZEAhKQgAQkIAEJSEACEpCABCQgAQlIQAISaDIBBdAmAzU7CUhAAhKQgAQkIAEJSEACEpCABCQgAQlIoHMIKIB2Tl9YEwlIQAISkIAEJCABCUhAAhKQgAQkIAEJSKDJBOZvcn5mJwEJSEACEpCABCQgAQlIYMgE3n777fDHP/4xPPTQQ2HVVVcNa6yxRhg7duyQ8zUDCUhAAhKQgAS6j4AWoN3X57ZYAhKQgAQkIIEmEECMGTNmTN1l4YUXDhMnTgxbbrllOPXUU8Nf/vKXJpTaeVn84z/+Y2Lwnve072flPvvsk+qwyCKL9AD0+OOPF/1zxhln9DjXaOeOO+4o0tbqZ9q74IILhsUXXzx88IMfDIceemi4//77a2Y7lHrUzHAUH3z55ZfD0UcfHT760Y+GCRMmhMmTJ4edd945rLPOOmn/wx/+cNh///3DY489NmwU6l1Pw1agGUtAAhKQgAQkMOwE2vdLddibZgESkIAEJCABCUigfQRef/318NRTT4Vbb701HHXUUWGLLbYIzz77bPsqNMwlVyqVYS6hcfatrANlvfHGG+Gll14Ks2fPDmeffXb40Ic+lMQ6LBcNAyfwwAMPhA984APhX/7lX8K9994b/vrXv/bIBN6/+93vwve+970kOl9yySU9zjd7p5XXU7Prbn4SkIAEJCABCfQk4BD4njzck4AEJCABCUhAAgMisNBCC4Vjjz22R5q33norWXz+7//+b7jlllvCk08+GX7zm9+EjTbaKGBZuOKKK/aI705nE9hss83CDjvs0KuSb775ZnjttdfCf/3Xf4Wbbropnb/66qvD4YcfHs4666xe8T1QnwCWn9tvv33xkWDTTTcNBx54YFhttdXCMsssE+bMmRMeeeSRcP7554frrrsu8IHhi1/8Ylh++eWTlXX9nD0jAQlIQAISkIAEQlAA9SqQgAQkIAEJSEACQyCAAMqQ3XoBYQeh5qc//WlgKPRpp50WzjnnnHrRPd6BBKZMmdJnH1PlH/zgB+HLX/5yePXVV5M16J577hk+8pGPdGBrOrNK3/nOd8Kf//znVLmvfvWr6T4p13SllVYK66+/fthtt93CueeeG3C9wIeGI488Mtxzzz3lqG5LQAISkIAEJCCBXgQcAt8LiQckIAEJSEACEpBA8wgsuuii4bvf/W7yJ0muv/jFL5qXuTl1DIG999477LvvvkV9sPQ19J8AVp2E8ePHh5NOOqnPhAjN22yzTYqDZfWDDz7YZ3xPSkACEpCABCQgAS1AvQYkIAEJSEACEpDAMBN43/vel3wW4uMQn5F9BYb2/s///E8SdZgBe9y4cWH11VdPC5Pt9DXZED4SGXLPrNn4G11llVVSuaSrniCoVh3weUja3//+94G6Mrx4vfXWSxPQYOnan/DOO++EWbNmhbvuuiu88MILaTIbJrRhsqD+BKwAEbRYnnnmmbDyyisXbV9qqaX6k0Xb4uy0005h+vTpqXza/5WvfGVAdRlo3z/99NPJzyyFMCnXYostVrc8hurTpwRmVF9yySV7xB1M3+MC4L777kv5cI0x8devf/3rcPPNN4flllsu7Lrrrr3K6VFoaef5559Pe8suu2y/Znr/5Cc/GW688cYw//zzp/tlzTXXLOX27uZAmb6bsvHWYK5VJm967rnnUl/RZ2z/7Gc/S+uPfexjyVcwoi79wSRQcO0r8Kx48cUX03Ni3XXX7Suq5yQgAQlIQALdTSD+czVIQAISkIAEJCABCQyQQJyshVl/Ku9973sbpoyTuVSiZVuK/5nPfKZu/PPOO68SRY8Uj7yrl+hDtBLFxZrp4xDsShQse6UhD/L8/ve/XzNdPhiFzwr5V5fJ/tJLL1255pprctQe62iNV6SJgmclWuYV+zmv+eabr3LKKadUojjaI215J7oHqGy99da90uY8ohBciZPjVKLoVk6WtqOLgZQOxuUQxaYiv9NPP718quH27bffXqSNQ7IbxifCn/70pyJN9BlapOlPPQbT91FoLMo7/vjji/JqbURhtogbRbMeUQbb99HHbZHnnXfeWfnc5z5X7NNv0fq5El0C9Cir3k6+jsaMGVOJPlXrRSuOc09F4a/Yr7UxGKbkU+96ymUM5VqNM9gnRtttt13l7rvvrsQPEz2YfeMb36hsvvnm6VgUlCuvvPJKLrbXmnuBexPW0eVCr/MekIAEJCABCUjgXQJagMZfDAYJSEACEpCABCQwnAQuvPDCNFkOZWAlWB3iT7N0fObMmekUlpf4nYziasDKDx+HWMhFwSRsvPHG4YknnghLLLFEkQ3+RfEzivUlx7faaquUlnRYc+KXctq0ackCsNbkPD/5yU8CQ7ixEowCVLLanDx5cpq8iTywUvvEJz4RjjjiiHDqqacW5VZvMMkTFqRY8TFx0Lx589KkT1iiqLAPAAATW0lEQVSCHnXUUan+V155ZS8r1htuuCF8+tOfDlHsSec22WSTMGnSpMBs6li4YRHHjOBf+9rXUpxGQ6Sr69WqfVjnsPbaa+fNPtdD6fstttgiWchiVciM6CeeeGLdsvBRSoAtFsU5NKvvo8AeLrvsspxtWlMWQ9r7E3bcccfk2xMeTIaEX11cCtSzXF5wwQUDS60wFKa18isfa9a1imXq5z//+XQ9l/On7RMnTgy33XZbmkiNe/sf/uEfylGK7V/+8pfp3uQA979BAhKQgAQkIIE+CMQfCAYJSEACEpCABCQggQESyBagcdhxssrEMjMvUQhL1l1XXXVVJQp7hYXXIYccUomiXq+Srr322iIOlnBxKHuPOFiBRYGjiHPyySf3OB+H/6Zzcch7L4u7OEy3EieQSeexkKy2KMNqMw6HTuej8FK59dZbe+QdhdfKtttuW5QdfVv2OJ8t9+LPzRQnijWVKO4Ucci/nP7SSy8tzuWNOEQ+paUe999/fz5crLEuxJqQMqLAW4lCbXGOjcymnRagtDkOVy44RaG3qGNfFqBD7fsTTjihKDMOPy/KLG/Eoe9FnLIl8FD7vmwBSt/EYe+VOJlRJQ6Lr5x99tmVm266qVyNPrfjhEaVKNIX9SS/sWPHJmvIb33rW5XoUqCm9W+tTIfKtN71RFlDvVazBWi+X7Dc/NWvflWhzscee2xqDvdotgTHUrRewJqcfLhvaz1X6qXzuAQkIAEJSKAbCeBfxiABCUhAAhKQgAQkMEACWQDNQkajdbRarFsCIgfpV1xxxQpCUK3AUOLo7zDF+9SnPlVE+b//+79CNIrWncXx8sYPf/jDSrSWq0Sfg70EzjibdkoffYtWEBprBYbakpY6xpm4e4gtZQE0+jCslTwJlnmoLvmU24hol9nFyaJqpudgtP4s4iGwlUM9waov4bGcvtZ2eQj8YYcdlupMvcvLnDlzKojdiIqrrbZaUb9o+dhjuH9f9RhK31PvRx99tMKwcRgedNBBtZpSida36Xz041qJPmiLOEPt+2oBNE5kVOQ92A3uk9yefF3kNaJgtBStnH/++ZW5c+fWLWKoTOtdT824VssC6KabbtrjXio3KNcB9xFwrg4M/8ctBGyitWz1afclIAEJSEACEqgi4Czw8VeDQQISkIAEJCABCQw3gW9/+9shWuuFKKD1Kir6xwyXX355uOCCC0IUPHqd5wBDiaNAms4xpD0HZpnPw4wZXs5w8+oQrczScFomFpo6dWpxmiHmDF0mMASZSVhqBSaaidar6VT0zxj++7//u1a0EP0X1jzO5DiHHnpoOsfETr/97W+LeFFITpPZRPEz7LHHHsXx6g0mjMmh3P58bDjX9B0MqhcmEvrQhz6U3AtE/5+pCkz+Q1twJdCfMJS+J/+V4yRRDIUn/OhHPwpMTFQOuEX493//93Rol112CVwvhGb3Pf0ThceU91D+MPSdyZr++Z//OURRuUdW9DtuIvbbb7/U7hkzZiS3Dz0ixZ2hMq3OL+83+1qNHw96uYPIZe2zzz5pk36KVtP5cLHmeYFbCMIXvvCF4rgbEpCABCQgAQnUJqAP0NpcPCoBCUhAAhKQgAT6RQAfhfhfrA74+ItWaskH58UXX5yESQTC3/3udwG/i2Wh88Mf/nBgqRWYNT4OCw9xaHqIFocpSllEXWCBBZLPzzhJUYgWnAGRhhmy4yQ8IQ49Tz5BEeNqCXL4EsVPJwEhj/rWC+SbA34+q2ecpj1lcTXHzWv8QeaACLrhhhumXUTEOPlRWvL5vEb8idaTaUb5sghUbn+O2+41/igReY855pg0e3d/6zOUvs9lIJbdcsst6frALyT+WnPg+FNPPZV2o1VhPpz8yDar78m07Fe0KGSQG2uttVZAdGaJFq5JIKcdLM8880zKlfsCUZ57I4v4ubhmMM15ldfNvlb7YhYnQgqrrrpqePjhh5OAnT8g5Ppkn658tCjfm/m8awlIQAISkIAEehJQAO3Jwz0JSEACEpCABCQwIALRT2EPwalW4jjUOER/fcmy7Wc/+1lAvMgWXuX4CJxYdkVfoikuQuGzzz5bjlJzOw4JTnVgwiLyYNIlFkRJJlNCEMW6kslVyoEJhnKIfkUDS38CAmh1WGGFFZKFZPXxvF8uu1Z64iFwIfRiATh79uyAVWX0h5qzaNsaMarW5FVMUhX9qyZrxPe///11J+XpT8UH2/fkzQRSXGMvv/xyEsvKAmgWyrAeRmjOoZl9T57V1pq5nKGumQyLCbxY4ki2NCFY9JWZRFHy5trfcsst04RC1WUNhWl1XtX7zbhWGzFDsD7uuOMCVtfcDwjDhEceeSRNLsZ2WdRm3yABCUhAAhKQQG0CCqC1uXhUAhKQgAQkIAEJNI1AnBwnnHbaaYWIxhDpagGUob/Tp09PQ9WrC8ZSDAHuP/7jP4pZn8txon/NJB7GiWeSuIpwSsCCEqtQFoQU8j/ggAOKpNkysDjQz40nn3yyV0ys4/oKiIU5MNt7OWDFh5ATfXuWD6dthvcjQMbJpnrNMt4r8jAdYHb7I444YphyD2nG88H2PZXCxQACO2IglsAIoQx1j5NFJWtj4jCTePTzymYKzex7MlxqqaX+lvEw/sWKmb5gJnZ4feUrX0mlMRSeGdXLYSj3Uzmf6u1mXau4U+Ca7iswtB23GdmNQfSPmqJHn75pHX26pn7vKw/PSUACEpCABCTwNwIKoF4JEpCABCQgAQlIoAUEsFJDsGBoPL44yyFO8JP8FnIMoTBOchQ+8pGPpGHm66yzTiGUxFnly8l6bCOCIfqwMGyWodBxUppw8803JyEMS8oDDzwwiSlxspyUNvsUZQdLwZ133rlHnvV2GHZfHWr5Hi3Hefrpp4tdhvbmwBB3huvHiV7SIYbKY6nIEHsW4iLc4Ubgsssuy8lGzboZfQ8MBHUEUK4vXCwgKP/0pz8N2V8q++XQzL4v5zuY7TjLe0DUixN6JetnrIkbhYMPPjjdMwyJr/ZJ2yym1XVo9bWK1TT3AoIvHz+yAJp9unK/NhJRq9vgvgQkIAEJSKBbCSiAdmvP224JSEACEpCABFpOIPuuLFtDMkz31FNPTXVhiCtiRz0BKIuMWHb2FRANmWCFhYlSsAxFFCJcccUVIQugZR+EWI3iz3Sw4bnnnksWp2XfpuW8EI9yKA/9jTPXF+InPh+Z/KZWyG3nXKP210rficea2ff4gmQiIvrxxz/+cSGA0u6NN964l5/IZvZ9M9jmIfnUPU+41Ve+iOJYViOAcj0wPB4L0WYyrS6/HdcqwjbPBO4fJg/j40OecKta1K6ur/sSkIAEJCABCbxL4N1xMO8ec0sCEpCABCQgAQlIoMkEfvWrXxUzdJdnW7/tttuSeENx+++/f13xEx+ADG0mZCGVbYY8f/zjHw+rrLJKmhCGY+Uwbty4cNRRRyWLUo7jJxSxiLBynEGc84Rrr7225oza6WT8g3DKRElYp95xxx35cLHG8hBr03qBGcoJiFTZlyH7+PwkMIQ+D2lOB6r+/Od//mdxpNz+4uAI3Bhq31c3OQtiN954YxICsQAm5OPl+M3s+3K+g9kuT56FpS/XUqPw4osvhttvvz1FW3PNNYtJvprNtFyPdlyru+yyS1h88cVTNbAAv/rqq9M2H0m22WabcvXcloAEJCABCUigDwIKoH3A8ZQEJCABCUhAAhJoBgGs28o+P8uT0ZQn+WHoeq2A8Ln33nsXp958881iG1+PM2fOTLNl4y+wXsiiJ9aAeUZ4rOj+6Z/+KSVhdvrvfOc7NZMzjPr4449PAuv1118fEJxqBWa5ryVeId5mv4V77rlnmjgop8/txy9ovQmfGPKLAJtDuf352Ehc57ZT98H0fXWbuUawwMXqF5+l+ABF4P7sZz9bHTW5FWhm3/cqYAAHNttsszRZF0mY8IdrNFs51sqG64RJvfJ1sN9++xXRms20yDhu5Lxbea3Sf5/73OdSNRBAmUSNUO3TNR30jwQkIAEJSEACdQkogNZF4wkJSEACEpCABCTQmACCX55BvbzGryH+OBE7sXhkqC4Ba00mN8nhox/9aCFIXnDBBQFL0TzEm8lPEIRIc++99+YkYe7cucU24lH2qYlA8q//+q+FMEQkxFMsKxk+S6j288mM2nnIPYLYMccck4Qz4s6bNy+Jq5Sf/ZYyfL7ehDdYhu66665JjCU9oivDd5nEiDbhA7V6pnkmtSEgLsErc+LY888/n0RZLBizgMvxcvvZH6lhqH1f3e7ll18+bLfddunwhRdemNZ9+YlsZt9X12Wg+/gvzZaOv//975PFMmI5bhGwLOY+QAjHmhnfsPi4JWy44YbhS1/6UlFcs5kWGceNdl2r+eMJvk5/85vfpCrVsuot19VtCUhAAhKQgASqCMQfkwYJSEACEpCABCQggQES+MAHPsA48gEtUQisRPGuV0lf/epXe+QTh4NX4qRJlTjBSXE8WvFVohCS9qMfwB75zJo1qxL9dxZx48zplcmTJ1eiT8hKtCArjsch9pUoNPYqPw4lrsQJV4p40TI0pZ0wYUJxjLZGcbMSh5/3SB/9jKY4lLXjjjsW8SdNmlSJvk6Lfep35ZVX9kjLTpxRvke8aJ1aiSJWqj/blLvMMstUokBWiTNnp/1o3dgjnygGpeO0uxyi38Si/NNPP718quE2THL/0j9DCX3VY6h9X12vyy+/vKg39Y9CYXWUHvtD6fs4cVVRVhT8e+Q7mJ0ooPe4DjP/eusoflai79leRQ2Vab3rqRnXKvcg7eFaHkiI/k4L1lOmTBlIUuNKQAISkIAEJBAJ8DXdIAEJSEACEpCABCQwQAKNBNBo7ViJlpkVRM9ooVaJPizrlhCH8lbOOOOMSrSAK0QORBIEwLXXXrsSh7intNG3Y3EeQbAcHnjggUocFlxBvCwLRuxHC9TKeeedV47ea/ull16qTJs2rRKH1PdIT16Imd///vcr1LM6ZAF0vfXWS+LqvvvuW6HtuQ5xSHYlzuxeiW4AqpMW+wi40Z9hkSanpS4HHHBAIfZuuummKc773//+SrSOLdLXE6z6Eh6LxHU2WiWANqPvy02Iw98LQTla9vYSrMtx8/Zg+77ZAij1ie4WKtGVQiVaefa6HvJ1scEGG6TrOVoV5yb0WA+Vab3riUKGeq0OVgBFwM/tb3Qv94DhjgQkIAEJSEACicAY/sZ/pgYJSEACEpCABCQggTYTwHcjviAfffTRsPTSS4doxRmiVeOAasWQ98cffzw88cQTYYkllkgTFw00j2jpFqKgmvxHMrnSiiuumHxG9rciUYBKQ5YZQh/Fqn63IQpqqf20gbZHobNwD9DfskdqvGb0PW1ngihcGkTLyPC1r32tl8uBRnyG2veN8h/IedwhcC3jCgFXE9ESOLl7YKh/f0KzmNYqq9XX6owZM8IhhxyS3Eg8/fTThbuAWnXzmAQkIAEJSEACvQkogPZm4hEJSEACEpCABCQgAQmMSALXXHNN+OQnP5mEYybfWm211UZkO6x0TwJ8SMAP6l577VVMKNYzhnsSkIAEJCABCfRFwEmQ+qLjOQlIQAISkIAEJCABCYwQAljennbaaam2TL6l+DlCOq5BNaMLjCR+Ei26hGgQ29MSkIAEJCABCdQiMH+tgx6TgAQkIAEJSEACEpCABDqfwK9//evArOlxcqsQJ5kKcSKhVGmGvxtGLoFvf/vbIU4iFv7whz+Ec889NzUk+hMO0Z/uyG2UNZeABCQgAQm0kYACaBvhW7QEJCABCUhAAhKQgASGQgCfnQcddFCPLI477riw1VZb9TjmzsgiECc5Cw8++GBR6eWWWy5ccsklxb4bEpCABCQgAQkMjIBD4AfGy9gSkIAEJCABCUhAAhLoGAIMc19wwQVTfSZOnBiOPPLIcOKJJ3ZM/azI4AisvfbaKeHYsWPDFltsEfDtymRkBglIQAISkIAEBkfASZAGx81UEpCABCQgAQlIQAIS6AgCzPzOjOkKZB3RHU2rxPPPPx/GjRsXJkyY0LQ8zUgCEpCABCTQrQQUQLu15223BCQgAQlIQAISkIAEJCABCUhAAhKQgAS6gIBD4Lugk22iBCQgAQlIQAISkIAEJCABCUhAAhKQgAS6lYACaLf2vO2WgAQkIAEJSEACEpCABCQgAQlIQAISkEAXEFAA7YJOtokSkIAEJCABCUhAAhKQgAQkIAEJSEACEuhWAgqg3drztlsCEpCABCQgAQlIQAISkIAEJCABCUhAAl1AQAG0CzrZJkpAAhKQgAQkIAEJSEACEpCABCQgAQlIoFsJKIB2a8/bbglIQAISkIAEJCABCUhAAhKQgAQkIAEJdAEBBdAu6GSbKAEJSEACEpCABCQgAQlIQAISkIAEJCCBbiWgANqtPW+7JSABCUhAAhKQgAQkIAEJSEACEpCABCTQBQQUQLugk22iBCQgAQlIQAISkIAEJCABCUhAAhKQgAS6lYACaLf2vO2WgAQkIAEJSEACEpCABCQgAQlIQAISkEAXEFAA7YJOtokSkIAEJCABCUhAAhKQgAQkIAEJSEACEuhWAgqg3drztlsCEpCABCQgAQlIQAISkIAEJCABCUhAAl1A4P8BZAe4t7Y7AgMAAAAASUVORK5CYII=" width="672" /></p>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
